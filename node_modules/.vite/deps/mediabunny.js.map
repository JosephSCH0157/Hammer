{
  "version": 3,
  "sources": ["../../mediabunny/dist/modules/src/misc.js", "../../mediabunny/dist/modules/src/metadata.js", "../../mediabunny/dist/modules/src/codec.js", "../../mediabunny/dist/modules/src/muxer.js", "../../mediabunny/dist/modules/src/adts/adts-muxer.js", "../../mediabunny/dist/modules/src/codec-data.js", "../../mediabunny/dist/modules/src/demuxer.js", "../../mediabunny/dist/modules/src/custom-coder.js", "../../mediabunny/dist/modules/src/packet.js", "../../mediabunny/dist/modules/src/pcm.js", "../../mediabunny/dist/modules/src/sample.js", "../../mediabunny/dist/modules/src/media-sink.js", "../../mediabunny/dist/modules/src/input-track.js", "../../mediabunny/dist/modules/src/isobmff/isobmff-misc.js", "../../mediabunny/dist/modules/src/isobmff/isobmff-reader.js", "../../mediabunny/dist/modules/src/isobmff/isobmff-demuxer.js", "../../mediabunny/dist/modules/src/matroska/ebml.js", "../../mediabunny/dist/modules/src/matroska/matroska-misc.js", "../../mediabunny/dist/modules/src/matroska/matroska-demuxer.js", "../../mediabunny/dist/modules/shared/mp3-misc.js", "../../mediabunny/dist/modules/src/id3.js", "../../mediabunny/dist/modules/src/mp3/mp3-reader.js", "../../mediabunny/dist/modules/src/mp3/mp3-demuxer.js", "../../mediabunny/dist/modules/src/ogg/ogg-misc.js", "../../mediabunny/dist/modules/src/ogg/ogg-reader.js", "../../mediabunny/dist/modules/src/ogg/ogg-demuxer.js", "../../mediabunny/dist/modules/src/wave/wave-demuxer.js", "../../mediabunny/dist/modules/src/adts/adts-reader.js", "../../mediabunny/dist/modules/src/adts/adts-demuxer.js", "../../mediabunny/dist/modules/src/flac/flac-misc.js", "../../mediabunny/dist/modules/src/flac/flac-demuxer.js", "../../mediabunny/dist/modules/src/input-format.js", "../../mediabunny/dist/modules/src/source.js", "../../mediabunny/dist/modules/src/input.js", "../../mediabunny/dist/modules/src/reader.js", "../../mediabunny/dist/modules/src/flac/flac-muxer.js", "../../mediabunny/dist/modules/src/subtitles.js", "../../mediabunny/dist/modules/src/isobmff/isobmff-boxes.js", "../../mediabunny/dist/modules/src/writer.js", "../../mediabunny/dist/modules/src/target.js", "../../mediabunny/dist/modules/src/isobmff/isobmff-muxer.js", "../../mediabunny/dist/modules/src/matroska/matroska-muxer.js", "../../mediabunny/dist/modules/src/mp3/mp3-writer.js", "../../mediabunny/dist/modules/src/mp3/mp3-muxer.js", "../../mediabunny/dist/modules/src/ogg/ogg-muxer.js", "../../mediabunny/dist/modules/src/wave/riff-writer.js", "../../mediabunny/dist/modules/src/wave/wave-muxer.js", "../../mediabunny/dist/modules/src/output-format.js", "../../mediabunny/dist/modules/src/encode.js", "../../mediabunny/dist/modules/src/media-source.js", "../../mediabunny/dist/modules/src/output.js", "../../mediabunny/dist/modules/src/conversion.js"],
  "sourcesContent": ["/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport function assert(x) {\n    if (!x) {\n        throw new Error('Assertion failed.');\n    }\n}\nexport const normalizeRotation = (rotation) => {\n    const mappedRotation = (rotation % 360 + 360) % 360;\n    if (mappedRotation === 0 || mappedRotation === 90 || mappedRotation === 180 || mappedRotation === 270) {\n        return mappedRotation;\n    }\n    else {\n        throw new Error(`Invalid rotation ${rotation}.`);\n    }\n};\nexport const last = (arr) => {\n    return arr && arr[arr.length - 1];\n};\nexport const isU32 = (value) => {\n    return value >= 0 && value < 2 ** 32;\n};\nexport class Bitstream {\n    constructor(bytes) {\n        this.bytes = bytes;\n        /** Current offset in bits. */\n        this.pos = 0;\n    }\n    seekToByte(byteOffset) {\n        this.pos = 8 * byteOffset;\n    }\n    readBit() {\n        const byteIndex = Math.floor(this.pos / 8);\n        const byte = this.bytes[byteIndex] ?? 0;\n        const bitIndex = 0b111 - (this.pos & 0b111);\n        const bit = (byte & (1 << bitIndex)) >> bitIndex;\n        this.pos++;\n        return bit;\n    }\n    readBits(n) {\n        if (n === 1) {\n            return this.readBit();\n        }\n        let result = 0;\n        for (let i = 0; i < n; i++) {\n            result <<= 1;\n            result |= this.readBit();\n        }\n        return result;\n    }\n    writeBits(n, value) {\n        const end = this.pos + n;\n        for (let i = this.pos; i < end; i++) {\n            const byteIndex = Math.floor(i / 8);\n            let byte = this.bytes[byteIndex];\n            const bitIndex = 0b111 - (i & 0b111);\n            byte &= ~(1 << bitIndex);\n            byte |= ((value & (1 << (end - i - 1))) >> (end - i - 1)) << bitIndex;\n            this.bytes[byteIndex] = byte;\n        }\n        this.pos = end;\n    }\n    ;\n    readAlignedByte() {\n        // Ensure we're byte-aligned\n        if (this.pos % 8 !== 0) {\n            throw new Error('Bitstream is not byte-aligned.');\n        }\n        const byteIndex = this.pos / 8;\n        const byte = this.bytes[byteIndex] ?? 0;\n        this.pos += 8;\n        return byte;\n    }\n    skipBits(n) {\n        this.pos += n;\n    }\n    getBitsLeft() {\n        return this.bytes.length * 8 - this.pos;\n    }\n    clone() {\n        const clone = new Bitstream(this.bytes);\n        clone.pos = this.pos;\n        return clone;\n    }\n}\n/** Reads an exponential-Golomb universal code from a Bitstream.  */\nexport const readExpGolomb = (bitstream) => {\n    let leadingZeroBits = 0;\n    while (bitstream.readBits(1) === 0 && leadingZeroBits < 32) {\n        leadingZeroBits++;\n    }\n    if (leadingZeroBits >= 32) {\n        throw new Error('Invalid exponential-Golomb code.');\n    }\n    const result = (1 << leadingZeroBits) - 1 + bitstream.readBits(leadingZeroBits);\n    return result;\n};\n/** Reads a signed exponential-Golomb universal code from a Bitstream. */\nexport const readSignedExpGolomb = (bitstream) => {\n    const codeNum = readExpGolomb(bitstream);\n    return ((codeNum & 1) === 0)\n        ? -(codeNum >> 1)\n        : ((codeNum + 1) >> 1);\n};\nexport const writeBits = (bytes, start, end, value) => {\n    for (let i = start; i < end; i++) {\n        const byteIndex = Math.floor(i / 8);\n        let byte = bytes[byteIndex];\n        const bitIndex = 0b111 - (i & 0b111);\n        byte &= ~(1 << bitIndex);\n        byte |= ((value & (1 << (end - i - 1))) >> (end - i - 1)) << bitIndex;\n        bytes[byteIndex] = byte;\n    }\n};\nexport const toUint8Array = (source) => {\n    if (source.constructor === Uint8Array) { // We want a true Uint8Array, not something that extends it like Buffer\n        return source;\n    }\n    else if (ArrayBuffer.isView(source)) {\n        return new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    }\n    else {\n        return new Uint8Array(source);\n    }\n};\nexport const toDataView = (source) => {\n    if (source.constructor === DataView) {\n        return source;\n    }\n    else if (ArrayBuffer.isView(source)) {\n        return new DataView(source.buffer, source.byteOffset, source.byteLength);\n    }\n    else {\n        return new DataView(source);\n    }\n};\nexport const textDecoder = /* #__PURE__ */ new TextDecoder();\nexport const textEncoder = /* #__PURE__ */ new TextEncoder();\nexport const isIso88591Compatible = (text) => {\n    for (let i = 0; i < text.length; i++) {\n        const code = text.charCodeAt(i);\n        if (code > 255) {\n            return false;\n        }\n    }\n    return true;\n};\nconst invertObject = (object) => {\n    return Object.fromEntries(Object.entries(object).map(([key, value]) => [value, key]));\n};\n// For the color space mappings, see Rec. ITU-T H.273.\nexport const COLOR_PRIMARIES_MAP = {\n    bt709: 1, // ITU-R BT.709\n    bt470bg: 5, // ITU-R BT.470BG\n    smpte170m: 6, // ITU-R BT.601 525 - SMPTE 170M\n    bt2020: 9, // ITU-R BT.202\n    smpte432: 12, // SMPTE EG 432-1\n};\nexport const COLOR_PRIMARIES_MAP_INVERSE = /* #__PURE__ */ invertObject(COLOR_PRIMARIES_MAP);\nexport const TRANSFER_CHARACTERISTICS_MAP = {\n    'bt709': 1, // ITU-R BT.709\n    'smpte170m': 6, // SMPTE 170M\n    'linear': 8, // Linear transfer characteristics\n    'iec61966-2-1': 13, // IEC 61966-2-1\n    'pq': 16, // Rec. ITU-R BT.2100-2 perceptual quantization (PQ) system\n    'hlg': 18, // Rec. ITU-R BT.2100-2 hybrid loggamma (HLG) system\n};\nexport const TRANSFER_CHARACTERISTICS_MAP_INVERSE = /* #__PURE__ */ invertObject(TRANSFER_CHARACTERISTICS_MAP);\nexport const MATRIX_COEFFICIENTS_MAP = {\n    'rgb': 0, // Identity\n    'bt709': 1, // ITU-R BT.709\n    'bt470bg': 5, // ITU-R BT.470BG\n    'smpte170m': 6, // SMPTE 170M\n    'bt2020-ncl': 9, // ITU-R BT.2020-2 (non-constant luminance)\n};\nexport const MATRIX_COEFFICIENTS_MAP_INVERSE = /* #__PURE__ */ invertObject(MATRIX_COEFFICIENTS_MAP);\nexport const colorSpaceIsComplete = (colorSpace) => {\n    return (!!colorSpace\n        && !!colorSpace.primaries\n        && !!colorSpace.transfer\n        && !!colorSpace.matrix\n        && colorSpace.fullRange !== undefined);\n};\nexport const isAllowSharedBufferSource = (x) => {\n    return (x instanceof ArrayBuffer\n        || (typeof SharedArrayBuffer !== 'undefined' && x instanceof SharedArrayBuffer)\n        || ArrayBuffer.isView(x));\n};\nexport class AsyncMutex {\n    constructor() {\n        this.currentPromise = Promise.resolve();\n    }\n    async acquire() {\n        let resolver;\n        const nextPromise = new Promise((resolve) => {\n            resolver = resolve;\n        });\n        const currentPromiseAlias = this.currentPromise;\n        this.currentPromise = nextPromise;\n        await currentPromiseAlias;\n        return resolver;\n    }\n}\nexport const bytesToHexString = (bytes) => {\n    return [...bytes].map(x => x.toString(16).padStart(2, '0')).join('');\n};\nexport const reverseBitsU32 = (x) => {\n    x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);\n    x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);\n    x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);\n    x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);\n    x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);\n    return x >>> 0; // Ensure it's treated as an unsigned 32-bit integer\n};\n/** Returns the smallest index i such that val[i] === key, or -1 if no such index exists. */\nexport const binarySearchExact = (arr, key, valueGetter) => {\n    let low = 0;\n    let high = arr.length - 1;\n    let ans = -1;\n    while (low <= high) {\n        const mid = (low + high) >> 1;\n        const midVal = valueGetter(arr[mid]);\n        if (midVal === key) {\n            ans = mid;\n            high = mid - 1; // Continue searching left to find the lowest index\n        }\n        else if (midVal < key) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    return ans;\n};\n/** Returns the largest index i such that val[i] <= key, or -1 if no such index exists. */\nexport const binarySearchLessOrEqual = (arr, key, valueGetter) => {\n    let low = 0;\n    let high = arr.length - 1;\n    let ans = -1;\n    while (low <= high) {\n        const mid = (low + (high - low + 1) / 2) | 0;\n        const midVal = valueGetter(arr[mid]);\n        if (midVal <= key) {\n            ans = mid;\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    return ans;\n};\n/** Assumes the array is already sorted. */\nexport const insertSorted = (arr, item, valueGetter) => {\n    const insertionIndex = binarySearchLessOrEqual(arr, valueGetter(item), valueGetter);\n    arr.splice(insertionIndex + 1, 0, item); // This even behaves correctly for the -1 case\n};\nexport const promiseWithResolvers = () => {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve: resolve, reject: reject };\n};\nexport const removeItem = (arr, item) => {\n    const index = arr.indexOf(item);\n    if (index !== -1) {\n        arr.splice(index, 1);\n    }\n};\nexport const findLast = (arr, predicate) => {\n    for (let i = arr.length - 1; i >= 0; i--) {\n        if (predicate(arr[i])) {\n            return arr[i];\n        }\n    }\n    return undefined;\n};\nexport const findLastIndex = (arr, predicate) => {\n    for (let i = arr.length - 1; i >= 0; i--) {\n        if (predicate(arr[i])) {\n            return i;\n        }\n    }\n    return -1;\n};\nexport const toAsyncIterator = async function* (source) {\n    if (Symbol.iterator in source) {\n        // @ts-expect-error Trust me\n        yield* source[Symbol.iterator]();\n    }\n    else {\n        // @ts-expect-error Trust me\n        yield* source[Symbol.asyncIterator]();\n    }\n};\nexport const validateAnyIterable = (iterable) => {\n    if (!(Symbol.iterator in iterable) && !(Symbol.asyncIterator in iterable)) {\n        throw new TypeError('Argument must be an iterable or async iterable.');\n    }\n};\nexport const assertNever = (x) => {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new Error(`Unexpected value: ${x}`);\n};\nexport const getUint24 = (view, byteOffset, littleEndian) => {\n    const byte1 = view.getUint8(byteOffset);\n    const byte2 = view.getUint8(byteOffset + 1);\n    const byte3 = view.getUint8(byteOffset + 2);\n    if (littleEndian) {\n        return byte1 | (byte2 << 8) | (byte3 << 16);\n    }\n    else {\n        return (byte1 << 16) | (byte2 << 8) | byte3;\n    }\n};\nexport const getInt24 = (view, byteOffset, littleEndian) => {\n    // The left shift pushes the most significant bit into the sign bit region, and the subsequent right shift\n    // then correctly interprets the sign bit.\n    return getUint24(view, byteOffset, littleEndian) << 8 >> 8;\n};\nexport const setUint24 = (view, byteOffset, value, littleEndian) => {\n    // Ensure the value is within 24-bit unsigned range (0 to 16777215)\n    value = value >>> 0; // Convert to unsigned 32-bit\n    value = value & 0xFFFFFF; // Mask to 24 bits\n    if (littleEndian) {\n        view.setUint8(byteOffset, value & 0xFF);\n        view.setUint8(byteOffset + 1, (value >>> 8) & 0xFF);\n        view.setUint8(byteOffset + 2, (value >>> 16) & 0xFF);\n    }\n    else {\n        view.setUint8(byteOffset, (value >>> 16) & 0xFF);\n        view.setUint8(byteOffset + 1, (value >>> 8) & 0xFF);\n        view.setUint8(byteOffset + 2, value & 0xFF);\n    }\n};\nexport const setInt24 = (view, byteOffset, value, littleEndian) => {\n    // Ensure the value is within 24-bit signed range (-8388608 to 8388607)\n    value = clamp(value, -8388608, 8388607);\n    // Convert negative values to their 24-bit representation\n    if (value < 0) {\n        value = (value + 0x1000000) & 0xFFFFFF;\n    }\n    setUint24(view, byteOffset, value, littleEndian);\n};\nexport const setInt64 = (view, byteOffset, value, littleEndian) => {\n    if (littleEndian) {\n        view.setUint32(byteOffset + 0, value, true);\n        view.setInt32(byteOffset + 4, Math.floor(value / 2 ** 32), true);\n    }\n    else {\n        view.setInt32(byteOffset + 0, Math.floor(value / 2 ** 32), true);\n        view.setUint32(byteOffset + 4, value, true);\n    }\n};\n/**\n * Calls a function on each value spat out by an async generator. The reason for writing this manually instead of\n * using a generator function is that the generator function queues return() calls - here, we forward them immediately.\n */\nexport const mapAsyncGenerator = (generator, map) => {\n    return {\n        async next() {\n            const result = await generator.next();\n            if (result.done) {\n                return { value: undefined, done: true };\n            }\n            else {\n                return { value: map(result.value), done: false };\n            }\n        },\n        return() {\n            return generator.return();\n        },\n        throw(error) {\n            return generator.throw(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n};\nexport const clamp = (value, min, max) => {\n    return Math.max(min, Math.min(max, value));\n};\nexport const UNDETERMINED_LANGUAGE = 'und';\nexport const roundIfAlmostInteger = (value) => {\n    const rounded = Math.round(value);\n    if (Math.abs(value / rounded - 1) < 10 * Number.EPSILON) {\n        return rounded;\n    }\n    else {\n        return value;\n    }\n};\nexport const roundToMultiple = (value, multiple) => {\n    return Math.round(value / multiple) * multiple;\n};\nexport const ilog = (x) => {\n    let ret = 0;\n    while (x) {\n        ret++;\n        x >>= 1;\n    }\n    return ret;\n};\nconst ISO_639_2_REGEX = /^[a-z]{3}$/;\nexport const isIso639Dash2LanguageCode = (x) => {\n    return ISO_639_2_REGEX.test(x);\n};\n// Since the result will be truncated, add a bit of eps to compensate for floating point errors\nexport const SECOND_TO_MICROSECOND_FACTOR = 1e6 * (1 + Number.EPSILON);\n/**\n * Merges two RequestInit objects with special handling for headers.\n * Headers are merged case-insensitively, but original casing is preserved.\n * init2 headers take precedence and will override case-insensitive matches from init1.\n */\nexport const mergeRequestInit = (init1, init2) => {\n    const merged = { ...init1, ...init2 };\n    // Special handling for headers\n    if (init1.headers || init2.headers) {\n        const headers1 = init1.headers ? normalizeHeaders(init1.headers) : {};\n        const headers2 = init2.headers ? normalizeHeaders(init2.headers) : {};\n        const mergedHeaders = { ...headers1 };\n        // For each header in headers2, check if a case-insensitive match exists in mergedHeaders\n        Object.entries(headers2).forEach(([key2, value2]) => {\n            const existingKey = Object.keys(mergedHeaders).find(key1 => key1.toLowerCase() === key2.toLowerCase());\n            if (existingKey) {\n                delete mergedHeaders[existingKey];\n            }\n            mergedHeaders[key2] = value2;\n        });\n        merged.headers = mergedHeaders;\n    }\n    return merged;\n};\n/** Normalizes HeadersInit to a Record<string, string> format. */\nconst normalizeHeaders = (headers) => {\n    if (headers instanceof Headers) {\n        const result = {};\n        headers.forEach((value, key) => {\n            result[key] = value;\n        });\n        return result;\n    }\n    if (Array.isArray(headers)) {\n        const result = {};\n        headers.forEach(([key, value]) => {\n            result[key] = value;\n        });\n        return result;\n    }\n    return headers;\n};\nexport const retriedFetch = async (fetchFn, url, requestInit, getRetryDelay, shouldStop) => {\n    let attempts = 0;\n    while (true) {\n        try {\n            return await fetchFn(url, requestInit);\n        }\n        catch (error) {\n            if (shouldStop()) {\n                throw error;\n            }\n            attempts++;\n            const retryDelayInSeconds = getRetryDelay(attempts, error, url);\n            if (retryDelayInSeconds === null) {\n                throw error;\n            }\n            console.error('Retrying failed fetch. Error:', error);\n            if (!Number.isFinite(retryDelayInSeconds) || retryDelayInSeconds < 0) {\n                throw new TypeError('Retry delay must be a non-negative finite number.');\n            }\n            if (retryDelayInSeconds > 0) {\n                await new Promise(resolve => setTimeout(resolve, 1000 * retryDelayInSeconds));\n            }\n            if (shouldStop()) {\n                throw error;\n            }\n        }\n    }\n};\nexport const computeRationalApproximation = (x, maxDenominator) => {\n    // Handle negative numbers\n    const sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n    let prevNumerator = 0, prevDenominator = 1;\n    let currNumerator = 1, currDenominator = 0;\n    // Continued fraction algorithm\n    let remainder = x;\n    while (true) {\n        const integer = Math.floor(remainder);\n        // Calculate next convergent\n        const nextNumerator = integer * currNumerator + prevNumerator;\n        const nextDenominator = integer * currDenominator + prevDenominator;\n        if (nextDenominator > maxDenominator) {\n            return {\n                numerator: sign * currNumerator,\n                denominator: currDenominator,\n            };\n        }\n        prevNumerator = currNumerator;\n        prevDenominator = currDenominator;\n        currNumerator = nextNumerator;\n        currDenominator = nextDenominator;\n        remainder = 1 / (remainder - integer);\n        // Guard against precision issues\n        if (!isFinite(remainder)) {\n            break;\n        }\n    }\n    return {\n        numerator: sign * currNumerator,\n        denominator: currDenominator,\n    };\n};\nexport class CallSerializer {\n    constructor() {\n        this.currentPromise = Promise.resolve();\n    }\n    call(fn) {\n        return this.currentPromise = this.currentPromise.then(fn);\n    }\n}\nlet isWebKitCache = null;\nexport const isWebKit = () => {\n    if (isWebKitCache !== null) {\n        return isWebKitCache;\n    }\n    // This even returns true for WebKit-wrapping browsers such as Chrome on iOS\n    return isWebKitCache = !!(typeof navigator !== 'undefined'\n        && (navigator.vendor?.match(/apple/i)\n            // Or, in workers:\n            || (/AppleWebKit/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent))\n            || /\\b(iPad|iPhone|iPod)\\b/.test(navigator.userAgent)));\n};\nlet isFirefoxCache = null;\nexport const isFirefox = () => {\n    if (isFirefoxCache !== null) {\n        return isFirefoxCache;\n    }\n    return isFirefoxCache = typeof navigator !== 'undefined' && navigator.userAgent?.includes('Firefox');\n};\nlet isChromiumCache = null;\nexport const isChromium = () => {\n    if (isChromiumCache !== null) {\n        return isChromiumCache;\n    }\n    return isChromiumCache = !!(typeof navigator !== 'undefined'\n        && (navigator.vendor?.includes('Google Inc') || /Chrome/.test(navigator.userAgent)));\n};\nlet chromiumVersionCache = null;\nexport const getChromiumVersion = () => {\n    if (chromiumVersionCache !== null) {\n        return chromiumVersionCache;\n    }\n    if (typeof navigator === 'undefined') {\n        return null;\n    }\n    const match = /\\bChrome\\/(\\d+)/.exec(navigator.userAgent);\n    if (!match) {\n        return null;\n    }\n    return chromiumVersionCache = Number(match[1]);\n};\n/** Acts like `??` except the condition is -1 and not null/undefined. */\nexport const coalesceIndex = (a, b) => {\n    return a !== -1 ? a : b;\n};\nexport const closedIntervalsOverlap = (startA, endA, startB, endB) => {\n    return startA <= endB && startB <= endA;\n};\nexport const keyValueIterator = function* (object) {\n    for (const key in object) {\n        const value = object[key];\n        if (value === undefined) {\n            continue;\n        }\n        yield { key, value };\n    }\n};\nexport const imageMimeTypeToExtension = (mimeType) => {\n    switch (mimeType.toLowerCase()) {\n        case 'image/jpeg':\n        case 'image/jpg':\n            return '.jpg';\n        case 'image/png':\n            return '.png';\n        case 'image/gif':\n            return '.gif';\n        case 'image/webp':\n            return '.webp';\n        case 'image/bmp':\n            return '.bmp';\n        case 'image/svg+xml':\n            return '.svg';\n        case 'image/tiff':\n            return '.tiff';\n        case 'image/avif':\n            return '.avif';\n        case 'image/x-icon':\n        case 'image/vnd.microsoft.icon':\n            return '.ico';\n        default:\n            return null;\n    }\n};\nexport const base64ToBytes = (base64) => {\n    const decoded = atob(base64);\n    const bytes = new Uint8Array(decoded.length);\n    for (let i = 0; i < decoded.length; i++) {\n        bytes[i] = decoded.charCodeAt(i);\n    }\n    return bytes;\n};\nexport const bytesToBase64 = (bytes) => {\n    let string = '';\n    for (let i = 0; i < bytes.length; i++) {\n        string += String.fromCharCode(bytes[i]);\n    }\n    return btoa(string);\n};\nexport const uint8ArraysAreEqual = (a, b) => {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n};\nexport const polyfillSymbolDispose = () => {\n    // https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html\n    // @ts-expect-error Readonly\n    Symbol.dispose ??= Symbol('Symbol.dispose');\n};\nexport const isNumber = (x) => {\n    return typeof x === 'number' && !Number.isNaN(x);\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/**\n * Image data with additional metadata.\n *\n * @group Metadata tags\n * @public\n */\nexport class RichImageData {\n    /** Creates a new {@link RichImageData}. */\n    constructor(\n    /** The raw image data. */\n    data, \n    /** An RFC 6838 MIME type (e.g. image/jpeg, image/png, etc.) */\n    mimeType) {\n        this.data = data;\n        this.mimeType = mimeType;\n        if (!(data instanceof Uint8Array)) {\n            throw new TypeError('data must be a Uint8Array.');\n        }\n        if (typeof mimeType !== 'string') {\n            throw new TypeError('mimeType must be a string.');\n        }\n    }\n}\n/**\n * A file attached to a media file.\n *\n * @group Metadata tags\n * @public\n */\nexport class AttachedFile {\n    /** Creates a new {@link AttachedFile}. */\n    constructor(\n    /** The raw file data. */\n    data, \n    /** An RFC 6838 MIME type (e.g. image/jpeg, image/png, font/ttf, etc.) */\n    mimeType, \n    /** The name of the file. */\n    name, \n    /** A description of the file. */\n    description) {\n        this.data = data;\n        this.mimeType = mimeType;\n        this.name = name;\n        this.description = description;\n        if (!(data instanceof Uint8Array)) {\n            throw new TypeError('data must be a Uint8Array.');\n        }\n        if (mimeType !== undefined && typeof mimeType !== 'string') {\n            throw new TypeError('mimeType, when provided, must be a string.');\n        }\n        if (name !== undefined && typeof name !== 'string') {\n            throw new TypeError('name, when provided, must be a string.');\n        }\n        if (description !== undefined && typeof description !== 'string') {\n            throw new TypeError('description, when provided, must be a string.');\n        }\n    }\n}\n;\nexport const validateMetadataTags = (tags) => {\n    if (!tags || typeof tags !== 'object') {\n        throw new TypeError('tags must be an object.');\n    }\n    if (tags.title !== undefined && typeof tags.title !== 'string') {\n        throw new TypeError('tags.title, when provided, must be a string.');\n    }\n    if (tags.description !== undefined && typeof tags.description !== 'string') {\n        throw new TypeError('tags.description, when provided, must be a string.');\n    }\n    if (tags.artist !== undefined && typeof tags.artist !== 'string') {\n        throw new TypeError('tags.artist, when provided, must be a string.');\n    }\n    if (tags.album !== undefined && typeof tags.album !== 'string') {\n        throw new TypeError('tags.album, when provided, must be a string.');\n    }\n    if (tags.albumArtist !== undefined && typeof tags.albumArtist !== 'string') {\n        throw new TypeError('tags.albumArtist, when provided, must be a string.');\n    }\n    if (tags.trackNumber !== undefined && (!Number.isInteger(tags.trackNumber) || tags.trackNumber <= 0)) {\n        throw new TypeError('tags.trackNumber, when provided, must be a positive integer.');\n    }\n    if (tags.tracksTotal !== undefined\n        && (!Number.isInteger(tags.tracksTotal) || tags.tracksTotal <= 0)) {\n        throw new TypeError('tags.tracksTotal, when provided, must be a positive integer.');\n    }\n    if (tags.discNumber !== undefined && (!Number.isInteger(tags.discNumber) || tags.discNumber <= 0)) {\n        throw new TypeError('tags.discNumber, when provided, must be a positive integer.');\n    }\n    if (tags.discsTotal !== undefined\n        && (!Number.isInteger(tags.discsTotal) || tags.discsTotal <= 0)) {\n        throw new TypeError('tags.discsTotal, when provided, must be a positive integer.');\n    }\n    if (tags.genre !== undefined && typeof tags.genre !== 'string') {\n        throw new TypeError('tags.genre, when provided, must be a string.');\n    }\n    if (tags.date !== undefined && (!(tags.date instanceof Date) || Number.isNaN(tags.date.getTime()))) {\n        throw new TypeError('tags.date, when provided, must be a valid Date.');\n    }\n    if (tags.lyrics !== undefined && typeof tags.lyrics !== 'string') {\n        throw new TypeError('tags.lyrics, when provided, must be a string.');\n    }\n    if (tags.images !== undefined) {\n        if (!Array.isArray(tags.images)) {\n            throw new TypeError('tags.images, when provided, must be an array.');\n        }\n        for (const image of tags.images) {\n            if (!image || typeof image !== 'object') {\n                throw new TypeError('Each image in tags.images must be an object.');\n            }\n            if (!(image.data instanceof Uint8Array)) {\n                throw new TypeError('Each image.data must be a Uint8Array.');\n            }\n            if (typeof image.mimeType !== 'string') {\n                throw new TypeError('Each image.mimeType must be a string.');\n            }\n            if (!['coverFront', 'coverBack', 'unknown'].includes(image.kind)) {\n                throw new TypeError('Each image.kind must be \\'coverFront\\', \\'coverBack\\', or \\'unknown\\'.');\n            }\n        }\n    }\n    if (tags.comment !== undefined && typeof tags.comment !== 'string') {\n        throw new TypeError('tags.comment, when provided, must be a string.');\n    }\n    if (tags.raw !== undefined) {\n        if (!tags.raw || typeof tags.raw !== 'object') {\n            throw new TypeError('tags.raw, when provided, must be an object.');\n        }\n        for (const value of Object.values(tags.raw)) {\n            if (value !== null\n                && typeof value !== 'string'\n                && !(value instanceof Uint8Array)\n                && !(value instanceof RichImageData)\n                && !(value instanceof AttachedFile)) {\n                throw new TypeError('Each value in tags.raw must be a string, Uint8Array, RichImageData, AttachedFile, or null.');\n            }\n        }\n    }\n};\nexport const metadataTagsAreEmpty = (tags) => {\n    return tags.title === undefined\n        && tags.description === undefined\n        && tags.artist === undefined\n        && tags.album === undefined\n        && tags.albumArtist === undefined\n        && tags.trackNumber === undefined\n        && tags.tracksTotal === undefined\n        && tags.discNumber === undefined\n        && tags.discsTotal === undefined\n        && tags.genre === undefined\n        && tags.date === undefined\n        && tags.lyrics === undefined\n        && (!tags.images || tags.images.length === 0)\n        && tags.comment === undefined\n        && (tags.raw === undefined || Object.keys(tags.raw).length === 0);\n};\nexport const DEFAULT_TRACK_DISPOSITION = {\n    default: true,\n    forced: false,\n    original: false,\n    commentary: false,\n    hearingImpaired: false,\n    visuallyImpaired: false,\n};\nexport const validateTrackDisposition = (disposition) => {\n    if (!disposition || typeof disposition !== 'object') {\n        throw new TypeError('disposition must be an object.');\n    }\n    if (disposition.default !== undefined && typeof disposition.default !== 'boolean') {\n        throw new TypeError('disposition.default must be a boolean.');\n    }\n    if (disposition.forced !== undefined && typeof disposition.forced !== 'boolean') {\n        throw new TypeError('disposition.forced must be a boolean.');\n    }\n    if (disposition.original !== undefined && typeof disposition.original !== 'boolean') {\n        throw new TypeError('disposition.original must be a boolean.');\n    }\n    if (disposition.commentary !== undefined && typeof disposition.commentary !== 'boolean') {\n        throw new TypeError('disposition.commentary must be a boolean.');\n    }\n    if (disposition.hearingImpaired !== undefined && typeof disposition.hearingImpaired !== 'boolean') {\n        throw new TypeError('disposition.hearingImpaired must be a boolean.');\n    }\n    if (disposition.visuallyImpaired !== undefined && typeof disposition.visuallyImpaired !== 'boolean') {\n        throw new TypeError('disposition.visuallyImpaired must be a boolean.');\n    }\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Bitstream, COLOR_PRIMARIES_MAP, MATRIX_COEFFICIENTS_MAP, TRANSFER_CHARACTERISTICS_MAP, assert, bytesToHexString, isAllowSharedBufferSource, last, reverseBitsU32, toDataView, } from './misc.js';\n/**\n * List of known video codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const VIDEO_CODECS = [\n    'avc',\n    'hevc',\n    'vp9',\n    'av1',\n    'vp8',\n];\n/**\n * List of known PCM (uncompressed) audio codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const PCM_AUDIO_CODECS = [\n    'pcm-s16', // We don't prefix 'le' so we're compatible with the WebCodecs-registered PCM codec strings\n    'pcm-s16be',\n    'pcm-s24',\n    'pcm-s24be',\n    'pcm-s32',\n    'pcm-s32be',\n    'pcm-f32',\n    'pcm-f32be',\n    'pcm-f64',\n    'pcm-f64be',\n    'pcm-u8',\n    'pcm-s8',\n    'ulaw',\n    'alaw',\n];\n/**\n * List of known compressed audio codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const NON_PCM_AUDIO_CODECS = [\n    'aac',\n    'opus',\n    'mp3',\n    'vorbis',\n    'flac',\n];\n/**\n * List of known audio codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const AUDIO_CODECS = [\n    ...NON_PCM_AUDIO_CODECS,\n    ...PCM_AUDIO_CODECS,\n];\n/**\n * List of known subtitle codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const SUBTITLE_CODECS = [\n    'webvtt',\n]; // TODO add the rest\n// https://en.wikipedia.org/wiki/Advanced_Video_Coding\nconst AVC_LEVEL_TABLE = [\n    { maxMacroblocks: 99, maxBitrate: 64000, level: 0x0A }, // Level 1\n    { maxMacroblocks: 396, maxBitrate: 192000, level: 0x0B }, // Level 1.1\n    { maxMacroblocks: 396, maxBitrate: 384000, level: 0x0C }, // Level 1.2\n    { maxMacroblocks: 396, maxBitrate: 768000, level: 0x0D }, // Level 1.3\n    { maxMacroblocks: 396, maxBitrate: 2000000, level: 0x14 }, // Level 2\n    { maxMacroblocks: 792, maxBitrate: 4000000, level: 0x15 }, // Level 2.1\n    { maxMacroblocks: 1620, maxBitrate: 4000000, level: 0x16 }, // Level 2.2\n    { maxMacroblocks: 1620, maxBitrate: 10000000, level: 0x1E }, // Level 3\n    { maxMacroblocks: 3600, maxBitrate: 14000000, level: 0x1F }, // Level 3.1\n    { maxMacroblocks: 5120, maxBitrate: 20000000, level: 0x20 }, // Level 3.2\n    { maxMacroblocks: 8192, maxBitrate: 20000000, level: 0x28 }, // Level 4\n    { maxMacroblocks: 8192, maxBitrate: 50000000, level: 0x29 }, // Level 4.1\n    { maxMacroblocks: 8704, maxBitrate: 50000000, level: 0x2A }, // Level 4.2\n    { maxMacroblocks: 22080, maxBitrate: 135000000, level: 0x32 }, // Level 5\n    { maxMacroblocks: 36864, maxBitrate: 240000000, level: 0x33 }, // Level 5.1\n    { maxMacroblocks: 36864, maxBitrate: 240000000, level: 0x34 }, // Level 5.2\n    { maxMacroblocks: 139264, maxBitrate: 240000000, level: 0x3C }, // Level 6\n    { maxMacroblocks: 139264, maxBitrate: 480000000, level: 0x3D }, // Level 6.1\n    { maxMacroblocks: 139264, maxBitrate: 800000000, level: 0x3E }, // Level 6.2\n];\n// https://en.wikipedia.org/wiki/High_Efficiency_Video_Coding\nconst HEVC_LEVEL_TABLE = [\n    { maxPictureSize: 36864, maxBitrate: 128000, tier: 'L', level: 30 }, // Level 1 (Low Tier)\n    { maxPictureSize: 122880, maxBitrate: 1500000, tier: 'L', level: 60 }, // Level 2 (Low Tier)\n    { maxPictureSize: 245760, maxBitrate: 3000000, tier: 'L', level: 63 }, // Level 2.1 (Low Tier)\n    { maxPictureSize: 552960, maxBitrate: 6000000, tier: 'L', level: 90 }, // Level 3 (Low Tier)\n    { maxPictureSize: 983040, maxBitrate: 10000000, tier: 'L', level: 93 }, // Level 3.1 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 12000000, tier: 'L', level: 120 }, // Level 4 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 30000000, tier: 'H', level: 120 }, // Level 4 (High Tier)\n    { maxPictureSize: 2228224, maxBitrate: 20000000, tier: 'L', level: 123 }, // Level 4.1 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 50000000, tier: 'H', level: 123 }, // Level 4.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 25000000, tier: 'L', level: 150 }, // Level 5 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 100000000, tier: 'H', level: 150 }, // Level 5 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 40000000, tier: 'L', level: 153 }, // Level 5.1 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 160000000, tier: 'H', level: 153 }, // Level 5.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 60000000, tier: 'L', level: 156 }, // Level 5.2 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 240000000, tier: 'H', level: 156 }, // Level 5.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'L', level: 180 }, // Level 6 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 180 }, // Level 6 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 120000000, tier: 'L', level: 183 }, // Level 6.1 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 480000000, tier: 'H', level: 183 }, // Level 6.1 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'L', level: 186 }, // Level 6.2 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 186 }, // Level 6.2 (High Tier)\n];\n// https://en.wikipedia.org/wiki/VP9\nexport const VP9_LEVEL_TABLE = [\n    { maxPictureSize: 36864, maxBitrate: 200000, level: 10 }, // Level 1\n    { maxPictureSize: 73728, maxBitrate: 800000, level: 11 }, // Level 1.1\n    { maxPictureSize: 122880, maxBitrate: 1800000, level: 20 }, // Level 2\n    { maxPictureSize: 245760, maxBitrate: 3600000, level: 21 }, // Level 2.1\n    { maxPictureSize: 552960, maxBitrate: 7200000, level: 30 }, // Level 3\n    { maxPictureSize: 983040, maxBitrate: 12000000, level: 31 }, // Level 3.1\n    { maxPictureSize: 2228224, maxBitrate: 18000000, level: 40 }, // Level 4\n    { maxPictureSize: 2228224, maxBitrate: 30000000, level: 41 }, // Level 4.1\n    { maxPictureSize: 8912896, maxBitrate: 60000000, level: 50 }, // Level 5\n    { maxPictureSize: 8912896, maxBitrate: 120000000, level: 51 }, // Level 5.1\n    { maxPictureSize: 8912896, maxBitrate: 180000000, level: 52 }, // Level 5.2\n    { maxPictureSize: 35651584, maxBitrate: 180000000, level: 60 }, // Level 6\n    { maxPictureSize: 35651584, maxBitrate: 240000000, level: 61 }, // Level 6.1\n    { maxPictureSize: 35651584, maxBitrate: 480000000, level: 62 }, // Level 6.2\n];\n// https://en.wikipedia.org/wiki/AV1\nconst AV1_LEVEL_TABLE = [\n    { maxPictureSize: 147456, maxBitrate: 1500000, tier: 'M', level: 0 }, // Level 2.0 (Main Tier)\n    { maxPictureSize: 278784, maxBitrate: 3000000, tier: 'M', level: 1 }, // Level 2.1 (Main Tier)\n    { maxPictureSize: 665856, maxBitrate: 6000000, tier: 'M', level: 4 }, // Level 3.0 (Main Tier)\n    { maxPictureSize: 1065024, maxBitrate: 10000000, tier: 'M', level: 5 }, // Level 3.1 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 12000000, tier: 'M', level: 8 }, // Level 4.0 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 30000000, tier: 'H', level: 8 }, // Level 4.0 (High Tier)\n    { maxPictureSize: 2359296, maxBitrate: 20000000, tier: 'M', level: 9 }, // Level 4.1 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 50000000, tier: 'H', level: 9 }, // Level 4.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 30000000, tier: 'M', level: 12 }, // Level 5.0 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 100000000, tier: 'H', level: 12 }, // Level 5.0 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 40000000, tier: 'M', level: 13 }, // Level 5.1 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 160000000, tier: 'H', level: 13 }, // Level 5.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 60000000, tier: 'M', level: 14 }, // Level 5.2 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 240000000, tier: 'H', level: 14 }, // Level 5.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'M', level: 15 }, // Level 5.3 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 15 }, // Level 5.3 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'M', level: 16 }, // Level 6.0 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 16 }, // Level 6.0 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 100000000, tier: 'M', level: 17 }, // Level 6.1 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 480000000, tier: 'H', level: 17 }, // Level 6.1 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 160000000, tier: 'M', level: 18 }, // Level 6.2 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 18 }, // Level 6.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 160000000, tier: 'M', level: 19 }, // Level 6.3 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 19 }, // Level 6.3 (High Tier)\n];\nconst VP9_DEFAULT_SUFFIX = '.01.01.01.01.00';\nconst AV1_DEFAULT_SUFFIX = '.0.110.01.01.01.0';\nexport const buildVideoCodecString = (codec, width, height, bitrate) => {\n    if (codec === 'avc') {\n        const profileIndication = 0x64; // High Profile\n        const totalMacroblocks = Math.ceil(width / 16) * Math.ceil(height / 16);\n        // Determine the level based on the table\n        const levelInfo = AVC_LEVEL_TABLE.find(level => totalMacroblocks <= level.maxMacroblocks && bitrate <= level.maxBitrate) ?? last(AVC_LEVEL_TABLE);\n        const levelIndication = levelInfo ? levelInfo.level : 0;\n        const hexProfileIndication = profileIndication.toString(16).padStart(2, '0');\n        const hexProfileCompatibility = '00';\n        const hexLevelIndication = levelIndication.toString(16).padStart(2, '0');\n        return `avc1.${hexProfileIndication}${hexProfileCompatibility}${hexLevelIndication}`;\n    }\n    else if (codec === 'hevc') {\n        const profilePrefix = ''; // Profile space 0\n        const profileIdc = 1; // Main Profile\n        const compatibilityFlags = '6'; // Taken from the example in ISO 14496-15\n        const pictureSize = width * height;\n        const levelInfo = HEVC_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? last(HEVC_LEVEL_TABLE);\n        const constraintFlags = 'B0'; // Progressive source flag\n        return 'hev1.'\n            + `${profilePrefix}${profileIdc}.`\n            + `${compatibilityFlags}.`\n            + `${levelInfo.tier}${levelInfo.level}.`\n            + `${constraintFlags}`;\n    }\n    else if (codec === 'vp8') {\n        return 'vp8'; // Easy, this one\n    }\n    else if (codec === 'vp9') {\n        const profile = '00'; // Profile 0\n        const pictureSize = width * height;\n        const levelInfo = VP9_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? last(VP9_LEVEL_TABLE);\n        const bitDepth = '08'; // 8-bit\n        return `vp09.${profile}.${levelInfo.level.toString().padStart(2, '0')}.${bitDepth}`;\n    }\n    else if (codec === 'av1') {\n        const profile = 0; // Main Profile, single digit\n        const pictureSize = width * height;\n        const levelInfo = AV1_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? last(AV1_LEVEL_TABLE);\n        const level = levelInfo.level.toString().padStart(2, '0');\n        const bitDepth = '08'; // 8-bit\n        return `av01.${profile}.${level}${levelInfo.tier}.${bitDepth}`;\n    }\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const generateVp9CodecConfigurationFromCodecString = (codecString) => {\n    // Reference: https://www.webmproject.org/docs/container/#vp9-codec-feature-metadata-codecprivate\n    const parts = codecString.split('.'); // We can derive the required values from the codec string\n    const profile = Number(parts[1]);\n    const level = Number(parts[2]);\n    const bitDepth = Number(parts[3]);\n    const chromaSubsampling = parts[4] ? Number(parts[4]) : 1;\n    return [\n        1, 1, profile,\n        2, 1, level,\n        3, 1, bitDepth,\n        4, 1, chromaSubsampling,\n    ];\n};\nexport const generateAv1CodecConfigurationFromCodecString = (codecString) => {\n    // Reference: https://aomediacodec.github.io/av1-isobmff/\n    const parts = codecString.split('.'); // We can derive the required values from the codec string\n    const marker = 1;\n    const version = 1;\n    const firstByte = (marker << 7) + version;\n    const profile = Number(parts[1]);\n    const levelAndTier = parts[2];\n    const level = Number(levelAndTier.slice(0, -1));\n    const secondByte = (profile << 5) + level;\n    const tier = levelAndTier.slice(-1) === 'H' ? 1 : 0;\n    const bitDepth = Number(parts[3]);\n    const highBitDepth = bitDepth === 8 ? 0 : 1;\n    const twelveBit = 0;\n    const monochrome = parts[4] ? Number(parts[4]) : 0;\n    const chromaSubsamplingX = parts[5] ? Number(parts[5][0]) : 1;\n    const chromaSubsamplingY = parts[5] ? Number(parts[5][1]) : 1;\n    const chromaSamplePosition = parts[5] ? Number(parts[5][2]) : 0; // CSP_UNKNOWN\n    const thirdByte = (tier << 7)\n        + (highBitDepth << 6)\n        + (twelveBit << 5)\n        + (monochrome << 4)\n        + (chromaSubsamplingX << 3)\n        + (chromaSubsamplingY << 2)\n        + chromaSamplePosition;\n    const initialPresentationDelayPresent = 0; // Should be fine\n    const fourthByte = initialPresentationDelayPresent;\n    return [firstByte, secondByte, thirdByte, fourthByte];\n};\nexport const extractVideoCodecString = (trackInfo) => {\n    const { codec, codecDescription, colorSpace, avcCodecInfo, hevcCodecInfo, vp9CodecInfo, av1CodecInfo } = trackInfo;\n    if (codec === 'avc') {\n        assert(trackInfo.avcType !== null);\n        if (avcCodecInfo) {\n            const bytes = new Uint8Array([\n                avcCodecInfo.avcProfileIndication,\n                avcCodecInfo.profileCompatibility,\n                avcCodecInfo.avcLevelIndication,\n            ]);\n            return `avc${trackInfo.avcType}.${bytesToHexString(bytes)}`;\n        }\n        if (!codecDescription || codecDescription.byteLength < 4) {\n            throw new TypeError('AVC decoder description is not provided or is not at least 4 bytes long.');\n        }\n        return `avc${trackInfo.avcType}.${bytesToHexString(codecDescription.subarray(1, 4))}`;\n    }\n    else if (codec === 'hevc') {\n        let generalProfileSpace;\n        let generalProfileIdc;\n        let compatibilityFlags;\n        let generalTierFlag;\n        let generalLevelIdc;\n        let constraintFlags;\n        if (hevcCodecInfo) {\n            generalProfileSpace = hevcCodecInfo.generalProfileSpace;\n            generalProfileIdc = hevcCodecInfo.generalProfileIdc;\n            compatibilityFlags = reverseBitsU32(hevcCodecInfo.generalProfileCompatibilityFlags);\n            generalTierFlag = hevcCodecInfo.generalTierFlag;\n            generalLevelIdc = hevcCodecInfo.generalLevelIdc;\n            constraintFlags = [...hevcCodecInfo.generalConstraintIndicatorFlags];\n        }\n        else {\n            if (!codecDescription || codecDescription.byteLength < 23) {\n                throw new TypeError('HEVC decoder description is not provided or is not at least 23 bytes long.');\n            }\n            const view = toDataView(codecDescription);\n            const profileByte = view.getUint8(1);\n            generalProfileSpace = (profileByte >> 6) & 0x03;\n            generalProfileIdc = profileByte & 0x1F;\n            compatibilityFlags = reverseBitsU32(view.getUint32(2));\n            generalTierFlag = (profileByte >> 5) & 0x01;\n            generalLevelIdc = view.getUint8(12);\n            constraintFlags = [];\n            for (let i = 0; i < 6; i++) {\n                constraintFlags.push(view.getUint8(6 + i));\n            }\n        }\n        let codecString = 'hev1.';\n        codecString += ['', 'A', 'B', 'C'][generalProfileSpace] + generalProfileIdc;\n        codecString += '.';\n        codecString += compatibilityFlags.toString(16).toUpperCase();\n        codecString += '.';\n        codecString += generalTierFlag === 0 ? 'L' : 'H';\n        codecString += generalLevelIdc;\n        while (constraintFlags.length > 0 && constraintFlags[constraintFlags.length - 1] === 0) {\n            constraintFlags.pop();\n        }\n        if (constraintFlags.length > 0) {\n            codecString += '.';\n            codecString += constraintFlags.map(x => x.toString(16).toUpperCase()).join('.');\n        }\n        return codecString;\n    }\n    else if (codec === 'vp8') {\n        return 'vp8'; // Easy, this one\n    }\n    else if (codec === 'vp9') {\n        if (!vp9CodecInfo) {\n            // Calculate level based on dimensions\n            const pictureSize = trackInfo.width * trackInfo.height;\n            let level = last(VP9_LEVEL_TABLE).level; // Default to highest level\n            for (const entry of VP9_LEVEL_TABLE) {\n                if (pictureSize <= entry.maxPictureSize) {\n                    level = entry.level;\n                    break;\n                }\n            }\n            // We don't really know better, so let's return a general-purpose, common codec string and hope for the best\n            return `vp09.00.${level.toString().padStart(2, '0')}.08`;\n        }\n        const profile = vp9CodecInfo.profile.toString().padStart(2, '0');\n        const level = vp9CodecInfo.level.toString().padStart(2, '0');\n        const bitDepth = vp9CodecInfo.bitDepth.toString().padStart(2, '0');\n        const chromaSubsampling = vp9CodecInfo.chromaSubsampling.toString().padStart(2, '0');\n        const colourPrimaries = vp9CodecInfo.colourPrimaries.toString().padStart(2, '0');\n        const transferCharacteristics = vp9CodecInfo.transferCharacteristics.toString().padStart(2, '0');\n        const matrixCoefficients = vp9CodecInfo.matrixCoefficients.toString().padStart(2, '0');\n        const videoFullRangeFlag = vp9CodecInfo.videoFullRangeFlag.toString().padStart(2, '0');\n        let string = `vp09.${profile}.${level}.${bitDepth}.${chromaSubsampling}`;\n        string += `.${colourPrimaries}.${transferCharacteristics}.${matrixCoefficients}.${videoFullRangeFlag}`;\n        if (string.endsWith(VP9_DEFAULT_SUFFIX)) {\n            string = string.slice(0, -VP9_DEFAULT_SUFFIX.length);\n        }\n        return string;\n    }\n    else if (codec === 'av1') {\n        if (!av1CodecInfo) {\n            // Calculate level based on dimensions\n            const pictureSize = trackInfo.width * trackInfo.height;\n            let level = last(VP9_LEVEL_TABLE).level; // Default to highest level\n            for (const entry of VP9_LEVEL_TABLE) {\n                if (pictureSize <= entry.maxPictureSize) {\n                    level = entry.level;\n                    break;\n                }\n            }\n            // We don't really know better, so let's return a general-purpose, common codec string and hope for the best\n            return `av01.0.${level.toString().padStart(2, '0')}M.08`;\n        }\n        // https://aomediacodec.github.io/av1-isobmff/#codecsparam\n        const profile = av1CodecInfo.profile; // Single digit\n        const level = av1CodecInfo.level.toString().padStart(2, '0');\n        const tier = av1CodecInfo.tier ? 'H' : 'M';\n        const bitDepth = av1CodecInfo.bitDepth.toString().padStart(2, '0');\n        const monochrome = av1CodecInfo.monochrome ? '1' : '0';\n        const chromaSubsampling = 100 * av1CodecInfo.chromaSubsamplingX\n            + 10 * av1CodecInfo.chromaSubsamplingY\n            + 1 * (av1CodecInfo.chromaSubsamplingX && av1CodecInfo.chromaSubsamplingY\n                ? av1CodecInfo.chromaSamplePosition\n                : 0);\n        // The defaults are 1 (ITU-R BT.709)\n        const colorPrimaries = colorSpace?.primaries ? COLOR_PRIMARIES_MAP[colorSpace.primaries] : 1;\n        const transferCharacteristics = colorSpace?.transfer ? TRANSFER_CHARACTERISTICS_MAP[colorSpace.transfer] : 1;\n        const matrixCoefficients = colorSpace?.matrix ? MATRIX_COEFFICIENTS_MAP[colorSpace.matrix] : 1;\n        const videoFullRangeFlag = colorSpace?.fullRange ? 1 : 0;\n        let string = `av01.${profile}.${level}${tier}.${bitDepth}`;\n        string += `.${monochrome}.${chromaSubsampling.toString().padStart(3, '0')}`;\n        string += `.${colorPrimaries.toString().padStart(2, '0')}`;\n        string += `.${transferCharacteristics.toString().padStart(2, '0')}`;\n        string += `.${matrixCoefficients.toString().padStart(2, '0')}`;\n        string += `.${videoFullRangeFlag}`;\n        if (string.endsWith(AV1_DEFAULT_SUFFIX)) {\n            string = string.slice(0, -AV1_DEFAULT_SUFFIX.length);\n        }\n        return string;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const buildAudioCodecString = (codec, numberOfChannels, sampleRate) => {\n    if (codec === 'aac') {\n        // If stereo or higher channels and lower sample rate, likely using HE-AAC v2 with PS\n        if (numberOfChannels >= 2 && sampleRate <= 24000) {\n            return 'mp4a.40.29'; // HE-AAC v2 (AAC LC + SBR + PS)\n        }\n        // If sample rate is low, likely using HE-AAC v1 with SBR\n        if (sampleRate <= 24000) {\n            return 'mp4a.40.5'; // HE-AAC v1 (AAC LC + SBR)\n        }\n        // Default to standard AAC-LC for higher sample rates\n        return 'mp4a.40.2'; // AAC-LC\n    }\n    else if (codec === 'mp3') {\n        return 'mp3';\n    }\n    else if (codec === 'opus') {\n        return 'opus';\n    }\n    else if (codec === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codec === 'flac') {\n        return 'flac';\n    }\n    else if (PCM_AUDIO_CODECS.includes(codec)) {\n        return codec;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const extractAudioCodecString = (trackInfo) => {\n    const { codec, codecDescription, aacCodecInfo } = trackInfo;\n    if (codec === 'aac') {\n        if (!aacCodecInfo) {\n            throw new TypeError('AAC codec info must be provided.');\n        }\n        if (aacCodecInfo.isMpeg2) {\n            return 'mp4a.67';\n        }\n        else {\n            const audioSpecificConfig = parseAacAudioSpecificConfig(codecDescription);\n            return `mp4a.40.${audioSpecificConfig.objectType}`;\n        }\n    }\n    else if (codec === 'mp3') {\n        return 'mp3';\n    }\n    else if (codec === 'opus') {\n        return 'opus';\n    }\n    else if (codec === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codec === 'flac') {\n        return 'flac';\n    }\n    else if (codec && PCM_AUDIO_CODECS.includes(codec)) {\n        return codec;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const aacFrequencyTable = [\n    96000, 88200, 64000, 48000, 44100, 32000,\n    24000, 22050, 16000, 12000, 11025, 8000, 7350,\n];\nexport const aacChannelMap = [-1, 1, 2, 3, 4, 5, 6, 8];\nexport const parseAacAudioSpecificConfig = (bytes) => {\n    if (!bytes || bytes.byteLength < 2) {\n        throw new TypeError('AAC description must be at least 2 bytes long.');\n    }\n    const bitstream = new Bitstream(bytes);\n    let objectType = bitstream.readBits(5);\n    if (objectType === 31) {\n        objectType = 32 + bitstream.readBits(6);\n    }\n    const frequencyIndex = bitstream.readBits(4);\n    let sampleRate = null;\n    if (frequencyIndex === 15) {\n        sampleRate = bitstream.readBits(24);\n    }\n    else {\n        if (frequencyIndex < aacFrequencyTable.length) {\n            sampleRate = aacFrequencyTable[frequencyIndex];\n        }\n    }\n    const channelConfiguration = bitstream.readBits(4);\n    let numberOfChannels = null;\n    if (channelConfiguration >= 1 && channelConfiguration <= 7) {\n        numberOfChannels = aacChannelMap[channelConfiguration];\n    }\n    return {\n        objectType,\n        frequencyIndex,\n        sampleRate,\n        channelConfiguration,\n        numberOfChannels,\n    };\n};\nexport const buildAacAudioSpecificConfig = (config) => {\n    let frequencyIndex = aacFrequencyTable.indexOf(config.sampleRate);\n    let customSampleRate = null;\n    if (frequencyIndex === -1) {\n        frequencyIndex = 15;\n        customSampleRate = config.sampleRate;\n    }\n    const channelConfiguration = aacChannelMap.indexOf(config.numberOfChannels);\n    if (channelConfiguration === -1) {\n        throw new TypeError(`Unsupported number of channels: ${config.numberOfChannels}`);\n    }\n    let bitCount = 5 + 4 + 4;\n    if (config.objectType >= 32) {\n        bitCount += 6;\n    }\n    if (frequencyIndex === 15) {\n        bitCount += 24;\n    }\n    const byteCount = Math.ceil(bitCount / 8);\n    const bytes = new Uint8Array(byteCount);\n    const bitstream = new Bitstream(bytes);\n    if (config.objectType < 32) {\n        bitstream.writeBits(5, config.objectType);\n    }\n    else {\n        bitstream.writeBits(5, 31);\n        bitstream.writeBits(6, config.objectType - 32);\n    }\n    bitstream.writeBits(4, frequencyIndex);\n    if (frequencyIndex === 15) {\n        bitstream.writeBits(24, customSampleRate);\n    }\n    bitstream.writeBits(4, channelConfiguration);\n    return bytes;\n};\nexport const OPUS_SAMPLE_RATE = 48_000;\nconst PCM_CODEC_REGEX = /^pcm-([usf])(\\d+)+(be)?$/;\nexport const parsePcmCodec = (codec) => {\n    assert(PCM_AUDIO_CODECS.includes(codec));\n    if (codec === 'ulaw') {\n        return { dataType: 'ulaw', sampleSize: 1, littleEndian: true, silentValue: 255 };\n    }\n    else if (codec === 'alaw') {\n        return { dataType: 'alaw', sampleSize: 1, littleEndian: true, silentValue: 213 };\n    }\n    const match = PCM_CODEC_REGEX.exec(codec);\n    assert(match);\n    let dataType;\n    if (match[1] === 'u') {\n        dataType = 'unsigned';\n    }\n    else if (match[1] === 's') {\n        dataType = 'signed';\n    }\n    else {\n        dataType = 'float';\n    }\n    const sampleSize = (Number(match[2]) / 8);\n    const littleEndian = match[3] !== 'be';\n    const silentValue = codec === 'pcm-u8' ? 2 ** 7 : 0;\n    return { dataType, sampleSize, littleEndian, silentValue };\n};\nexport const inferCodecFromCodecString = (codecString) => {\n    // Video codecs\n    if (codecString.startsWith('avc1') || codecString.startsWith('avc3')) {\n        return 'avc';\n    }\n    else if (codecString.startsWith('hev1') || codecString.startsWith('hvc1')) {\n        return 'hevc';\n    }\n    else if (codecString === 'vp8') {\n        return 'vp8';\n    }\n    else if (codecString.startsWith('vp09')) {\n        return 'vp9';\n    }\n    else if (codecString.startsWith('av01')) {\n        return 'av1';\n    }\n    // Audio codecs\n    if (codecString.startsWith('mp4a.40') || codecString === 'mp4a.67') {\n        return 'aac';\n    }\n    else if (codecString === 'mp3'\n        || codecString === 'mp4a.69'\n        || codecString === 'mp4a.6B'\n        || codecString === 'mp4a.6b') {\n        return 'mp3';\n    }\n    else if (codecString === 'opus') {\n        return 'opus';\n    }\n    else if (codecString === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codecString === 'flac') {\n        return 'flac';\n    }\n    else if (codecString === 'ulaw') {\n        return 'ulaw';\n    }\n    else if (codecString === 'alaw') {\n        return 'alaw';\n    }\n    else if (PCM_CODEC_REGEX.test(codecString)) {\n        return codecString;\n    }\n    // Subtitle codecs\n    if (codecString === 'webvtt') {\n        return 'webvtt';\n    }\n    return null;\n};\nexport const getVideoEncoderConfigExtension = (codec) => {\n    if (codec === 'avc') {\n        return {\n            avc: {\n                format: 'avc', // Ensure the format is not Annex B\n            },\n        };\n    }\n    else if (codec === 'hevc') {\n        return {\n            hevc: {\n                format: 'hevc', // Ensure the format is not Annex B\n            },\n        };\n    }\n    return {};\n};\nexport const getAudioEncoderConfigExtension = (codec) => {\n    if (codec === 'aac') {\n        return {\n            aac: {\n                format: 'aac', // Ensure the format is not ADTS\n            },\n        };\n    }\n    else if (codec === 'opus') {\n        return {\n            opus: {\n                format: 'opus',\n            },\n        };\n    }\n    return {};\n};\nconst VALID_VIDEO_CODEC_STRING_PREFIXES = ['avc1', 'avc3', 'hev1', 'hvc1', 'vp8', 'vp09', 'av01'];\nconst AVC_CODEC_STRING_REGEX = /^(avc1|avc3)\\.[0-9a-fA-F]{6}$/;\nconst HEVC_CODEC_STRING_REGEX = /^(hev1|hvc1)\\.(?:[ABC]?\\d+)\\.[0-9a-fA-F]{1,8}\\.[LH]\\d+(?:\\.[0-9a-fA-F]{1,2}){0,6}$/;\nconst VP9_CODEC_STRING_REGEX = /^vp09(?:\\.\\d{2}){3}(?:(?:\\.\\d{2}){5})?$/;\nconst AV1_CODEC_STRING_REGEX = /^av01\\.\\d\\.\\d{2}[MH]\\.\\d{2}(?:\\.\\d\\.\\d{3}\\.\\d{2}\\.\\d{2}\\.\\d{2}\\.\\d)?$/;\nexport const validateVideoChunkMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Video chunk metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Video chunk metadata must be an object.');\n    }\n    if (!metadata.decoderConfig) {\n        throw new TypeError('Video chunk metadata must include a decoder configuration.');\n    }\n    if (typeof metadata.decoderConfig !== 'object') {\n        throw new TypeError('Video chunk metadata decoder configuration must be an object.');\n    }\n    if (typeof metadata.decoderConfig.codec !== 'string') {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a codec string.');\n    }\n    if (!VALID_VIDEO_CODEC_STRING_PREFIXES.some(prefix => metadata.decoderConfig.codec.startsWith(prefix))) {\n        throw new TypeError('Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in'\n            + ' the WebCodecs Codec Registry.');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.codedWidth) || metadata.decoderConfig.codedWidth <= 0) {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.codedHeight) || metadata.decoderConfig.codedHeight <= 0) {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).');\n    }\n    if (metadata.decoderConfig.description !== undefined) {\n        if (!isAllowSharedBufferSource(metadata.decoderConfig.description)) {\n            throw new TypeError('Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an'\n                + ' ArrayBuffer view.');\n        }\n    }\n    if (metadata.decoderConfig.colorSpace !== undefined) {\n        const { colorSpace } = metadata.decoderConfig;\n        if (typeof colorSpace !== 'object') {\n            throw new TypeError('Video chunk metadata decoder configuration colorSpace, when provided, must be an object.');\n        }\n        const primariesValues = Object.keys(COLOR_PRIMARIES_MAP);\n        if (colorSpace.primaries != null && !primariesValues.includes(colorSpace.primaries)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of`\n                + ` ${primariesValues.join(', ')}.`);\n        }\n        const transferValues = Object.keys(TRANSFER_CHARACTERISTICS_MAP);\n        if (colorSpace.transfer != null && !transferValues.includes(colorSpace.transfer)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of`\n                + ` ${transferValues.join(', ')}.`);\n        }\n        const matrixValues = Object.keys(MATRIX_COEFFICIENTS_MAP);\n        if (colorSpace.matrix != null && !matrixValues.includes(colorSpace.matrix)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of`\n                + ` ${matrixValues.join(', ')}.`);\n        }\n        if (colorSpace.fullRange != null && typeof colorSpace.fullRange !== 'boolean') {\n            throw new TypeError('Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.');\n        }\n    }\n    if (metadata.decoderConfig.codec.startsWith('avc1') || metadata.decoderConfig.codec.startsWith('avc3')) {\n        // AVC-specific validation\n        if (!AVC_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as'\n                + ' specified in Section 3.4 of RFC 6381.');\n        }\n        // `description` may or may not be set, depending on if the format is AVCC or Annex B, so don't perform any\n        // validation for it.\n        // https://www.w3.org/TR/webcodecs-avc-codec-registration\n    }\n    else if (metadata.decoderConfig.codec.startsWith('hev1') || metadata.decoderConfig.codec.startsWith('hvc1')) {\n        // HEVC-specific validation\n        if (!HEVC_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as'\n                + ' specified in Section E.3 of ISO 14496-15.');\n        }\n        // `description` may or may not be set, depending on if the format is HEVC or Annex B, so don't perform any\n        // validation for it.\n        // https://www.w3.org/TR/webcodecs-hevc-codec-registration\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vp8')) {\n        // VP8-specific validation\n        if (metadata.decoderConfig.codec !== 'vp8') {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be \"vp8\".');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vp09')) {\n        // VP9-specific validation\n        if (!VP9_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as'\n                + ' specified in Section \"Codecs Parameter String\" of https://www.webmproject.org/vp9/mp4/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('av01')) {\n        // AV1-specific validation\n        if (!AV1_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as'\n                + ' specified in Section \"Codecs Parameter String\" of https://aomediacodec.github.io/av1-isobmff/.');\n        }\n    }\n};\nconst VALID_AUDIO_CODEC_STRING_PREFIXES = ['mp4a', 'mp3', 'opus', 'vorbis', 'flac', 'ulaw', 'alaw', 'pcm'];\nexport const validateAudioChunkMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Audio chunk metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Audio chunk metadata must be an object.');\n    }\n    if (!metadata.decoderConfig) {\n        throw new TypeError('Audio chunk metadata must include a decoder configuration.');\n    }\n    if (typeof metadata.decoderConfig !== 'object') {\n        throw new TypeError('Audio chunk metadata decoder configuration must be an object.');\n    }\n    if (typeof metadata.decoderConfig.codec !== 'string') {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a codec string.');\n    }\n    if (!VALID_AUDIO_CODEC_STRING_PREFIXES.some(prefix => metadata.decoderConfig.codec.startsWith(prefix))) {\n        throw new TypeError('Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in'\n            + ' the WebCodecs Codec Registry.');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.sampleRate) || metadata.decoderConfig.sampleRate <= 0) {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.numberOfChannels) || metadata.decoderConfig.numberOfChannels <= 0) {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).');\n    }\n    if (metadata.decoderConfig.description !== undefined) {\n        if (!isAllowSharedBufferSource(metadata.decoderConfig.description)) {\n            throw new TypeError('Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an'\n                + ' ArrayBuffer view.');\n        }\n    }\n    if (metadata.decoderConfig.codec.startsWith('mp4a')\n        // These three refer to MP3:\n        && metadata.decoderConfig.codec !== 'mp4a.69'\n        && metadata.decoderConfig.codec !== 'mp4a.6B'\n        && metadata.decoderConfig.codec !== 'mp4a.6b') {\n        // AAC-specific validation\n        const validStrings = ['mp4a.40.2', 'mp4a.40.02', 'mp4a.40.5', 'mp4a.40.05', 'mp4a.40.29', 'mp4a.67'];\n        if (!validStrings.includes(metadata.decoderConfig.codec)) {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as'\n                + ' specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.');\n        }\n        if (!metadata.decoderConfig.description) {\n            throw new TypeError('Audio chunk metadata decoder configuration for AAC must include a description, which is expected to be'\n                + ' an AudioSpecificConfig as specified in ISO 14496-3.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('mp3') || metadata.decoderConfig.codec.startsWith('mp4a')) {\n        // MP3-specific validation\n        if (metadata.decoderConfig.codec !== 'mp3'\n            && metadata.decoderConfig.codec !== 'mp4a.69'\n            && metadata.decoderConfig.codec !== 'mp4a.6B'\n            && metadata.decoderConfig.codec !== 'mp4a.6b') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be \"mp3\", \"mp4a.69\" or'\n                + ' \"mp4a.6B\".');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('opus')) {\n        // Opus-specific validation\n        if (metadata.decoderConfig.codec !== 'opus') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be \"opus\".');\n        }\n        if (metadata.decoderConfig.description && metadata.decoderConfig.description.byteLength < 18) {\n            // Description is optional for Opus per-spec, so we shouldn't enforce it\n            throw new TypeError('Audio chunk metadata decoder configuration description, when specified, is expected to be an'\n                + ' Identification Header as specified in Section 5.1 of RFC 7845.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vorbis')) {\n        // Vorbis-specific validation\n        if (metadata.decoderConfig.codec !== 'vorbis') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be \"vorbis\".');\n        }\n        if (!metadata.decoderConfig.description) {\n            throw new TypeError('Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to'\n                + ' adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('flac')) {\n        // FLAC-specific validation\n        if (metadata.decoderConfig.codec !== 'flac') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be \"flac\".');\n        }\n        const minDescriptionSize = 4 + 4 + 34; // 'fLaC' + metadata block header + STREAMINFO block\n        if (!metadata.decoderConfig.description || metadata.decoderConfig.description.byteLength < minDescriptionSize) {\n            throw new TypeError('Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to'\n                + ' adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('pcm')\n        || metadata.decoderConfig.codec.startsWith('ulaw')\n        || metadata.decoderConfig.codec.startsWith('alaw')) {\n        // PCM-specific validation\n        if (!PCM_AUDIO_CODECS.includes(metadata.decoderConfig.codec)) {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM'\n                + ` codecs (${PCM_AUDIO_CODECS.join(', ')}).`);\n        }\n    }\n};\nexport const validateSubtitleMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Subtitle metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Subtitle metadata must be an object.');\n    }\n    if (!metadata.config) {\n        throw new TypeError('Subtitle metadata must include a config object.');\n    }\n    if (typeof metadata.config !== 'object') {\n        throw new TypeError('Subtitle metadata config must be an object.');\n    }\n    if (typeof metadata.config.description !== 'string') {\n        throw new TypeError('Subtitle metadata config description must be a string.');\n    }\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AsyncMutex } from './misc.js';\nexport class Muxer {\n    constructor(output) {\n        this.mutex = new AsyncMutex();\n        /**\n         * This field is used to synchronize multiple MediaStreamTracks. They use the same time coordinate system across\n         * tracks, and to ensure correct audio-video sync, we must use the same offset for all of them. The reason an offset\n         * is needed at all is because the timestamps typically don't start at zero.\n         */\n        this.firstMediaStreamTimestamp = null;\n        this.trackTimestampInfo = new WeakMap();\n        this.output = output;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onTrackClose(track) { }\n    validateAndNormalizeTimestamp(track, timestampInSeconds, isKeyPacket) {\n        timestampInSeconds += track.source._timestampOffset;\n        let timestampInfo = this.trackTimestampInfo.get(track);\n        if (!timestampInfo) {\n            if (!isKeyPacket) {\n                throw new Error('First packet must be a key packet.');\n            }\n            timestampInfo = {\n                maxTimestamp: timestampInSeconds,\n                maxTimestampBeforeLastKeyPacket: timestampInSeconds,\n            };\n            this.trackTimestampInfo.set(track, timestampInfo);\n        }\n        if (timestampInSeconds < 0) {\n            throw new Error(`Timestamps must be non-negative (got ${timestampInSeconds}s).`);\n        }\n        if (isKeyPacket) {\n            timestampInfo.maxTimestampBeforeLastKeyPacket = timestampInfo.maxTimestamp;\n        }\n        if (timestampInSeconds < timestampInfo.maxTimestampBeforeLastKeyPacket) {\n            throw new Error(`Timestamps cannot be smaller than the largest timestamp of the previous GOP (a GOP begins with a key`\n                + ` packet and ends right before the next key packet). Got ${timestampInSeconds}s, but largest`\n                + ` timestamp is ${timestampInfo.maxTimestampBeforeLastKeyPacket}s.`);\n        }\n        timestampInfo.maxTimestamp = Math.max(timestampInfo.maxTimestamp, timestampInSeconds);\n        return timestampInSeconds;\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { parseAacAudioSpecificConfig, validateAudioChunkMetadata } from '../codec.js';\nimport { assert, Bitstream, toUint8Array } from '../misc.js';\nimport { Muxer } from '../muxer.js';\nexport class AdtsMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.header = new Uint8Array(7);\n        this.headerBitstream = new Bitstream(this.header);\n        this.audioSpecificConfig = null;\n        this.format = format;\n        this.writer = output._writer;\n    }\n    async start() {\n        // Nothing needed here\n    }\n    async getMimeType() {\n        return 'audio/aac';\n    }\n    async addEncodedVideoPacket() {\n        throw new Error('ADTS does not support video.');\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        // https://wiki.multimedia.cx/index.php/ADTS (last visited: 2025/08/17)\n        const release = await this.mutex.acquire();\n        try {\n            this.validateAndNormalizeTimestamp(track, packet.timestamp, packet.type === 'key');\n            if (!this.audioSpecificConfig) {\n                validateAudioChunkMetadata(meta);\n                const description = meta?.decoderConfig?.description;\n                assert(description);\n                this.audioSpecificConfig = parseAacAudioSpecificConfig(toUint8Array(description));\n                const { objectType, frequencyIndex, channelConfiguration } = this.audioSpecificConfig;\n                const profile = objectType - 1;\n                this.headerBitstream.writeBits(12, 0b1111_11111111); // Syncword\n                this.headerBitstream.writeBits(1, 0); // MPEG Version\n                this.headerBitstream.writeBits(2, 0); // Layer\n                this.headerBitstream.writeBits(1, 1); // Protection absence\n                this.headerBitstream.writeBits(2, profile); // Profile\n                this.headerBitstream.writeBits(4, frequencyIndex); // MPEG-4 Sampling Frequency Index\n                this.headerBitstream.writeBits(1, 0); // Private bit\n                this.headerBitstream.writeBits(3, channelConfiguration); // MPEG-4 Channel Configuration\n                this.headerBitstream.writeBits(1, 0); // Originality\n                this.headerBitstream.writeBits(1, 0); // Home\n                this.headerBitstream.writeBits(1, 0); // Copyright ID bit\n                this.headerBitstream.writeBits(1, 0); // Copyright ID start\n                this.headerBitstream.skipBits(13); // Frame length\n                this.headerBitstream.writeBits(11, 0x7ff); // Buffer fullness\n                this.headerBitstream.writeBits(2, 0); // Number of AAC frames minus 1\n                // Omit CRC check\n            }\n            const frameLength = packet.data.byteLength + this.header.byteLength;\n            this.headerBitstream.pos = 30;\n            this.headerBitstream.writeBits(13, frameLength);\n            const startPos = this.writer.getPos();\n            this.writer.write(this.header);\n            this.writer.write(packet.data);\n            if (this.format._options.onFrame) {\n                const frameBytes = new Uint8Array(frameLength);\n                frameBytes.set(this.header, 0);\n                frameBytes.set(packet.data, this.header.byteLength);\n                this.format._options.onFrame(frameBytes, startPos);\n            }\n            await this.writer.flush();\n        }\n        finally {\n            release();\n        }\n    }\n    async addSubtitleCue() {\n        throw new Error('ADTS does not support subtitles.');\n    }\n    async finalize() { }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { VP9_LEVEL_TABLE } from './codec.js';\nimport { assert, assertNever, base64ToBytes, Bitstream, bytesToBase64, keyValueIterator, getUint24, last, readExpGolomb, readSignedExpGolomb, textDecoder, textEncoder, toDataView, toUint8Array, getChromiumVersion, isChromium, setUint24, } from './misc.js';\n// References for AVC/HEVC code:\n// ISO 14496-15\n// Rec. ITU-T H.264\n// Rec. ITU-T H.265\n// https://stackoverflow.com/questions/24884827\nexport var AvcNalUnitType;\n(function (AvcNalUnitType) {\n    AvcNalUnitType[AvcNalUnitType[\"IDR\"] = 5] = \"IDR\";\n    AvcNalUnitType[AvcNalUnitType[\"SEI\"] = 6] = \"SEI\";\n    AvcNalUnitType[AvcNalUnitType[\"SPS\"] = 7] = \"SPS\";\n    AvcNalUnitType[AvcNalUnitType[\"PPS\"] = 8] = \"PPS\";\n    AvcNalUnitType[AvcNalUnitType[\"SPS_EXT\"] = 13] = \"SPS_EXT\";\n})(AvcNalUnitType || (AvcNalUnitType = {}));\nexport var HevcNalUnitType;\n(function (HevcNalUnitType) {\n    HevcNalUnitType[HevcNalUnitType[\"RASL_N\"] = 8] = \"RASL_N\";\n    HevcNalUnitType[HevcNalUnitType[\"RASL_R\"] = 9] = \"RASL_R\";\n    HevcNalUnitType[HevcNalUnitType[\"BLA_W_LP\"] = 16] = \"BLA_W_LP\";\n    HevcNalUnitType[HevcNalUnitType[\"RSV_IRAP_VCL23\"] = 23] = \"RSV_IRAP_VCL23\";\n    HevcNalUnitType[HevcNalUnitType[\"VPS_NUT\"] = 32] = \"VPS_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"SPS_NUT\"] = 33] = \"SPS_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"PPS_NUT\"] = 34] = \"PPS_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"PREFIX_SEI_NUT\"] = 39] = \"PREFIX_SEI_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"SUFFIX_SEI_NUT\"] = 40] = \"SUFFIX_SEI_NUT\";\n})(HevcNalUnitType || (HevcNalUnitType = {}));\n/** Finds all NAL units in an AVC packet in Annex B format. */\nexport const findNalUnitsInAnnexB = (packetData) => {\n    const nalUnits = [];\n    let i = 0;\n    while (i < packetData.length) {\n        let startCodePos = -1;\n        let startCodeLength = 0;\n        for (let j = i; j < packetData.length - 3; j++) {\n            // Check for 3-byte start code (0x000001)\n            if (packetData[j] === 0 && packetData[j + 1] === 0 && packetData[j + 2] === 1) {\n                startCodePos = j;\n                startCodeLength = 3;\n                break;\n            }\n            // Check for 4-byte start code (0x00000001)\n            if (j < packetData.length - 4\n                && packetData[j] === 0\n                && packetData[j + 1] === 0\n                && packetData[j + 2] === 0\n                && packetData[j + 3] === 1) {\n                startCodePos = j;\n                startCodeLength = 4;\n                break;\n            }\n        }\n        if (startCodePos === -1) {\n            break; // No more start codes found\n        }\n        // If this isn't the first start code, extract the previous NAL unit\n        if (i > 0 && startCodePos > i) {\n            const nalData = packetData.subarray(i, startCodePos);\n            if (nalData.length > 0) {\n                nalUnits.push(nalData);\n            }\n        }\n        i = startCodePos + startCodeLength;\n    }\n    // Extract the last NAL unit if there is one\n    if (i < packetData.length) {\n        const nalData = packetData.subarray(i);\n        if (nalData.length > 0) {\n            nalUnits.push(nalData);\n        }\n    }\n    return nalUnits;\n};\n/** Finds all NAL units in an AVC packet in length-prefixed format. */\nconst findNalUnitsInLengthPrefixed = (packetData, lengthSize) => {\n    const nalUnits = [];\n    let offset = 0;\n    const dataView = new DataView(packetData.buffer, packetData.byteOffset, packetData.byteLength);\n    while (offset + lengthSize <= packetData.length) {\n        let nalUnitLength;\n        if (lengthSize === 1) {\n            nalUnitLength = dataView.getUint8(offset);\n        }\n        else if (lengthSize === 2) {\n            nalUnitLength = dataView.getUint16(offset, false);\n        }\n        else if (lengthSize === 3) {\n            nalUnitLength = getUint24(dataView, offset, false);\n        }\n        else if (lengthSize === 4) {\n            nalUnitLength = dataView.getUint32(offset, false);\n        }\n        else {\n            assertNever(lengthSize);\n            assert(false);\n        }\n        offset += lengthSize;\n        const nalUnit = packetData.subarray(offset, offset + nalUnitLength);\n        nalUnits.push(nalUnit);\n        offset += nalUnitLength;\n    }\n    return nalUnits;\n};\nconst removeEmulationPreventionBytes = (data) => {\n    const result = [];\n    const len = data.length;\n    for (let i = 0; i < len; i++) {\n        // Look for the 0x000003 pattern\n        if (i + 2 < len && data[i] === 0x00 && data[i + 1] === 0x00 && data[i + 2] === 0x03) {\n            result.push(0x00, 0x00); // Push the first two bytes\n            i += 2; // Skip the 0x03 byte\n        }\n        else {\n            result.push(data[i]);\n        }\n    }\n    return new Uint8Array(result);\n};\nconst ANNEX_B_START_CODE = new Uint8Array([0, 0, 0, 1]);\nexport const concatNalUnitsInAnnexB = (nalUnits) => {\n    const totalLength = nalUnits.reduce((a, b) => a + ANNEX_B_START_CODE.byteLength + b.byteLength, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const nalUnit of nalUnits) {\n        result.set(ANNEX_B_START_CODE, offset);\n        offset += ANNEX_B_START_CODE.byteLength;\n        result.set(nalUnit, offset);\n        offset += nalUnit.byteLength;\n    }\n    return result;\n};\nexport const concatNalUnitsInLengthPrefixed = (nalUnits, lengthSize) => {\n    const totalLength = nalUnits.reduce((a, b) => a + lengthSize + b.byteLength, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const nalUnit of nalUnits) {\n        const dataView = new DataView(result.buffer, result.byteOffset, result.byteLength);\n        switch (lengthSize) {\n            case 1:\n                dataView.setUint8(offset, nalUnit.byteLength);\n                break;\n            case 2:\n                dataView.setUint16(offset, nalUnit.byteLength, false);\n                break;\n            case 3:\n                setUint24(dataView, offset, nalUnit.byteLength, false);\n                break;\n            case 4:\n                dataView.setUint32(offset, nalUnit.byteLength, false);\n                break;\n        }\n        offset += lengthSize;\n        result.set(nalUnit, offset);\n        offset += nalUnit.byteLength;\n    }\n    return result;\n};\nexport const extractAvcNalUnits = (packetData, decoderConfig) => {\n    if (decoderConfig.description) {\n        // Stream is length-prefixed. Let's extract the size of the length prefix from the decoder config\n        const bytes = toUint8Array(decoderConfig.description);\n        const lengthSizeMinusOne = bytes[4] & 0b11;\n        const lengthSize = (lengthSizeMinusOne + 1);\n        return findNalUnitsInLengthPrefixed(packetData, lengthSize);\n    }\n    else {\n        // Stream is in Annex B format\n        return findNalUnitsInAnnexB(packetData);\n    }\n};\nexport const concatAvcNalUnits = (nalUnits, decoderConfig) => {\n    if (decoderConfig.description) {\n        // Stream is length-prefixed. Let's extract the size of the length prefix from the decoder config\n        const bytes = toUint8Array(decoderConfig.description);\n        const lengthSizeMinusOne = bytes[4] & 0b11;\n        const lengthSize = (lengthSizeMinusOne + 1);\n        return concatNalUnitsInLengthPrefixed(nalUnits, lengthSize);\n    }\n    else {\n        // Stream is in Annex B format\n        return concatNalUnitsInAnnexB(nalUnits);\n    }\n};\nexport const extractNalUnitTypeForAvc = (data) => {\n    return data[0] & 0x1F;\n};\n/** Builds an AvcDecoderConfigurationRecord from an AVC packet in Annex B format. */\nexport const extractAvcDecoderConfigurationRecord = (packetData) => {\n    try {\n        const nalUnits = findNalUnitsInAnnexB(packetData);\n        const spsUnits = nalUnits.filter(unit => extractNalUnitTypeForAvc(unit) === AvcNalUnitType.SPS);\n        const ppsUnits = nalUnits.filter(unit => extractNalUnitTypeForAvc(unit) === AvcNalUnitType.PPS);\n        const spsExtUnits = nalUnits.filter(unit => extractNalUnitTypeForAvc(unit) === AvcNalUnitType.SPS_EXT);\n        if (spsUnits.length === 0) {\n            return null;\n        }\n        if (ppsUnits.length === 0) {\n            return null;\n        }\n        // Let's get the first SPS for profile and level information\n        const spsData = spsUnits[0];\n        const spsInfo = parseAvcSps(spsData);\n        assert(spsInfo !== null);\n        const hasExtendedData = spsInfo.profileIdc === 100\n            || spsInfo.profileIdc === 110\n            || spsInfo.profileIdc === 122\n            || spsInfo.profileIdc === 144;\n        return {\n            configurationVersion: 1,\n            avcProfileIndication: spsInfo.profileIdc,\n            profileCompatibility: spsInfo.constraintFlags,\n            avcLevelIndication: spsInfo.levelIdc,\n            lengthSizeMinusOne: 3, // Typically 4 bytes for length field\n            sequenceParameterSets: spsUnits,\n            pictureParameterSets: ppsUnits,\n            chromaFormat: hasExtendedData ? spsInfo.chromaFormatIdc : null,\n            bitDepthLumaMinus8: hasExtendedData ? spsInfo.bitDepthLumaMinus8 : null,\n            bitDepthChromaMinus8: hasExtendedData ? spsInfo.bitDepthChromaMinus8 : null,\n            sequenceParameterSetExt: hasExtendedData ? spsExtUnits : null,\n        };\n    }\n    catch (error) {\n        console.error('Error building AVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\n/** Serializes an AvcDecoderConfigurationRecord into the format specified in Section 5.3.3.1 of ISO 14496-15. */\nexport const serializeAvcDecoderConfigurationRecord = (record) => {\n    const bytes = [];\n    // Write header\n    bytes.push(record.configurationVersion);\n    bytes.push(record.avcProfileIndication);\n    bytes.push(record.profileCompatibility);\n    bytes.push(record.avcLevelIndication);\n    bytes.push(0xFC | (record.lengthSizeMinusOne & 0x03)); // Reserved bits (6) + lengthSizeMinusOne (2)\n    // Reserved bits (3) + numOfSequenceParameterSets (5)\n    bytes.push(0xE0 | (record.sequenceParameterSets.length & 0x1F));\n    // Write SPS\n    for (const sps of record.sequenceParameterSets) {\n        const length = sps.byteLength;\n        bytes.push(length >> 8); // High byte\n        bytes.push(length & 0xFF); // Low byte\n        for (let i = 0; i < length; i++) {\n            bytes.push(sps[i]);\n        }\n    }\n    bytes.push(record.pictureParameterSets.length);\n    // Write PPS\n    for (const pps of record.pictureParameterSets) {\n        const length = pps.byteLength;\n        bytes.push(length >> 8); // High byte\n        bytes.push(length & 0xFF); // Low byte\n        for (let i = 0; i < length; i++) {\n            bytes.push(pps[i]);\n        }\n    }\n    if (record.avcProfileIndication === 100\n        || record.avcProfileIndication === 110\n        || record.avcProfileIndication === 122\n        || record.avcProfileIndication === 144) {\n        assert(record.chromaFormat !== null);\n        assert(record.bitDepthLumaMinus8 !== null);\n        assert(record.bitDepthChromaMinus8 !== null);\n        assert(record.sequenceParameterSetExt !== null);\n        bytes.push(0xFC | (record.chromaFormat & 0x03)); // Reserved bits + chroma_format\n        bytes.push(0xF8 | (record.bitDepthLumaMinus8 & 0x07)); // Reserved bits + bit_depth_luma_minus8\n        bytes.push(0xF8 | (record.bitDepthChromaMinus8 & 0x07)); // Reserved bits + bit_depth_chroma_minus8\n        bytes.push(record.sequenceParameterSetExt.length);\n        // Write SPS Ext\n        for (const spsExt of record.sequenceParameterSetExt) {\n            const length = spsExt.byteLength;\n            bytes.push(length >> 8); // High byte\n            bytes.push(length & 0xFF); // Low byte\n            for (let i = 0; i < length; i++) {\n                bytes.push(spsExt[i]);\n            }\n        }\n    }\n    return new Uint8Array(bytes);\n};\n/** Deserializes an AvcDecoderConfigurationRecord from the format specified in Section 5.3.3.1 of ISO 14496-15. */\nexport const deserializeAvcDecoderConfigurationRecord = (data) => {\n    try {\n        const view = toDataView(data);\n        let offset = 0;\n        // Read header\n        const configurationVersion = view.getUint8(offset++);\n        const avcProfileIndication = view.getUint8(offset++);\n        const profileCompatibility = view.getUint8(offset++);\n        const avcLevelIndication = view.getUint8(offset++);\n        const lengthSizeMinusOne = view.getUint8(offset++) & 0x03;\n        const numOfSequenceParameterSets = view.getUint8(offset++) & 0x1F;\n        // Read SPS\n        const sequenceParameterSets = [];\n        for (let i = 0; i < numOfSequenceParameterSets; i++) {\n            const length = view.getUint16(offset, false);\n            offset += 2;\n            sequenceParameterSets.push(data.subarray(offset, offset + length));\n            offset += length;\n        }\n        const numOfPictureParameterSets = view.getUint8(offset++);\n        // Read PPS\n        const pictureParameterSets = [];\n        for (let i = 0; i < numOfPictureParameterSets; i++) {\n            const length = view.getUint16(offset, false);\n            offset += 2;\n            pictureParameterSets.push(data.subarray(offset, offset + length));\n            offset += length;\n        }\n        const record = {\n            configurationVersion,\n            avcProfileIndication,\n            profileCompatibility,\n            avcLevelIndication,\n            lengthSizeMinusOne,\n            sequenceParameterSets,\n            pictureParameterSets,\n            chromaFormat: null,\n            bitDepthLumaMinus8: null,\n            bitDepthChromaMinus8: null,\n            sequenceParameterSetExt: null,\n        };\n        // Check if there are extended profile fields\n        if ((avcProfileIndication === 100\n            || avcProfileIndication === 110\n            || avcProfileIndication === 122\n            || avcProfileIndication === 144)\n            && offset + 4 <= data.length) {\n            const chromaFormat = view.getUint8(offset++) & 0x03;\n            const bitDepthLumaMinus8 = view.getUint8(offset++) & 0x07;\n            const bitDepthChromaMinus8 = view.getUint8(offset++) & 0x07;\n            const numOfSequenceParameterSetExt = view.getUint8(offset++);\n            record.chromaFormat = chromaFormat;\n            record.bitDepthLumaMinus8 = bitDepthLumaMinus8;\n            record.bitDepthChromaMinus8 = bitDepthChromaMinus8;\n            // Read SPS Ext\n            const sequenceParameterSetExt = [];\n            for (let i = 0; i < numOfSequenceParameterSetExt; i++) {\n                const length = view.getUint16(offset, false);\n                offset += 2;\n                sequenceParameterSetExt.push(data.subarray(offset, offset + length));\n                offset += length;\n            }\n            record.sequenceParameterSetExt = sequenceParameterSetExt;\n        }\n        return record;\n    }\n    catch (error) {\n        console.error('Error deserializing AVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\n/** Parses an AVC SPS (Sequence Parameter Set) to extract basic information. */\nexport const parseAvcSps = (sps) => {\n    try {\n        const bitstream = new Bitstream(removeEmulationPreventionBytes(sps));\n        bitstream.skipBits(1); // forbidden_zero_bit\n        bitstream.skipBits(2); // nal_ref_idc\n        const nalUnitType = bitstream.readBits(5);\n        if (nalUnitType !== 7) { // SPS NAL unit type is 7\n            return null;\n        }\n        const profileIdc = bitstream.readAlignedByte();\n        const constraintFlags = bitstream.readAlignedByte();\n        const levelIdc = bitstream.readAlignedByte();\n        readExpGolomb(bitstream); // seq_parameter_set_id\n        let chromaFormatIdc = null;\n        let bitDepthLumaMinus8 = null;\n        let bitDepthChromaMinus8 = null;\n        // Handle high profile chroma_format_idc\n        if (profileIdc === 100\n            || profileIdc === 110\n            || profileIdc === 122\n            || profileIdc === 244\n            || profileIdc === 44\n            || profileIdc === 83\n            || profileIdc === 86\n            || profileIdc === 118\n            || profileIdc === 128) {\n            chromaFormatIdc = readExpGolomb(bitstream);\n            if (chromaFormatIdc === 3) {\n                bitstream.skipBits(1); // separate_colour_plane_flag\n            }\n            bitDepthLumaMinus8 = readExpGolomb(bitstream);\n            bitDepthChromaMinus8 = readExpGolomb(bitstream);\n            bitstream.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n            const seqScalingMatrixPresentFlag = bitstream.readBits(1);\n            if (seqScalingMatrixPresentFlag) {\n                for (let i = 0; i < (chromaFormatIdc !== 3 ? 8 : 12); i++) {\n                    const seqScalingListPresentFlag = bitstream.readBits(1);\n                    if (seqScalingListPresentFlag) {\n                        const sizeOfScalingList = i < 6 ? 16 : 64;\n                        let lastScale = 8;\n                        let nextScale = 8;\n                        for (let j = 0; j < sizeOfScalingList; j++) {\n                            if (nextScale !== 0) {\n                                const deltaScale = readSignedExpGolomb(bitstream);\n                                nextScale = (lastScale + deltaScale + 256) % 256;\n                            }\n                            lastScale = nextScale === 0 ? lastScale : nextScale;\n                        }\n                    }\n                }\n            }\n        }\n        readExpGolomb(bitstream); // log2_max_frame_num_minus4\n        const picOrderCntType = readExpGolomb(bitstream);\n        if (picOrderCntType === 0) {\n            readExpGolomb(bitstream); // log2_max_pic_order_cnt_lsb_minus4\n        }\n        else if (picOrderCntType === 1) {\n            bitstream.skipBits(1); // delta_pic_order_always_zero_flag\n            readSignedExpGolomb(bitstream); // offset_for_non_ref_pic\n            readSignedExpGolomb(bitstream); // offset_for_top_to_bottom_field\n            const numRefFramesInPicOrderCntCycle = readExpGolomb(bitstream);\n            for (let i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n                readSignedExpGolomb(bitstream); // offset_for_ref_frame[i]\n            }\n        }\n        readExpGolomb(bitstream); // max_num_ref_frames\n        bitstream.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n        readExpGolomb(bitstream); // pic_width_in_mbs_minus1\n        readExpGolomb(bitstream); // pic_height_in_map_units_minus1\n        const frameMbsOnlyFlag = bitstream.readBits(1);\n        return {\n            profileIdc,\n            constraintFlags,\n            levelIdc,\n            frameMbsOnlyFlag,\n            chromaFormatIdc,\n            bitDepthLumaMinus8,\n            bitDepthChromaMinus8,\n        };\n    }\n    catch (error) {\n        console.error('Error parsing AVC SPS:', error);\n        return null;\n    }\n};\nexport const extractHevcNalUnits = (packetData, decoderConfig) => {\n    if (decoderConfig.description) {\n        // Stream is length-prefixed. Let's extract the size of the length prefix from the decoder config\n        const bytes = toUint8Array(decoderConfig.description);\n        const lengthSizeMinusOne = bytes[21] & 0b11;\n        const lengthSize = (lengthSizeMinusOne + 1);\n        return findNalUnitsInLengthPrefixed(packetData, lengthSize);\n    }\n    else {\n        // Stream is in Annex B format\n        return findNalUnitsInAnnexB(packetData);\n    }\n};\nexport const extractNalUnitTypeForHevc = (data) => {\n    return (data[0] >> 1) & 0x3F;\n};\n/** Builds a HevcDecoderConfigurationRecord from an HEVC packet in Annex B format. */\nexport const extractHevcDecoderConfigurationRecord = (packetData) => {\n    try {\n        const nalUnits = findNalUnitsInAnnexB(packetData);\n        const vpsUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === HevcNalUnitType.VPS_NUT);\n        const spsUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === HevcNalUnitType.SPS_NUT);\n        const ppsUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === HevcNalUnitType.PPS_NUT);\n        const seiUnits = nalUnits.filter(unit => extractNalUnitTypeForHevc(unit) === HevcNalUnitType.PREFIX_SEI_NUT\n            || extractNalUnitTypeForHevc(unit) === HevcNalUnitType.SUFFIX_SEI_NUT);\n        if (spsUnits.length === 0 || ppsUnits.length === 0)\n            return null;\n        const sps = spsUnits[0];\n        const bitstream = new Bitstream(removeEmulationPreventionBytes(sps));\n        bitstream.skipBits(16); // NAL header\n        bitstream.readBits(4); // sps_video_parameter_set_id\n        const sps_max_sub_layers_minus1 = bitstream.readBits(3);\n        const sps_temporal_id_nesting_flag = bitstream.readBits(1);\n        const { general_profile_space, general_tier_flag, general_profile_idc, general_profile_compatibility_flags, general_constraint_indicator_flags, general_level_idc, } = parseProfileTierLevel(bitstream, sps_max_sub_layers_minus1);\n        readExpGolomb(bitstream); // sps_seq_parameter_set_id\n        const chroma_format_idc = readExpGolomb(bitstream);\n        if (chroma_format_idc === 3)\n            bitstream.skipBits(1); // separate_colour_plane_flag\n        readExpGolomb(bitstream); // pic_width_in_luma_samples\n        readExpGolomb(bitstream); // pic_height_in_luma_samples\n        if (bitstream.readBits(1)) { // conformance_window_flag\n            readExpGolomb(bitstream); // conf_win_left_offset\n            readExpGolomb(bitstream); // conf_win_right_offset\n            readExpGolomb(bitstream); // conf_win_top_offset\n            readExpGolomb(bitstream); // conf_win_bottom_offset\n        }\n        const bit_depth_luma_minus8 = readExpGolomb(bitstream);\n        const bit_depth_chroma_minus8 = readExpGolomb(bitstream);\n        readExpGolomb(bitstream); // log2_max_pic_order_cnt_lsb_minus4\n        const sps_sub_layer_ordering_info_present_flag = bitstream.readBits(1);\n        const maxNum = sps_sub_layer_ordering_info_present_flag ? 0 : sps_max_sub_layers_minus1;\n        for (let i = maxNum; i <= sps_max_sub_layers_minus1; i++) {\n            readExpGolomb(bitstream); // sps_max_dec_pic_buffering_minus1[i]\n            readExpGolomb(bitstream); // sps_max_num_reorder_pics[i]\n            readExpGolomb(bitstream); // sps_max_latency_increase_plus1[i]\n        }\n        readExpGolomb(bitstream); // log2_min_luma_coding_block_size_minus3\n        readExpGolomb(bitstream); // log2_diff_max_min_luma_coding_block_size\n        readExpGolomb(bitstream); // log2_min_luma_transform_block_size_minus2\n        readExpGolomb(bitstream); // log2_diff_max_min_luma_transform_block_size\n        readExpGolomb(bitstream); // max_transform_hierarchy_depth_inter\n        readExpGolomb(bitstream); // max_transform_hierarchy_depth_intra\n        if (bitstream.readBits(1)) { // scaling_list_enabled_flag\n            if (bitstream.readBits(1)) {\n                skipScalingListData(bitstream);\n            }\n        }\n        bitstream.skipBits(1); // amp_enabled_flag\n        bitstream.skipBits(1); // sample_adaptive_offset_enabled_flag\n        if (bitstream.readBits(1)) { // pcm_enabled_flag\n            bitstream.skipBits(4); // pcm_sample_bit_depth_luma_minus1\n            bitstream.skipBits(4); // pcm_sample_bit_depth_chroma_minus1\n            readExpGolomb(bitstream); // log2_min_pcm_luma_coding_block_size_minus3\n            readExpGolomb(bitstream); // log2_diff_max_min_pcm_luma_coding_block_size\n            bitstream.skipBits(1); // pcm_loop_filter_disabled_flag\n        }\n        const num_short_term_ref_pic_sets = readExpGolomb(bitstream);\n        skipAllStRefPicSets(bitstream, num_short_term_ref_pic_sets);\n        if (bitstream.readBits(1)) { // long_term_ref_pics_present_flag\n            const num_long_term_ref_pics_sps = readExpGolomb(bitstream);\n            for (let i = 0; i < num_long_term_ref_pics_sps; i++) {\n                readExpGolomb(bitstream); // lt_ref_pic_poc_lsb_sps[i]\n                bitstream.skipBits(1); // used_by_curr_pic_lt_sps_flag[i]\n            }\n        }\n        bitstream.skipBits(1); // sps_temporal_mvp_enabled_flag\n        bitstream.skipBits(1); // strong_intra_smoothing_enabled_flag\n        let min_spatial_segmentation_idc = 0;\n        if (bitstream.readBits(1)) { // vui_parameters_present_flag\n            min_spatial_segmentation_idc = parseVuiForMinSpatialSegmentationIdc(bitstream, sps_max_sub_layers_minus1);\n        }\n        // Parse PPS for parallelismType\n        let parallelismType = 0;\n        if (ppsUnits.length > 0) {\n            const pps = ppsUnits[0];\n            const ppsBitstream = new Bitstream(removeEmulationPreventionBytes(pps));\n            ppsBitstream.skipBits(16); // NAL header\n            readExpGolomb(ppsBitstream); // pps_pic_parameter_set_id\n            readExpGolomb(ppsBitstream); // pps_seq_parameter_set_id\n            ppsBitstream.skipBits(1); // dependent_slice_segments_enabled_flag\n            ppsBitstream.skipBits(1); // output_flag_present_flag\n            ppsBitstream.skipBits(3); // num_extra_slice_header_bits\n            ppsBitstream.skipBits(1); // sign_data_hiding_enabled_flag\n            ppsBitstream.skipBits(1); // cabac_init_present_flag\n            readExpGolomb(ppsBitstream); // num_ref_idx_l0_default_active_minus1\n            readExpGolomb(ppsBitstream); // num_ref_idx_l1_default_active_minus1\n            readSignedExpGolomb(ppsBitstream); // init_qp_minus26\n            ppsBitstream.skipBits(1); // constrained_intra_pred_flag\n            ppsBitstream.skipBits(1); // transform_skip_enabled_flag\n            if (ppsBitstream.readBits(1)) { // cu_qp_delta_enabled_flag\n                readExpGolomb(ppsBitstream); // diff_cu_qp_delta_depth\n            }\n            readSignedExpGolomb(ppsBitstream); // pps_cb_qp_offset\n            readSignedExpGolomb(ppsBitstream); // pps_cr_qp_offset\n            ppsBitstream.skipBits(1); // pps_slice_chroma_qp_offsets_present_flag\n            ppsBitstream.skipBits(1); // weighted_pred_flag\n            ppsBitstream.skipBits(1); // weighted_bipred_flag\n            ppsBitstream.skipBits(1); // transquant_bypass_enabled_flag\n            const tiles_enabled_flag = ppsBitstream.readBits(1);\n            const entropy_coding_sync_enabled_flag = ppsBitstream.readBits(1);\n            if (!tiles_enabled_flag && !entropy_coding_sync_enabled_flag)\n                parallelismType = 0;\n            else if (tiles_enabled_flag && !entropy_coding_sync_enabled_flag)\n                parallelismType = 2;\n            else if (!tiles_enabled_flag && entropy_coding_sync_enabled_flag)\n                parallelismType = 3;\n            else\n                parallelismType = 0;\n        }\n        const arrays = [\n            ...(vpsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: HevcNalUnitType.VPS_NUT,\n                        nalUnits: vpsUnits,\n                    },\n                ]\n                : []),\n            ...(spsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: HevcNalUnitType.SPS_NUT,\n                        nalUnits: spsUnits,\n                    },\n                ]\n                : []),\n            ...(ppsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: HevcNalUnitType.PPS_NUT,\n                        nalUnits: ppsUnits,\n                    },\n                ]\n                : []),\n            ...(seiUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: extractNalUnitTypeForHevc(seiUnits[0]),\n                        nalUnits: seiUnits,\n                    },\n                ]\n                : []),\n        ];\n        const record = {\n            configurationVersion: 1,\n            generalProfileSpace: general_profile_space,\n            generalTierFlag: general_tier_flag,\n            generalProfileIdc: general_profile_idc,\n            generalProfileCompatibilityFlags: general_profile_compatibility_flags,\n            generalConstraintIndicatorFlags: general_constraint_indicator_flags,\n            generalLevelIdc: general_level_idc,\n            minSpatialSegmentationIdc: min_spatial_segmentation_idc,\n            parallelismType,\n            chromaFormatIdc: chroma_format_idc,\n            bitDepthLumaMinus8: bit_depth_luma_minus8,\n            bitDepthChromaMinus8: bit_depth_chroma_minus8,\n            avgFrameRate: 0,\n            constantFrameRate: 0,\n            numTemporalLayers: sps_max_sub_layers_minus1 + 1,\n            temporalIdNested: sps_temporal_id_nesting_flag,\n            lengthSizeMinusOne: 3,\n            arrays,\n        };\n        return record;\n    }\n    catch (error) {\n        console.error('Error building HEVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\nconst parseProfileTierLevel = (bitstream, maxNumSubLayersMinus1) => {\n    const general_profile_space = bitstream.readBits(2);\n    const general_tier_flag = bitstream.readBits(1);\n    const general_profile_idc = bitstream.readBits(5);\n    let general_profile_compatibility_flags = 0;\n    for (let i = 0; i < 32; i++) {\n        general_profile_compatibility_flags = (general_profile_compatibility_flags << 1) | bitstream.readBits(1);\n    }\n    const general_constraint_indicator_flags = new Uint8Array(6);\n    for (let i = 0; i < 6; i++) {\n        general_constraint_indicator_flags[i] = bitstream.readBits(8);\n    }\n    const general_level_idc = bitstream.readBits(8);\n    const sub_layer_profile_present_flag = [];\n    const sub_layer_level_present_flag = [];\n    for (let i = 0; i < maxNumSubLayersMinus1; i++) {\n        sub_layer_profile_present_flag.push(bitstream.readBits(1));\n        sub_layer_level_present_flag.push(bitstream.readBits(1));\n    }\n    if (maxNumSubLayersMinus1 > 0) {\n        for (let i = maxNumSubLayersMinus1; i < 8; i++) {\n            bitstream.skipBits(2); // reserved_zero_2bits\n        }\n    }\n    for (let i = 0; i < maxNumSubLayersMinus1; i++) {\n        if (sub_layer_profile_present_flag[i])\n            bitstream.skipBits(88);\n        if (sub_layer_level_present_flag[i])\n            bitstream.skipBits(8);\n    }\n    return {\n        general_profile_space,\n        general_tier_flag,\n        general_profile_idc,\n        general_profile_compatibility_flags,\n        general_constraint_indicator_flags,\n        general_level_idc,\n    };\n};\nconst skipScalingListData = (bitstream) => {\n    for (let sizeId = 0; sizeId < 4; sizeId++) {\n        for (let matrixId = 0; matrixId < (sizeId === 3 ? 2 : 6); matrixId++) {\n            const scaling_list_pred_mode_flag = bitstream.readBits(1);\n            if (!scaling_list_pred_mode_flag) {\n                readExpGolomb(bitstream); // scaling_list_pred_matrix_id_delta\n            }\n            else {\n                const coefNum = Math.min(64, 1 << (4 + (sizeId << 1)));\n                if (sizeId > 1) {\n                    readSignedExpGolomb(bitstream); // scaling_list_dc_coef_minus8\n                }\n                for (let i = 0; i < coefNum; i++) {\n                    readSignedExpGolomb(bitstream); // scaling_list_delta_coef\n                }\n            }\n        }\n    }\n};\nconst skipAllStRefPicSets = (bitstream, num_short_term_ref_pic_sets) => {\n    const NumDeltaPocs = [];\n    for (let stRpsIdx = 0; stRpsIdx < num_short_term_ref_pic_sets; stRpsIdx++) {\n        NumDeltaPocs[stRpsIdx] = skipStRefPicSet(bitstream, stRpsIdx, num_short_term_ref_pic_sets, NumDeltaPocs);\n    }\n};\nconst skipStRefPicSet = (bitstream, stRpsIdx, num_short_term_ref_pic_sets, NumDeltaPocs) => {\n    let NumDeltaPocsThis = 0;\n    let inter_ref_pic_set_prediction_flag = 0;\n    let RefRpsIdx = 0;\n    if (stRpsIdx !== 0) {\n        inter_ref_pic_set_prediction_flag = bitstream.readBits(1);\n    }\n    if (inter_ref_pic_set_prediction_flag) {\n        if (stRpsIdx === num_short_term_ref_pic_sets) {\n            const delta_idx_minus1 = readExpGolomb(bitstream);\n            RefRpsIdx = stRpsIdx - (delta_idx_minus1 + 1);\n        }\n        else {\n            RefRpsIdx = stRpsIdx - 1;\n        }\n        bitstream.readBits(1); // delta_rps_sign\n        readExpGolomb(bitstream); // abs_delta_rps_minus1\n        // The number of iterations is NumDeltaPocs[RefRpsIdx] + 1\n        const numDelta = NumDeltaPocs[RefRpsIdx] ?? 0;\n        for (let j = 0; j <= numDelta; j++) {\n            const used_by_curr_pic_flag = bitstream.readBits(1);\n            if (!used_by_curr_pic_flag) {\n                bitstream.readBits(1); // use_delta_flag\n            }\n        }\n        NumDeltaPocsThis = NumDeltaPocs[RefRpsIdx];\n    }\n    else {\n        const num_negative_pics = readExpGolomb(bitstream);\n        const num_positive_pics = readExpGolomb(bitstream);\n        for (let i = 0; i < num_negative_pics; i++) {\n            readExpGolomb(bitstream); // delta_poc_s0_minus1[i]\n            bitstream.readBits(1); // used_by_curr_pic_s0_flag[i]\n        }\n        for (let i = 0; i < num_positive_pics; i++) {\n            readExpGolomb(bitstream); // delta_poc_s1_minus1[i]\n            bitstream.readBits(1); // used_by_curr_pic_s1_flag[i]\n        }\n        NumDeltaPocsThis = num_negative_pics + num_positive_pics;\n    }\n    return NumDeltaPocsThis;\n};\nconst parseVuiForMinSpatialSegmentationIdc = (bitstream, sps_max_sub_layers_minus1) => {\n    if (bitstream.readBits(1)) { // aspect_ratio_info_present_flag\n        const aspect_ratio_idc = bitstream.readBits(8);\n        if (aspect_ratio_idc === 255) {\n            bitstream.readBits(16); // sar_width\n            bitstream.readBits(16); // sar_height\n        }\n    }\n    if (bitstream.readBits(1)) { // overscan_info_present_flag\n        bitstream.readBits(1); // overscan_appropriate_flag\n    }\n    if (bitstream.readBits(1)) { // video_signal_type_present_flag\n        bitstream.readBits(3); // video_format\n        bitstream.readBits(1); // video_full_range_flag\n        if (bitstream.readBits(1)) {\n            bitstream.readBits(8); // colour_primaries\n            bitstream.readBits(8); // transfer_characteristics\n            bitstream.readBits(8); // matrix_coeffs\n        }\n    }\n    if (bitstream.readBits(1)) { // chroma_loc_info_present_flag\n        readExpGolomb(bitstream); // chroma_sample_loc_type_top_field\n        readExpGolomb(bitstream); // chroma_sample_loc_type_bottom_field\n    }\n    bitstream.readBits(1); // neutral_chroma_indication_flag\n    bitstream.readBits(1); // field_seq_flag\n    bitstream.readBits(1); // frame_field_info_present_flag\n    if (bitstream.readBits(1)) { // default_display_window_flag\n        readExpGolomb(bitstream); // def_disp_win_left_offset\n        readExpGolomb(bitstream); // def_disp_win_right_offset\n        readExpGolomb(bitstream); // def_disp_win_top_offset\n        readExpGolomb(bitstream); // def_disp_win_bottom_offset\n    }\n    if (bitstream.readBits(1)) { // vui_timing_info_present_flag\n        bitstream.readBits(32); // vui_num_units_in_tick\n        bitstream.readBits(32); // vui_time_scale\n        if (bitstream.readBits(1)) { // vui_poc_proportional_to_timing_flag\n            readExpGolomb(bitstream); // vui_num_ticks_poc_diff_one_minus1\n        }\n        if (bitstream.readBits(1)) {\n            skipHrdParameters(bitstream, true, sps_max_sub_layers_minus1);\n        }\n    }\n    if (bitstream.readBits(1)) { // bitstream_restriction_flag\n        bitstream.readBits(1); // tiles_fixed_structure_flag\n        bitstream.readBits(1); // motion_vectors_over_pic_boundaries_flag\n        bitstream.readBits(1); // restricted_ref_pic_lists_flag\n        const min_spatial_segmentation_idc = readExpGolomb(bitstream);\n        // skip the rest\n        readExpGolomb(bitstream); // max_bytes_per_pic_denom\n        readExpGolomb(bitstream); // max_bits_per_min_cu_denom\n        readExpGolomb(bitstream); // log2_max_mv_length_horizontal\n        readExpGolomb(bitstream); // log2_max_mv_length_vertical\n        return min_spatial_segmentation_idc;\n    }\n    return 0;\n};\nconst skipHrdParameters = (bitstream, commonInfPresentFlag, maxNumSubLayersMinus1) => {\n    let nal_hrd_parameters_present_flag = false;\n    let vcl_hrd_parameters_present_flag = false;\n    let sub_pic_hrd_params_present_flag = false;\n    if (commonInfPresentFlag) {\n        nal_hrd_parameters_present_flag = bitstream.readBits(1) === 1;\n        vcl_hrd_parameters_present_flag = bitstream.readBits(1) === 1;\n        if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {\n            sub_pic_hrd_params_present_flag = bitstream.readBits(1) === 1;\n            if (sub_pic_hrd_params_present_flag) {\n                bitstream.readBits(8); // tick_divisor_minus2\n                bitstream.readBits(5); // du_cpb_removal_delay_increment_length_minus1\n                bitstream.readBits(1); // sub_pic_cpb_params_in_pic_timing_sei_flag\n                bitstream.readBits(5); // dpb_output_delay_du_length_minus1\n            }\n            bitstream.readBits(4); // bit_rate_scale\n            bitstream.readBits(4); // cpb_size_scale\n            if (sub_pic_hrd_params_present_flag) {\n                bitstream.readBits(4); // cpb_size_du_scale\n            }\n            bitstream.readBits(5); // initial_cpb_removal_delay_length_minus1\n            bitstream.readBits(5); // au_cpb_removal_delay_length_minus1\n            bitstream.readBits(5); // dpb_output_delay_length_minus1\n        }\n    }\n    for (let i = 0; i <= maxNumSubLayersMinus1; i++) {\n        const fixed_pic_rate_general_flag = bitstream.readBits(1) === 1;\n        let fixed_pic_rate_within_cvs_flag = true; // Default assumption if general is true\n        if (!fixed_pic_rate_general_flag) {\n            fixed_pic_rate_within_cvs_flag = bitstream.readBits(1) === 1;\n        }\n        let low_delay_hrd_flag = false; // Default assumption\n        if (fixed_pic_rate_within_cvs_flag) {\n            readExpGolomb(bitstream); // elemental_duration_in_tc_minus1[i]\n        }\n        else {\n            low_delay_hrd_flag = bitstream.readBits(1) === 1;\n        }\n        let CpbCnt = 1; // Default if low_delay is true\n        if (!low_delay_hrd_flag) {\n            const cpb_cnt_minus1 = readExpGolomb(bitstream); // cpb_cnt_minus1[i]\n            CpbCnt = cpb_cnt_minus1 + 1;\n        }\n        if (nal_hrd_parameters_present_flag) {\n            skipSubLayerHrdParameters(bitstream, CpbCnt, sub_pic_hrd_params_present_flag);\n        }\n        if (vcl_hrd_parameters_present_flag) {\n            skipSubLayerHrdParameters(bitstream, CpbCnt, sub_pic_hrd_params_present_flag);\n        }\n    }\n};\nconst skipSubLayerHrdParameters = (bitstream, CpbCnt, sub_pic_hrd_params_present_flag) => {\n    for (let i = 0; i < CpbCnt; i++) {\n        readExpGolomb(bitstream); // bit_rate_value_minus1[i]\n        readExpGolomb(bitstream); // cpb_size_value_minus1[i]\n        if (sub_pic_hrd_params_present_flag) {\n            readExpGolomb(bitstream); // cpb_size_du_value_minus1[i]\n            readExpGolomb(bitstream); // bit_rate_du_value_minus1[i]\n        }\n        bitstream.readBits(1); // cbr_flag[i]\n    }\n};\n/** Serializes an HevcDecoderConfigurationRecord into the format specified in Section 8.3.3.1 of ISO 14496-15. */\nexport const serializeHevcDecoderConfigurationRecord = (record) => {\n    const bytes = [];\n    bytes.push(record.configurationVersion);\n    bytes.push(((record.generalProfileSpace & 0x3) << 6)\n        | ((record.generalTierFlag & 0x1) << 5)\n        | (record.generalProfileIdc & 0x1F));\n    bytes.push((record.generalProfileCompatibilityFlags >>> 24) & 0xFF);\n    bytes.push((record.generalProfileCompatibilityFlags >>> 16) & 0xFF);\n    bytes.push((record.generalProfileCompatibilityFlags >>> 8) & 0xFF);\n    bytes.push(record.generalProfileCompatibilityFlags & 0xFF);\n    bytes.push(...record.generalConstraintIndicatorFlags);\n    bytes.push(record.generalLevelIdc & 0xFF);\n    bytes.push(0xF0 | ((record.minSpatialSegmentationIdc >> 8) & 0x0F)); // Reserved + high nibble\n    bytes.push(record.minSpatialSegmentationIdc & 0xFF); // Low byte\n    bytes.push(0xFC | (record.parallelismType & 0x03));\n    bytes.push(0xFC | (record.chromaFormatIdc & 0x03));\n    bytes.push(0xF8 | (record.bitDepthLumaMinus8 & 0x07));\n    bytes.push(0xF8 | (record.bitDepthChromaMinus8 & 0x07));\n    bytes.push((record.avgFrameRate >> 8) & 0xFF); // High byte\n    bytes.push(record.avgFrameRate & 0xFF); // Low byte\n    bytes.push(((record.constantFrameRate & 0x03) << 6)\n        | ((record.numTemporalLayers & 0x07) << 3)\n        | ((record.temporalIdNested & 0x01) << 2)\n        | (record.lengthSizeMinusOne & 0x03));\n    bytes.push(record.arrays.length & 0xFF);\n    for (const arr of record.arrays) {\n        bytes.push(((arr.arrayCompleteness & 0x01) << 7)\n            | (0 << 6)\n            | (arr.nalUnitType & 0x3F));\n        bytes.push((arr.nalUnits.length >> 8) & 0xFF); // High byte\n        bytes.push(arr.nalUnits.length & 0xFF); // Low byte\n        for (const nal of arr.nalUnits) {\n            bytes.push((nal.length >> 8) & 0xFF); // High byte\n            bytes.push(nal.length & 0xFF); // Low byte\n            for (let i = 0; i < nal.length; i++) {\n                bytes.push(nal[i]);\n            }\n        }\n    }\n    return new Uint8Array(bytes);\n};\nexport const extractVp9CodecInfoFromPacket = (packet) => {\n    // eslint-disable-next-line @stylistic/max-len\n    // https://storage.googleapis.com/downloads.webmproject.org/docs/vp9/vp9-bitstream-specification-v0.7-20170222-draft.pdf\n    // http://downloads.webmproject.org/docs/vp9/vp9-bitstream_superframe-and-uncompressed-header_v1.0.pdf\n    const bitstream = new Bitstream(packet);\n    // Frame marker (0b10)\n    const frameMarker = bitstream.readBits(2);\n    if (frameMarker !== 2) {\n        return null;\n    }\n    // Profile\n    const profileLowBit = bitstream.readBits(1);\n    const profileHighBit = bitstream.readBits(1);\n    const profile = (profileHighBit << 1) + profileLowBit;\n    // Skip reserved bit for profile 3\n    if (profile === 3) {\n        bitstream.skipBits(1);\n    }\n    // show_existing_frame\n    const showExistingFrame = bitstream.readBits(1);\n    if (showExistingFrame === 1) {\n        return null;\n    }\n    // frame_type (0 = key frame)\n    const frameType = bitstream.readBits(1);\n    if (frameType !== 0) {\n        return null;\n    }\n    // Skip show_frame and error_resilient_mode\n    bitstream.skipBits(2);\n    // Sync code (0x498342)\n    const syncCode = bitstream.readBits(24);\n    if (syncCode !== 0x498342) {\n        return null;\n    }\n    // Color config\n    let bitDepth = 8;\n    if (profile >= 2) {\n        const tenOrTwelveBit = bitstream.readBits(1);\n        bitDepth = tenOrTwelveBit ? 12 : 10;\n    }\n    // Color space\n    const colorSpace = bitstream.readBits(3);\n    let chromaSubsampling = 0;\n    let videoFullRangeFlag = 0;\n    if (colorSpace !== 7) { // 7 is CS_RGB\n        const colorRange = bitstream.readBits(1);\n        videoFullRangeFlag = colorRange;\n        if (profile === 1 || profile === 3) {\n            const subsamplingX = bitstream.readBits(1);\n            const subsamplingY = bitstream.readBits(1);\n            // 0 = 4:2:0 vertical\n            // 1 = 4:2:0 colocated\n            // 2 = 4:2:2\n            // 3 = 4:4:4\n            chromaSubsampling = !subsamplingX && !subsamplingY\n                ? 3 // 0,0 = 4:4:4\n                : subsamplingX && !subsamplingY\n                    ? 2 // 1,0 = 4:2:2\n                    : 1; // 1,1 = 4:2:0 colocated (default)\n            // Skip reserved bit\n            bitstream.skipBits(1);\n        }\n        else {\n            // For profile 0 and 2, always 4:2:0\n            chromaSubsampling = 1; // Using colocated as default\n        }\n    }\n    else {\n        // RGB is always 4:4:4\n        chromaSubsampling = 3;\n        videoFullRangeFlag = 1;\n    }\n    // Parse frame size\n    const widthMinusOne = bitstream.readBits(16);\n    const heightMinusOne = bitstream.readBits(16);\n    const width = widthMinusOne + 1;\n    const height = heightMinusOne + 1;\n    // Calculate level based on dimensions\n    const pictureSize = width * height;\n    let level = last(VP9_LEVEL_TABLE).level; // Default to highest level\n    for (const entry of VP9_LEVEL_TABLE) {\n        if (pictureSize <= entry.maxPictureSize) {\n            level = entry.level;\n            break;\n        }\n    }\n    // Map color_space to standard values\n    const matrixCoefficients = colorSpace === 7\n        ? 0\n        : colorSpace === 2\n            ? 1\n            : colorSpace === 1\n                ? 6\n                : 2;\n    const colourPrimaries = colorSpace === 2\n        ? 1\n        : colorSpace === 1\n            ? 6\n            : 2;\n    const transferCharacteristics = colorSpace === 2\n        ? 1\n        : colorSpace === 1\n            ? 6\n            : 2;\n    return {\n        profile,\n        level,\n        bitDepth,\n        chromaSubsampling,\n        videoFullRangeFlag,\n        colourPrimaries,\n        transferCharacteristics,\n        matrixCoefficients,\n    };\n};\n/** Iterates over all OBUs in an AV1 packet bistream. */\nexport const iterateAv1PacketObus = function* (packet) {\n    // https://aomediacodec.github.io/av1-spec/av1-spec.pdf\n    const bitstream = new Bitstream(packet);\n    const readLeb128 = () => {\n        let value = 0;\n        for (let i = 0; i < 8; i++) {\n            const byte = bitstream.readAlignedByte();\n            value |= ((byte & 0x7f) << (i * 7));\n            if (!(byte & 0x80)) {\n                break;\n            }\n            // Spec requirement\n            if (i === 7 && (byte & 0x80)) {\n                return null;\n            }\n        }\n        // Spec requirement\n        if (value >= 2 ** 32 - 1) {\n            return null;\n        }\n        return value;\n    };\n    while (bitstream.getBitsLeft() >= 8) {\n        // Parse OBU header\n        bitstream.skipBits(1);\n        const obuType = bitstream.readBits(4);\n        const obuExtension = bitstream.readBits(1);\n        const obuHasSizeField = bitstream.readBits(1);\n        bitstream.skipBits(1);\n        // Skip extension header if present\n        if (obuExtension) {\n            bitstream.skipBits(8);\n        }\n        // Read OBU size if present\n        let obuSize;\n        if (obuHasSizeField) {\n            const obuSizeValue = readLeb128();\n            if (obuSizeValue === null)\n                return; // It was invalid\n            obuSize = obuSizeValue;\n        }\n        else {\n            // Calculate remaining bits and convert to bytes, rounding down\n            obuSize = Math.floor(bitstream.getBitsLeft() / 8);\n        }\n        assert(bitstream.pos % 8 === 0);\n        yield {\n            type: obuType,\n            data: packet.subarray(bitstream.pos / 8, bitstream.pos / 8 + obuSize),\n        };\n        // Move to next OBU\n        bitstream.skipBits(obuSize * 8);\n    }\n};\n/**\n * When AV1 codec information is not provided by the container, we can still try to extract the information by digging\n * into the AV1 bitstream.\n */\nexport const extractAv1CodecInfoFromPacket = (packet) => {\n    // https://aomediacodec.github.io/av1-spec/av1-spec.pdf\n    for (const { type, data } of iterateAv1PacketObus(packet)) {\n        if (type !== 1) {\n            continue; // 1 == OBU_SEQUENCE_HEADER\n        }\n        const bitstream = new Bitstream(data);\n        // Read sequence header fields\n        const seqProfile = bitstream.readBits(3);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const stillPicture = bitstream.readBits(1);\n        const reducedStillPictureHeader = bitstream.readBits(1);\n        let seqLevel = 0;\n        let seqTier = 0;\n        let bufferDelayLengthMinus1 = 0;\n        if (reducedStillPictureHeader) {\n            seqLevel = bitstream.readBits(5);\n        }\n        else {\n            // Parse timing_info_present_flag\n            const timingInfoPresentFlag = bitstream.readBits(1);\n            if (timingInfoPresentFlag) {\n                // Skip timing info (num_units_in_display_tick, time_scale, equal_picture_interval)\n                bitstream.skipBits(32); // num_units_in_display_tick\n                bitstream.skipBits(32); // time_scale\n                const equalPictureInterval = bitstream.readBits(1);\n                if (equalPictureInterval) {\n                    // Skip num_ticks_per_picture_minus_1 (uvlc)\n                    // Since this is variable length, we'd need to implement uvlc reading\n                    // For now, we'll return null as this is rare\n                    return null;\n                }\n            }\n            // Parse decoder_model_info_present_flag\n            const decoderModelInfoPresentFlag = bitstream.readBits(1);\n            if (decoderModelInfoPresentFlag) {\n                // Store buffer_delay_length_minus_1 instead of just skipping\n                bufferDelayLengthMinus1 = bitstream.readBits(5);\n                bitstream.skipBits(32); // num_units_in_decoding_tick\n                bitstream.skipBits(5); // buffer_removal_time_length_minus_1\n                bitstream.skipBits(5); // frame_presentation_time_length_minus_1\n            }\n            // Parse operating_points_cnt_minus_1\n            const operatingPointsCntMinus1 = bitstream.readBits(5);\n            // For each operating point\n            for (let i = 0; i <= operatingPointsCntMinus1; i++) {\n                // operating_point_idc[i]\n                bitstream.skipBits(12);\n                // seq_level_idx[i]\n                const seqLevelIdx = bitstream.readBits(5);\n                if (i === 0) {\n                    seqLevel = seqLevelIdx;\n                }\n                if (seqLevelIdx > 7) {\n                    // seq_tier[i]\n                    const seqTierTemp = bitstream.readBits(1);\n                    if (i === 0) {\n                        seqTier = seqTierTemp;\n                    }\n                }\n                if (decoderModelInfoPresentFlag) {\n                    // decoder_model_present_for_this_op[i]\n                    const decoderModelPresentForThisOp = bitstream.readBits(1);\n                    if (decoderModelPresentForThisOp) {\n                        const n = bufferDelayLengthMinus1 + 1;\n                        bitstream.skipBits(n); // decoder_buffer_delay[op]\n                        bitstream.skipBits(n); // encoder_buffer_delay[op]\n                        bitstream.skipBits(1); // low_delay_mode_flag[op]\n                    }\n                }\n                // initial_display_delay_present_flag\n                const initialDisplayDelayPresentFlag = bitstream.readBits(1);\n                if (initialDisplayDelayPresentFlag) {\n                    // initial_display_delay_minus_1[i]\n                    bitstream.skipBits(4);\n                }\n            }\n        }\n        // Frame size\n        const frameWidthBitsMinus1 = bitstream.readBits(4);\n        const frameHeightBitsMinus1 = bitstream.readBits(4);\n        const n1 = frameWidthBitsMinus1 + 1;\n        bitstream.skipBits(n1); // max_frame_width_minus_1\n        const n2 = frameHeightBitsMinus1 + 1;\n        bitstream.skipBits(n2); // max_frame_height_minus_1\n        // Frame IDs\n        let frameIdNumbersPresentFlag = 0;\n        if (reducedStillPictureHeader) {\n            frameIdNumbersPresentFlag = 0;\n        }\n        else {\n            frameIdNumbersPresentFlag = bitstream.readBits(1);\n        }\n        if (frameIdNumbersPresentFlag) {\n            bitstream.skipBits(4); // delta_frame_id_length_minus_2\n            bitstream.skipBits(3); // additional_frame_id_length_minus_1\n        }\n        bitstream.skipBits(1); // use_128x128_superblock\n        bitstream.skipBits(1); // enable_filter_intra\n        bitstream.skipBits(1); // enable_intra_edge_filter\n        if (!reducedStillPictureHeader) {\n            bitstream.skipBits(1); // enable_interintra_compound\n            bitstream.skipBits(1); // enable_masked_compound\n            bitstream.skipBits(1); // enable_warped_motion\n            bitstream.skipBits(1); // enable_dual_filter\n            const enableOrderHint = bitstream.readBits(1);\n            if (enableOrderHint) {\n                bitstream.skipBits(1); // enable_jnt_comp\n                bitstream.skipBits(1); // enable_ref_frame_mvs\n            }\n            const seqChooseScreenContentTools = bitstream.readBits(1);\n            let seqForceScreenContentTools = 0;\n            if (seqChooseScreenContentTools) {\n                seqForceScreenContentTools = 2; // SELECT_SCREEN_CONTENT_TOOLS\n            }\n            else {\n                seqForceScreenContentTools = bitstream.readBits(1);\n            }\n            if (seqForceScreenContentTools > 0) {\n                const seqChooseIntegerMv = bitstream.readBits(1);\n                if (!seqChooseIntegerMv) {\n                    bitstream.skipBits(1); // seq_force_integer_mv\n                }\n            }\n            if (enableOrderHint) {\n                bitstream.skipBits(3); // order_hint_bits_minus_1\n            }\n        }\n        bitstream.skipBits(1); // enable_superres\n        bitstream.skipBits(1); // enable_cdef\n        bitstream.skipBits(1); // enable_restoration\n        // color_config()\n        const highBitdepth = bitstream.readBits(1);\n        let bitDepth = 8;\n        if (seqProfile === 2 && highBitdepth) {\n            const twelveBit = bitstream.readBits(1);\n            bitDepth = twelveBit ? 12 : 10;\n        }\n        else if (seqProfile <= 2) {\n            bitDepth = highBitdepth ? 10 : 8;\n        }\n        let monochrome = 0;\n        if (seqProfile !== 1) {\n            monochrome = bitstream.readBits(1);\n        }\n        let chromaSubsamplingX = 1;\n        let chromaSubsamplingY = 1;\n        let chromaSamplePosition = 0;\n        if (!monochrome) {\n            if (seqProfile === 0) {\n                chromaSubsamplingX = 1;\n                chromaSubsamplingY = 1;\n            }\n            else if (seqProfile === 1) {\n                chromaSubsamplingX = 0;\n                chromaSubsamplingY = 0;\n            }\n            else {\n                if (bitDepth === 12) {\n                    chromaSubsamplingX = bitstream.readBits(1);\n                    if (chromaSubsamplingX) {\n                        chromaSubsamplingY = bitstream.readBits(1);\n                    }\n                }\n            }\n            if (chromaSubsamplingX && chromaSubsamplingY) {\n                chromaSamplePosition = bitstream.readBits(2);\n            }\n        }\n        return {\n            profile: seqProfile,\n            level: seqLevel,\n            tier: seqTier,\n            bitDepth,\n            monochrome,\n            chromaSubsamplingX,\n            chromaSubsamplingY,\n            chromaSamplePosition,\n        };\n    }\n    return null;\n};\nexport const parseOpusIdentificationHeader = (bytes) => {\n    const view = toDataView(bytes);\n    const outputChannelCount = view.getUint8(9);\n    const preSkip = view.getUint16(10, true);\n    const inputSampleRate = view.getUint32(12, true);\n    const outputGain = view.getInt16(16, true);\n    const channelMappingFamily = view.getUint8(18);\n    let channelMappingTable = null;\n    if (channelMappingFamily) {\n        channelMappingTable = bytes.subarray(19, 19 + 2 + outputChannelCount);\n    }\n    return {\n        outputChannelCount,\n        preSkip,\n        inputSampleRate,\n        outputGain,\n        channelMappingFamily,\n        channelMappingTable,\n    };\n};\n// From https://datatracker.ietf.org/doc/html/rfc6716, in 48 kHz samples\nconst OPUS_FRAME_DURATION_TABLE = [\n    480, 960, 1920, 2880,\n    480, 960, 1920, 2880,\n    480, 960, 1920, 2880,\n    480, 960,\n    480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n];\nexport const parseOpusTocByte = (packet) => {\n    const config = packet[0] >> 3;\n    return {\n        durationInSamples: OPUS_FRAME_DURATION_TABLE[config],\n    };\n};\n// Based on vorbis_parser.c from FFmpeg.\nexport const parseModesFromVorbisSetupPacket = (setupHeader) => {\n    // Verify that this is a Setup header.\n    if (setupHeader.length < 7) {\n        throw new Error('Setup header is too short.');\n    }\n    if (setupHeader[0] !== 5) {\n        throw new Error('Wrong packet type in Setup header.');\n    }\n    const signature = String.fromCharCode(...setupHeader.slice(1, 7));\n    if (signature !== 'vorbis') {\n        throw new Error('Invalid packet signature in Setup header.');\n    }\n    // Reverse the entire buffer.\n    const bufSize = setupHeader.length;\n    const revBuffer = new Uint8Array(bufSize);\n    for (let i = 0; i < bufSize; i++) {\n        revBuffer[i] = setupHeader[bufSize - 1 - i];\n    }\n    // Initialize a Bitstream on the reversed buffer.\n    const bitstream = new Bitstream(revBuffer);\n    // --- Find the framing bit.\n    // In FFmpeg code, we scan until get_bits1() returns 1.\n    let gotFramingBit = 0;\n    while (bitstream.getBitsLeft() > 97) {\n        if (bitstream.readBits(1) === 1) {\n            gotFramingBit = bitstream.pos;\n            break;\n        }\n    }\n    if (gotFramingBit === 0) {\n        throw new Error('Invalid Setup header: framing bit not found.');\n    }\n    // --- Search backwards for a valid mode header.\n    // We try to guess the number of modes by reading a fixed pattern.\n    let modeCount = 0;\n    let gotModeHeader = false;\n    let lastModeCount = 0;\n    while (bitstream.getBitsLeft() >= 97) {\n        const tempPos = bitstream.pos;\n        const a = bitstream.readBits(8);\n        const b = bitstream.readBits(16);\n        const c = bitstream.readBits(16);\n        // If a > 63 or b or c nonzero, assume weve gone too far.\n        if (a > 63 || b !== 0 || c !== 0) {\n            bitstream.pos = tempPos;\n            break;\n        }\n        bitstream.skipBits(1);\n        modeCount++;\n        if (modeCount > 64) {\n            break;\n        }\n        const bsClone = bitstream.clone();\n        const candidate = bsClone.readBits(6) + 1;\n        if (candidate === modeCount) {\n            gotModeHeader = true;\n            lastModeCount = modeCount;\n        }\n    }\n    if (!gotModeHeader) {\n        throw new Error('Invalid Setup header: mode header not found.');\n    }\n    if (lastModeCount > 63) {\n        throw new Error(`Unsupported mode count: ${lastModeCount}.`);\n    }\n    const finalModeCount = lastModeCount;\n    // --- Reinitialize the bitstream.\n    bitstream.pos = 0;\n    // Skip the bits up to the found framing bit.\n    bitstream.skipBits(gotFramingBit);\n    // --- Now read, for each mode (in reverse order), 40 bits then one bit.\n    // That one bit is the mode blockflag.\n    const modeBlockflags = Array(finalModeCount).fill(0);\n    for (let i = finalModeCount - 1; i >= 0; i--) {\n        bitstream.skipBits(40);\n        modeBlockflags[i] = bitstream.readBits(1);\n    }\n    return { modeBlockflags };\n};\n/** Determines a packet's type (key or delta) by digging into the packet bitstream. */\nexport const determineVideoPacketType = (codec, decoderConfig, packetData) => {\n    switch (codec) {\n        case 'avc':\n            {\n                const nalUnits = extractAvcNalUnits(packetData, decoderConfig);\n                let isKeyframe = nalUnits.some(x => extractNalUnitTypeForAvc(x) === AvcNalUnitType.IDR);\n                if (!isKeyframe && (!isChromium() || getChromiumVersion() >= 144)) {\n                    // In addition to IDR, Recovery Point SEI also counts as a valid H.264 keyframe by current consensus.\n                    // See https://github.com/w3c/webcodecs/issues/650 for the relevant discussion. WebKit and Firefox have\n                    // always supported them, but Chromium hasn't, therefore the (admittedly dirty) version check.\n                    for (const nalUnit of nalUnits) {\n                        const type = extractNalUnitTypeForAvc(nalUnit);\n                        if (type !== AvcNalUnitType.SEI) {\n                            continue;\n                        }\n                        const bytes = removeEmulationPreventionBytes(nalUnit);\n                        let pos = 1; // Skip NALU header\n                        // sei_rbsp()\n                        do {\n                            // sei_message()\n                            let payloadType = 0;\n                            while (true) {\n                                const nextByte = bytes[pos++];\n                                if (nextByte === undefined)\n                                    break;\n                                payloadType += nextByte;\n                                if (nextByte < 255) {\n                                    break;\n                                }\n                            }\n                            let payloadSize = 0;\n                            while (true) {\n                                const nextByte = bytes[pos++];\n                                if (nextByte === undefined)\n                                    break;\n                                payloadSize += nextByte;\n                                if (nextByte < 255) {\n                                    break;\n                                }\n                            }\n                            // sei_payload()\n                            const PAYLOAD_TYPE_RECOVERY_POINT = 6;\n                            if (payloadType === PAYLOAD_TYPE_RECOVERY_POINT) {\n                                const bitstream = new Bitstream(bytes);\n                                bitstream.pos = 8 * pos;\n                                const recoveryFrameCount = readExpGolomb(bitstream);\n                                const exactMatchFlag = bitstream.readBits(1);\n                                if (recoveryFrameCount === 0 && exactMatchFlag === 1) {\n                                    // https://github.com/w3c/webcodecs/pull/910\n                                    // \"recovery_frame_cnt == 0 and exact_match_flag=1 in the SEI recovery payload\"\n                                    isKeyframe = true;\n                                    break;\n                                }\n                            }\n                            pos += payloadSize;\n                        } while (pos < bytes.length - 1);\n                    }\n                }\n                return isKeyframe ? 'key' : 'delta';\n            }\n            ;\n        case 'hevc':\n            {\n                const nalUnits = extractHevcNalUnits(packetData, decoderConfig);\n                const isKeyframe = nalUnits.some((x) => {\n                    const type = extractNalUnitTypeForHevc(x);\n                    return HevcNalUnitType.BLA_W_LP <= type && type <= HevcNalUnitType.RSV_IRAP_VCL23;\n                });\n                return isKeyframe ? 'key' : 'delta';\n            }\n            ;\n        case 'vp8':\n            {\n                // VP8, once again, by far the easiest to deal with.\n                const frameType = packetData[0] & 0b1;\n                return frameType === 0 ? 'key' : 'delta';\n            }\n            ;\n        case 'vp9':\n            {\n                const bitstream = new Bitstream(packetData);\n                if (bitstream.readBits(2) !== 2) {\n                    return null;\n                }\n                ;\n                const profileLowBit = bitstream.readBits(1);\n                const profileHighBit = bitstream.readBits(1);\n                const profile = (profileHighBit << 1) + profileLowBit;\n                // Skip reserved bit for profile 3\n                if (profile === 3) {\n                    bitstream.skipBits(1);\n                }\n                const showExistingFrame = bitstream.readBits(1);\n                if (showExistingFrame) {\n                    return null;\n                }\n                const frameType = bitstream.readBits(1);\n                return frameType === 0 ? 'key' : 'delta';\n            }\n            ;\n        case 'av1':\n            {\n                let reducedStillPictureHeader = false;\n                for (const { type, data } of iterateAv1PacketObus(packetData)) {\n                    if (type === 1) { // OBU_SEQUENCE_HEADER\n                        const bitstream = new Bitstream(data);\n                        bitstream.skipBits(4);\n                        reducedStillPictureHeader = !!bitstream.readBits(1);\n                    }\n                    else if (type === 3 // OBU_FRAME_HEADER\n                        || type === 6 // OBU_FRAME\n                        || type === 7 // OBU_REDUNDANT_FRAME_HEADER\n                    ) {\n                        if (reducedStillPictureHeader) {\n                            return 'key';\n                        }\n                        const bitstream = new Bitstream(data);\n                        const showExistingFrame = bitstream.readBits(1);\n                        if (showExistingFrame) {\n                            return null;\n                        }\n                        const frameType = bitstream.readBits(2);\n                        return frameType === 0 ? 'key' : 'delta';\n                    }\n                }\n                return null;\n            }\n            ;\n        default:\n            {\n                assertNever(codec);\n                assert(false);\n            }\n            ;\n    }\n};\nexport var FlacBlockType;\n(function (FlacBlockType) {\n    FlacBlockType[FlacBlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\n    FlacBlockType[FlacBlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\n    FlacBlockType[FlacBlockType[\"PICTURE\"] = 6] = \"PICTURE\";\n})(FlacBlockType || (FlacBlockType = {}));\nexport const readVorbisComments = (bytes, metadataTags) => {\n    // https://datatracker.ietf.org/doc/html/rfc7845#section-5.2\n    const commentView = toDataView(bytes);\n    let commentPos = 0;\n    const vendorStringLength = commentView.getUint32(commentPos, true);\n    commentPos += 4;\n    const vendorString = textDecoder.decode(bytes.subarray(commentPos, commentPos + vendorStringLength));\n    commentPos += vendorStringLength;\n    if (vendorStringLength > 0) {\n        // Expose the vendor string in the raw metadata\n        metadataTags.raw ??= {};\n        metadataTags.raw['vendor'] ??= vendorString;\n    }\n    const listLength = commentView.getUint32(commentPos, true);\n    commentPos += 4;\n    // Loop over all metadata tags\n    for (let i = 0; i < listLength; i++) {\n        const stringLength = commentView.getUint32(commentPos, true);\n        commentPos += 4;\n        const string = textDecoder.decode(bytes.subarray(commentPos, commentPos + stringLength));\n        commentPos += stringLength;\n        const separatorIndex = string.indexOf('=');\n        if (separatorIndex === -1) {\n            continue;\n        }\n        const key = string.slice(0, separatorIndex).toUpperCase();\n        const value = string.slice(separatorIndex + 1);\n        metadataTags.raw ??= {};\n        metadataTags.raw[key] ??= value;\n        switch (key) {\n            case 'TITLE':\n                {\n                    metadataTags.title ??= value;\n                }\n                ;\n                break;\n            case 'DESCRIPTION':\n                {\n                    metadataTags.description ??= value;\n                }\n                ;\n                break;\n            case 'ARTIST':\n                {\n                    metadataTags.artist ??= value;\n                }\n                ;\n                break;\n            case 'ALBUM':\n                {\n                    metadataTags.album ??= value;\n                }\n                ;\n                break;\n            case 'ALBUMARTIST':\n                {\n                    metadataTags.albumArtist ??= value;\n                }\n                ;\n                break;\n            case 'COMMENT':\n                {\n                    metadataTags.comment ??= value;\n                }\n                ;\n                break;\n            case 'LYRICS':\n                {\n                    metadataTags.lyrics ??= value;\n                }\n                ;\n                break;\n            case 'TRACKNUMBER':\n                {\n                    const parts = value.split('/');\n                    const trackNum = Number.parseInt(parts[0], 10);\n                    const tracksTotal = parts[1] && Number.parseInt(parts[1], 10);\n                    if (Number.isInteger(trackNum) && trackNum > 0) {\n                        metadataTags.trackNumber ??= trackNum;\n                    }\n                    if (tracksTotal && Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                        metadataTags.tracksTotal ??= tracksTotal;\n                    }\n                }\n                ;\n                break;\n            case 'TRACKTOTAL':\n                {\n                    const tracksTotal = Number.parseInt(value, 10);\n                    if (Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                        metadataTags.tracksTotal ??= tracksTotal;\n                    }\n                }\n                ;\n                break;\n            case 'DISCNUMBER':\n                {\n                    const parts = value.split('/');\n                    const discNum = Number.parseInt(parts[0], 10);\n                    const discsTotal = parts[1] && Number.parseInt(parts[1], 10);\n                    if (Number.isInteger(discNum) && discNum > 0) {\n                        metadataTags.discNumber ??= discNum;\n                    }\n                    if (discsTotal && Number.isInteger(discsTotal) && discsTotal > 0) {\n                        metadataTags.discsTotal ??= discsTotal;\n                    }\n                }\n                ;\n                break;\n            case 'DISCTOTAL':\n                {\n                    const discsTotal = Number.parseInt(value, 10);\n                    if (Number.isInteger(discsTotal) && discsTotal > 0) {\n                        metadataTags.discsTotal ??= discsTotal;\n                    }\n                }\n                ;\n                break;\n            case 'DATE':\n                {\n                    const date = new Date(value);\n                    if (!Number.isNaN(date.getTime())) {\n                        metadataTags.date ??= date;\n                    }\n                }\n                ;\n                break;\n            case 'GENRE':\n                {\n                    metadataTags.genre ??= value;\n                }\n                ;\n                break;\n            case 'METADATA_BLOCK_PICTURE':\n                {\n                    // https://datatracker.ietf.org/doc/rfc9639/ Section 8.8\n                    const decoded = base64ToBytes(value);\n                    const view = toDataView(decoded);\n                    const pictureType = view.getUint32(0, false);\n                    const mediaTypeLength = view.getUint32(4, false);\n                    const mediaType = String.fromCharCode(...decoded.subarray(8, 8 + mediaTypeLength)); // ASCII\n                    const descriptionLength = view.getUint32(8 + mediaTypeLength, false);\n                    const description = textDecoder.decode(decoded.subarray(12 + mediaTypeLength, 12 + mediaTypeLength + descriptionLength));\n                    const dataLength = view.getUint32(mediaTypeLength + descriptionLength + 28);\n                    const data = decoded.subarray(mediaTypeLength + descriptionLength + 32, mediaTypeLength + descriptionLength + 32 + dataLength);\n                    metadataTags.images ??= [];\n                    metadataTags.images.push({\n                        data,\n                        mimeType: mediaType,\n                        kind: pictureType === 3 ? 'coverFront' : pictureType === 4 ? 'coverBack' : 'unknown',\n                        name: undefined,\n                        description: description || undefined,\n                    });\n                }\n                ;\n                break;\n        }\n    }\n};\nexport const createVorbisComments = (headerBytes, tags, writeImages) => {\n    // https://datatracker.ietf.org/doc/html/rfc7845#section-5.2\n    const commentHeaderParts = [\n        headerBytes,\n    ];\n    const vendorString = 'Mediabunny';\n    const encodedVendorString = textEncoder.encode(vendorString);\n    let currentBuffer = new Uint8Array(4 + encodedVendorString.length);\n    let currentView = new DataView(currentBuffer.buffer);\n    currentView.setUint32(0, encodedVendorString.length, true);\n    currentBuffer.set(encodedVendorString, 4);\n    commentHeaderParts.push(currentBuffer);\n    const writtenTags = new Set();\n    const addCommentTag = (key, value) => {\n        const joined = `${key}=${value}`;\n        const encoded = textEncoder.encode(joined);\n        currentBuffer = new Uint8Array(4 + encoded.length);\n        currentView = new DataView(currentBuffer.buffer);\n        currentView.setUint32(0, encoded.length, true);\n        currentBuffer.set(encoded, 4);\n        commentHeaderParts.push(currentBuffer);\n        writtenTags.add(key);\n    };\n    for (const { key, value } of keyValueIterator(tags)) {\n        switch (key) {\n            case 'title':\n                {\n                    addCommentTag('TITLE', value);\n                }\n                ;\n                break;\n            case 'description':\n                {\n                    addCommentTag('DESCRIPTION', value);\n                }\n                ;\n                break;\n            case 'artist':\n                {\n                    addCommentTag('ARTIST', value);\n                }\n                ;\n                break;\n            case 'album':\n                {\n                    addCommentTag('ALBUM', value);\n                }\n                ;\n                break;\n            case 'albumArtist':\n                {\n                    addCommentTag('ALBUMARTIST', value);\n                }\n                ;\n                break;\n            case 'genre':\n                {\n                    addCommentTag('GENRE', value);\n                }\n                ;\n                break;\n            case 'date':\n                {\n                    const rawVersion = tags.raw?.['DATE'] ?? tags.raw?.['date'];\n                    if (rawVersion && typeof rawVersion === 'string') {\n                        addCommentTag('DATE', rawVersion);\n                    }\n                    else {\n                        addCommentTag('DATE', value.toISOString().slice(0, 10));\n                    }\n                }\n                ;\n                break;\n            case 'comment':\n                {\n                    addCommentTag('COMMENT', value);\n                }\n                ;\n                break;\n            case 'lyrics':\n                {\n                    addCommentTag('LYRICS', value);\n                }\n                ;\n                break;\n            case 'trackNumber':\n                {\n                    addCommentTag('TRACKNUMBER', value.toString());\n                }\n                ;\n                break;\n            case 'tracksTotal':\n                {\n                    addCommentTag('TRACKTOTAL', value.toString());\n                }\n                ;\n                break;\n            case 'discNumber':\n                {\n                    addCommentTag('DISCNUMBER', value.toString());\n                }\n                ;\n                break;\n            case 'discsTotal':\n                {\n                    addCommentTag('DISCTOTAL', value.toString());\n                }\n                ;\n                break;\n            case 'images':\n                {\n                    // For example, in .flac, we put the pictures in a different section,\n                    // not in the Vorbis comment header.\n                    if (!writeImages) {\n                        break;\n                    }\n                    for (const image of value) {\n                        // https://datatracker.ietf.org/doc/rfc9639/ Section 8.8\n                        const pictureType = image.kind === 'coverFront' ? 3 : image.kind === 'coverBack' ? 4 : 0;\n                        const encodedMediaType = new Uint8Array(image.mimeType.length);\n                        for (let i = 0; i < image.mimeType.length; i++) {\n                            encodedMediaType[i] = image.mimeType.charCodeAt(i);\n                        }\n                        const encodedDescription = textEncoder.encode(image.description ?? '');\n                        const buffer = new Uint8Array(4 // Picture type\n                            + 4 // MIME type length\n                            + encodedMediaType.length // MIME type\n                            + 4 // Description length\n                            + encodedDescription.length // Description\n                            + 16 // Width, height, color depth, number of colors\n                            + 4 // Picture data length\n                            + image.data.length);\n                        const view = toDataView(buffer);\n                        view.setUint32(0, pictureType, false);\n                        view.setUint32(4, encodedMediaType.length, false);\n                        buffer.set(encodedMediaType, 8);\n                        view.setUint32(8 + encodedMediaType.length, encodedDescription.length, false);\n                        buffer.set(encodedDescription, 12 + encodedMediaType.length);\n                        // Skip a bunch of fields (width, height, color depth, number of colors)\n                        view.setUint32(28 + encodedMediaType.length + encodedDescription.length, image.data.length, false);\n                        buffer.set(image.data, 32 + encodedMediaType.length + encodedDescription.length);\n                        const encoded = bytesToBase64(buffer);\n                        addCommentTag('METADATA_BLOCK_PICTURE', encoded);\n                    }\n                }\n                ;\n                break;\n            case 'raw':\n                {\n                    // Handled later\n                }\n                ;\n                break;\n            default: assertNever(key);\n        }\n    }\n    if (tags.raw) {\n        for (const key in tags.raw) {\n            const value = tags.raw[key] ?? tags.raw[key.toLowerCase()];\n            if (key === 'vendor' || value == null || writtenTags.has(key)) {\n                continue;\n            }\n            if (typeof value === 'string') {\n                addCommentTag(key, value);\n            }\n        }\n    }\n    const listLengthBuffer = new Uint8Array(4);\n    toDataView(listLengthBuffer).setUint32(0, writtenTags.size, true);\n    commentHeaderParts.splice(2, 0, listLengthBuffer); // Insert after the header and vendor section\n    // Merge all comment header parts into a single buffer\n    const commentHeaderLength = commentHeaderParts.reduce((a, b) => a + b.length, 0);\n    const commentHeader = new Uint8Array(commentHeaderLength);\n    let pos = 0;\n    for (const part of commentHeaderParts) {\n        commentHeader.set(part, pos);\n        pos += part.length;\n    }\n    return commentHeader;\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport class Demuxer {\n    constructor(input) {\n        this.input = input;\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/**\n * Base class for custom video decoders. To add your own custom video decoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the decoder using {@link registerDecoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomVideoDecoder {\n    /** Returns true if and only if the decoder can decode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom audio decoders. To add your own custom audio decoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the decoder using {@link registerDecoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomAudioDecoder {\n    /** Returns true if and only if the decoder can decode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom video encoders. To add your own custom video encoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the encoder using {@link registerEncoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomVideoEncoder {\n    /** Returns true if and only if the encoder can encode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom audio encoders. To add your own custom audio encoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the encoder using {@link registerEncoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomAudioEncoder {\n    /** Returns true if and only if the encoder can encode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\nexport const customVideoDecoders = [];\nexport const customAudioDecoders = [];\nexport const customVideoEncoders = [];\nexport const customAudioEncoders = [];\n/**\n * Registers a custom video or audio decoder. Registered decoders will automatically be used for decoding whenever\n * possible.\n * @group Custom coders\n * @public\n */\nexport const registerDecoder = (decoder) => {\n    if (decoder.prototype instanceof CustomVideoDecoder) {\n        const casted = decoder;\n        if (customVideoDecoders.includes(casted)) {\n            console.warn('Video decoder already registered.');\n            return;\n        }\n        customVideoDecoders.push(casted);\n    }\n    else if (decoder.prototype instanceof CustomAudioDecoder) {\n        const casted = decoder;\n        if (customAudioDecoders.includes(casted)) {\n            console.warn('Audio decoder already registered.');\n            return;\n        }\n        customAudioDecoders.push(casted);\n    }\n    else {\n        throw new TypeError('Decoder must be a CustomVideoDecoder or CustomAudioDecoder.');\n    }\n};\n/**\n * Registers a custom video or audio encoder. Registered encoders will automatically be used for encoding whenever\n * possible.\n * @group Custom coders\n * @public\n */\nexport const registerEncoder = (encoder) => {\n    if (encoder.prototype instanceof CustomVideoEncoder) {\n        const casted = encoder;\n        if (customVideoEncoders.includes(casted)) {\n            console.warn('Video encoder already registered.');\n            return;\n        }\n        customVideoEncoders.push(casted);\n    }\n    else if (encoder.prototype instanceof CustomAudioEncoder) {\n        const casted = encoder;\n        if (customAudioEncoders.includes(casted)) {\n            console.warn('Audio encoder already registered.');\n            return;\n        }\n        customAudioEncoders.push(casted);\n    }\n    else {\n        throw new TypeError('Encoder must be a CustomVideoEncoder or CustomAudioEncoder.');\n    }\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { SECOND_TO_MICROSECOND_FACTOR } from './misc.js';\nexport const PLACEHOLDER_DATA = /* #__PURE__ */ new Uint8Array(0);\n/**\n * Represents an encoded chunk of media. Mainly used as an expressive wrapper around WebCodecs API's\n * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) and\n * [`EncodedAudioChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedAudioChunk), but can also be used\n * standalone.\n * @group Packets\n * @public\n */\nexport class EncodedPacket {\n    /** Creates a new {@link EncodedPacket} from raw bytes and timing information. */\n    constructor(\n    /** The encoded data of this packet. */\n    data, \n    /** The type of this packet. */\n    type, \n    /**\n     * The presentation timestamp of this packet in seconds. May be negative. Samples with negative end timestamps\n     * should not be presented.\n     */\n    timestamp, \n    /** The duration of this packet in seconds. */\n    duration, \n    /**\n     * The sequence number indicates the decode order of the packets. Packet A  must be decoded before packet B if A\n     * has a lower sequence number than B. If two packets have the same sequence number, they are the same packet.\n     * Otherwise, sequence numbers are arbitrary and are not guaranteed to have any meaning besides their relative\n     * ordering. Negative sequence numbers mean the sequence number is undefined.\n     */\n    sequenceNumber = -1, byteLength, sideData) {\n        this.data = data;\n        this.type = type;\n        this.timestamp = timestamp;\n        this.duration = duration;\n        this.sequenceNumber = sequenceNumber;\n        if (data === PLACEHOLDER_DATA && byteLength === undefined) {\n            throw new Error('Internal error: byteLength must be explicitly provided when constructing metadata-only packets.');\n        }\n        if (byteLength === undefined) {\n            byteLength = data.byteLength;\n        }\n        if (!(data instanceof Uint8Array)) {\n            throw new TypeError('data must be a Uint8Array.');\n        }\n        if (type !== 'key' && type !== 'delta') {\n            throw new TypeError('type must be either \"key\" or \"delta\".');\n        }\n        if (!Number.isFinite(timestamp)) {\n            throw new TypeError('timestamp must be a number.');\n        }\n        if (!Number.isFinite(duration) || duration < 0) {\n            throw new TypeError('duration must be a non-negative number.');\n        }\n        if (!Number.isFinite(sequenceNumber)) {\n            throw new TypeError('sequenceNumber must be a number.');\n        }\n        if (!Number.isInteger(byteLength) || byteLength < 0) {\n            throw new TypeError('byteLength must be a non-negative integer.');\n        }\n        if (sideData !== undefined && (typeof sideData !== 'object' || !sideData)) {\n            throw new TypeError('sideData, when provided, must be an object.');\n        }\n        if (sideData?.alpha !== undefined && !(sideData.alpha instanceof Uint8Array)) {\n            throw new TypeError('sideData.alpha, when provided, must be a Uint8Array.');\n        }\n        if (sideData?.alphaByteLength !== undefined\n            && (!Number.isInteger(sideData.alphaByteLength) || sideData.alphaByteLength < 0)) {\n            throw new TypeError('sideData.alphaByteLength, when provided, must be a non-negative integer.');\n        }\n        this.byteLength = byteLength;\n        this.sideData = sideData ?? {};\n        if (this.sideData.alpha && this.sideData.alphaByteLength === undefined) {\n            this.sideData.alphaByteLength = this.sideData.alpha.byteLength;\n        }\n    }\n    /**\n     * If this packet is a metadata-only packet. Metadata-only packets don't contain their packet data. They are the\n     * result of retrieving packets with {@link PacketRetrievalOptions.metadataOnly} set to `true`.\n     */\n    get isMetadataOnly() {\n        return this.data === PLACEHOLDER_DATA;\n    }\n    /** The timestamp of this packet in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of this packet in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    /** Converts this packet to an\n     * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) for use with the\n     * WebCodecs API. */\n    toEncodedVideoChunk() {\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to a video chunk.');\n        }\n        if (typeof EncodedVideoChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedVideoChunk.');\n        }\n        return new EncodedVideoChunk({\n            data: this.data,\n            type: this.type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /**\n     * Converts this packet to an\n     * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) for use with the\n     * WebCodecs API, using the alpha side data instead of the color data. Throws if no alpha side data is defined.\n     */\n    alphaToEncodedVideoChunk(type = this.type) {\n        if (!this.sideData.alpha) {\n            throw new TypeError('This packet does not contain alpha side data.');\n        }\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to a video chunk.');\n        }\n        if (typeof EncodedVideoChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedVideoChunk.');\n        }\n        return new EncodedVideoChunk({\n            data: this.sideData.alpha,\n            type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /** Converts this packet to an\n     * [`EncodedAudioChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedAudioChunk) for use with the\n     * WebCodecs API. */\n    toEncodedAudioChunk() {\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to an audio chunk.');\n        }\n        if (typeof EncodedAudioChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedAudioChunk.');\n        }\n        return new EncodedAudioChunk({\n            data: this.data,\n            type: this.type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /**\n     * Creates an {@link EncodedPacket} from an\n     * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) or\n     * [`EncodedAudioChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedAudioChunk). This method is useful\n     * for converting chunks from the WebCodecs API to `EncodedPacket` instances.\n     */\n    static fromEncodedChunk(chunk, sideData) {\n        if (!(chunk instanceof EncodedVideoChunk || chunk instanceof EncodedAudioChunk)) {\n            throw new TypeError('chunk must be an EncodedVideoChunk or EncodedAudioChunk.');\n        }\n        const data = new Uint8Array(chunk.byteLength);\n        chunk.copyTo(data);\n        return new EncodedPacket(data, chunk.type, chunk.timestamp / 1e6, (chunk.duration ?? 0) / 1e6, undefined, undefined, sideData);\n    }\n    /** Clones this packet while optionally updating timing information. */\n    clone(options) {\n        if (options !== undefined && (typeof options !== 'object' || options === null)) {\n            throw new TypeError('options, when provided, must be an object.');\n        }\n        if (options?.timestamp !== undefined && !Number.isFinite(options.timestamp)) {\n            throw new TypeError('options.timestamp, when provided, must be a number.');\n        }\n        if (options?.duration !== undefined && !Number.isFinite(options.duration)) {\n            throw new TypeError('options.duration, when provided, must be a number.');\n        }\n        return new EncodedPacket(this.data, this.type, options?.timestamp ?? this.timestamp, options?.duration ?? this.duration, this.sequenceNumber, this.byteLength);\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n// https://github.com/dystopiancode/pcm-g711/blob/master/pcm-g711/g711.c\nexport const toUlaw = (s16) => {\n    const MULAW_MAX = 0x1FFF;\n    const MULAW_BIAS = 33;\n    let number = s16;\n    let mask = 0x1000;\n    let sign = 0;\n    let position = 12;\n    let lsb = 0;\n    if (number < 0) {\n        number = -number;\n        sign = 0x80;\n    }\n    number += MULAW_BIAS;\n    if (number > MULAW_MAX) {\n        number = MULAW_MAX;\n    }\n    while ((number & mask) !== mask && position >= 5) {\n        mask >>= 1;\n        position--;\n    }\n    lsb = (number >> (position - 4)) & 0x0f;\n    return ~(sign | ((position - 5) << 4) | lsb) & 0xFF;\n};\nexport const fromUlaw = (u8) => {\n    const MULAW_BIAS = 33;\n    let sign = 0;\n    let position = 0;\n    let number = ~u8;\n    if (number & 0x80) {\n        number &= ~(1 << 7);\n        sign = -1;\n    }\n    position = ((number & 0xF0) >> 4) + 5;\n    const decoded = ((1 << position) | ((number & 0x0F) << (position - 4))\n        | (1 << (position - 5))) - MULAW_BIAS;\n    return (sign === 0) ? decoded : -decoded;\n};\nexport const toAlaw = (s16) => {\n    const ALAW_MAX = 0xFFF;\n    let mask = 0x800;\n    let sign = 0;\n    let position = 11;\n    let lsb = 0;\n    let number = s16;\n    if (number < 0) {\n        number = -number;\n        sign = 0x80;\n    }\n    if (number > ALAW_MAX) {\n        number = ALAW_MAX;\n    }\n    while ((number & mask) !== mask && position >= 5) {\n        mask >>= 1;\n        position--;\n    }\n    lsb = (number >> ((position === 4) ? 1 : (position - 4))) & 0x0f;\n    return (sign | ((position - 4) << 4) | lsb) ^ 0x55;\n};\nexport const fromAlaw = (u8) => {\n    let sign = 0x00;\n    let position = 0;\n    let number = u8 ^ 0x55;\n    if (number & 0x80) {\n        number &= ~(1 << 7);\n        sign = -1;\n    }\n    position = ((number & 0xF0) >> 4) + 4;\n    let decoded = 0;\n    if (position !== 4) {\n        decoded = ((1 << position) | ((number & 0x0F) << (position - 4))\n            | (1 << (position - 5)));\n    }\n    else {\n        decoded = (number << 1) | 1;\n    }\n    return (sign === 0) ? decoded : -decoded;\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert, clamp, isAllowSharedBufferSource, SECOND_TO_MICROSECOND_FACTOR, toDataView, toUint8Array, isFirefox, polyfillSymbolDispose, assertNever, isWebKit, } from './misc.js';\npolyfillSymbolDispose();\n// Let's manually handle logging the garbage collection errors that are typically logged by the browser. This way, they\n// also kick for audio samples (which is normally not the case), making sure any incorrect code is quickly caught.\nlet lastVideoGcErrorLog = -Infinity;\nlet lastAudioGcErrorLog = -Infinity;\nlet finalizationRegistry = null;\nif (typeof FinalizationRegistry !== 'undefined') {\n    finalizationRegistry = new FinalizationRegistry((value) => {\n        const now = Date.now();\n        if (value.type === 'video') {\n            if (now - lastVideoGcErrorLog >= 1000) {\n                // This error is annoying but oh so important\n                console.error(`A VideoSample was garbage collected without first being closed. For proper resource management,`\n                    + ` make sure to call close() on all your VideoSamples as soon as you're done using them.`);\n                lastVideoGcErrorLog = now;\n            }\n            if (typeof VideoFrame !== 'undefined' && value.data instanceof VideoFrame) {\n                value.data.close(); // Prevent the browser error since we're logging our own\n            }\n        }\n        else {\n            if (now - lastAudioGcErrorLog >= 1000) {\n                console.error(`An AudioSample was garbage collected without first being closed. For proper resource management,`\n                    + ` make sure to call close() on all your AudioSamples as soon as you're done using them.`);\n                lastAudioGcErrorLog = now;\n            }\n            if (typeof AudioData !== 'undefined' && value.data instanceof AudioData) {\n                value.data.close();\n            }\n        }\n    });\n}\n/**\n * The list of {@link VideoSample} pixel formats.\n * @group Samples\n * @public\n */\nexport const VIDEO_SAMPLE_PIXEL_FORMATS = [\n    // 4:2:0 Y, U, V\n    'I420',\n    'I420P10',\n    'I420P12',\n    // 4:2:0 Y, U, V, A\n    'I420A',\n    'I420AP10',\n    'I420AP12',\n    // 4:2:2 Y, U, V\n    'I422',\n    'I422P10',\n    'I422P12',\n    // 4:2:2 Y, U, V, A\n    'I422A',\n    'I422AP10',\n    'I422AP12',\n    // 4:4:4 Y, U, V\n    'I444',\n    'I444P10',\n    'I444P12',\n    // 4:4:4 Y, U, V, A\n    'I444A',\n    'I444AP10',\n    'I444AP12',\n    // 4:2:0 Y, UV\n    'NV12',\n    // 4:4:4 RGBA\n    'RGBA',\n    // 4:4:4 RGBX (opaque)\n    'RGBX',\n    // 4:4:4 BGRA\n    'BGRA',\n    // 4:4:4 BGRX (opaque)\n    'BGRX',\n];\nconst VIDEO_SAMPLE_PIXEL_FORMATS_SET = new Set(VIDEO_SAMPLE_PIXEL_FORMATS);\n/**\n * Represents a raw, unencoded video sample (frame). Mainly used as an expressive wrapper around WebCodecs API's\n * [`VideoFrame`](https://developer.mozilla.org/en-US/docs/Web/API/VideoFrame), but can also be used standalone.\n * @group Samples\n * @public\n */\nexport class VideoSample {\n    /** The width of the frame in pixels after rotation. */\n    get displayWidth() {\n        return this.rotation % 180 === 0 ? this.codedWidth : this.codedHeight;\n    }\n    /** The height of the frame in pixels after rotation. */\n    get displayHeight() {\n        return this.rotation % 180 === 0 ? this.codedHeight : this.codedWidth;\n    }\n    /** The presentation timestamp of the frame in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of the frame in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    /**\n     * Whether this sample uses a pixel format that can hold transparency data. Note that this doesn't necessarily mean\n     * that the sample is transparent.\n     */\n    get hasAlpha() {\n        return this.format && this.format.includes('A');\n    }\n    constructor(data, init) {\n        /** @internal */\n        this._closed = false;\n        if (data instanceof ArrayBuffer\n            || (typeof SharedArrayBuffer !== 'undefined' && data instanceof SharedArrayBuffer)\n            || ArrayBuffer.isView(data)) {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('init must be an object.');\n            }\n            if (init.format === undefined || !VIDEO_SAMPLE_PIXEL_FORMATS_SET.has(init.format)) {\n                throw new TypeError('init.format must be one of: ' + VIDEO_SAMPLE_PIXEL_FORMATS.join(', '));\n            }\n            if (!Number.isInteger(init.codedWidth) || init.codedWidth <= 0) {\n                throw new TypeError('init.codedWidth must be a positive integer.');\n            }\n            if (!Number.isInteger(init.codedHeight) || init.codedHeight <= 0) {\n                throw new TypeError('init.codedHeight must be a positive integer.');\n            }\n            if (init.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (!Number.isFinite(init.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            if (init.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            this._data = toUint8Array(data).slice(); // Copy it\n            this._layout = init.layout ?? createDefaultPlaneLayout(init.format, init.codedWidth, init.codedHeight);\n            this.format = init.format;\n            this.codedWidth = init.codedWidth;\n            this.codedHeight = init.codedHeight;\n            this.rotation = init.rotation ?? 0;\n            this.timestamp = init.timestamp;\n            this.duration = init.duration ?? 0;\n            this.colorSpace = new VideoSampleColorSpace(init.colorSpace);\n        }\n        else if (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) {\n            if (init?.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (init?.timestamp !== undefined && !Number.isFinite(init?.timestamp)) {\n                throw new TypeError('init.timestamp, when provided, must be a number.');\n            }\n            if (init?.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            this._data = data;\n            this._layout = null;\n            this.format = data.format;\n            // Copying the display dimensions here, assuming no innate VideoFrame rotation\n            this.codedWidth = data.displayWidth;\n            this.codedHeight = data.displayHeight;\n            // The VideoFrame's rotation is ignored here. It's still a new field, and I'm not sure of any application\n            // where the browser makes use of it. If a case gets found, I'll add it.\n            this.rotation = init?.rotation ?? 0;\n            this.timestamp = init?.timestamp ?? data.timestamp / 1e6;\n            this.duration = init?.duration ?? (data.duration ?? 0) / 1e6;\n            this.colorSpace = new VideoSampleColorSpace(data.colorSpace);\n        }\n        else if ((typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement)\n            || (typeof SVGImageElement !== 'undefined' && data instanceof SVGImageElement)\n            || (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap)\n            || (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement)\n            || (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement)\n            || (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas)) {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('init must be an object.');\n            }\n            if (init.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (!Number.isFinite(init.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            if (init.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            if (typeof VideoFrame !== 'undefined') {\n                return new VideoSample(new VideoFrame(data, {\n                    timestamp: Math.trunc(init.timestamp * SECOND_TO_MICROSECOND_FACTOR),\n                    // Drag 0 to undefined\n                    duration: Math.trunc((init.duration ?? 0) * SECOND_TO_MICROSECOND_FACTOR) || undefined,\n                }), init);\n            }\n            let width = 0;\n            let height = 0;\n            // Determine the dimensions of the thing\n            if ('naturalWidth' in data) {\n                width = data.naturalWidth;\n                height = data.naturalHeight;\n            }\n            else if ('videoWidth' in data) {\n                width = data.videoWidth;\n                height = data.videoHeight;\n            }\n            else if ('width' in data) {\n                width = Number(data.width);\n                height = Number(data.height);\n            }\n            if (!width || !height) {\n                throw new TypeError('Could not determine dimensions.');\n            }\n            const canvas = new OffscreenCanvas(width, height);\n            const context = canvas.getContext('2d', {\n                alpha: isFirefox(), // Firefox has VideoFrame glitches with opaque canvases\n                willReadFrequently: true,\n            });\n            assert(context);\n            // Draw it to a canvas\n            context.drawImage(data, 0, 0);\n            this._data = canvas;\n            this._layout = null;\n            this.format = 'RGBX';\n            this.codedWidth = width;\n            this.codedHeight = height;\n            this.rotation = init.rotation ?? 0;\n            this.timestamp = init.timestamp;\n            this.duration = init.duration ?? 0;\n            this.colorSpace = new VideoSampleColorSpace({\n                matrix: 'rgb',\n                primaries: 'bt709',\n                transfer: 'iec61966-2-1',\n                fullRange: true,\n            });\n        }\n        else {\n            throw new TypeError('Invalid data type: Must be a BufferSource or CanvasImageSource.');\n        }\n        finalizationRegistry?.register(this, { type: 'video', data: this._data }, this);\n    }\n    /** Clones this video sample. */\n    clone() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            return new VideoSample(this._data.clone(), {\n                timestamp: this.timestamp,\n                duration: this.duration,\n                rotation: this.rotation,\n            });\n        }\n        else if (this._data instanceof Uint8Array) {\n            assert(this._layout);\n            return new VideoSample(this._data, {\n                format: this.format,\n                layout: this._layout,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.timestamp,\n                duration: this.duration,\n                colorSpace: this.colorSpace,\n                rotation: this.rotation,\n            });\n        }\n        else {\n            return new VideoSample(this._data, {\n                format: this.format,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.timestamp,\n                duration: this.duration,\n                colorSpace: this.colorSpace,\n                rotation: this.rotation,\n            });\n        }\n    }\n    /**\n     * Closes this video sample, releasing held resources. Video samples should be closed as soon as they are not\n     * needed anymore.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        finalizationRegistry?.unregister(this);\n        if (isVideoFrame(this._data)) {\n            this._data.close();\n        }\n        else {\n            this._data = null; // GC that shit\n        }\n        this._closed = true;\n    }\n    /**\n     * Returns the number of bytes required to hold this video sample's pixel data. Throws if `format` is `null`;\n     * specify an explicit RGB format in the options in this case.\n     */\n    allocationSize(options = {}) {\n        validateVideoFrameCopyToOptions(options);\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        if ((options.format ?? this.format) === null) {\n            throw new Error('Cannot get allocation size when format is null. Please manually provide an RGB pixel format in the'\n                + ' options instead.');\n        }\n        assert(this._data !== null);\n        if (!isVideoFrame(this._data)) {\n            if (options.colorSpace\n                || (options.format && options.format !== this.format)\n                || options.layout\n                || options.rect) {\n                // Temporarily convert to VideoFrame to get it done\n                const videoFrame = this.toVideoFrame();\n                const size = videoFrame.allocationSize(options);\n                videoFrame.close();\n                return size;\n            }\n        }\n        if (isVideoFrame(this._data)) {\n            return this._data.allocationSize(options);\n        }\n        else if (this._data instanceof Uint8Array) {\n            return this._data.byteLength;\n        }\n        else {\n            return this.codedWidth * this.codedHeight * 4; // RGBX\n        }\n    }\n    /**\n     * Copies this video sample's pixel data to an ArrayBuffer or ArrayBufferView. Throws if `format` is `null`;\n     * specify an explicit RGB format in the options in this case.\n     * @returns The byte layout of the planes of the copied data.\n     */\n    async copyTo(destination, options = {}) {\n        if (!isAllowSharedBufferSource(destination)) {\n            throw new TypeError('destination must be an ArrayBuffer or an ArrayBuffer view.');\n        }\n        validateVideoFrameCopyToOptions(options);\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        if ((options.format ?? this.format) === null) {\n            throw new Error('Cannot copy video sample data when format is null. Please manually provide an RGB pixel format in the'\n                + ' options instead.');\n        }\n        assert(this._data !== null);\n        if (!isVideoFrame(this._data)) {\n            if (options.colorSpace\n                || (options.format && options.format !== this.format)\n                || options.layout\n                || options.rect) {\n                // Temporarily convert to VideoFrame to get it done\n                const videoFrame = this.toVideoFrame();\n                const layout = await videoFrame.copyTo(destination, options);\n                videoFrame.close();\n                return layout;\n            }\n        }\n        if (isVideoFrame(this._data)) {\n            return this._data.copyTo(destination, options);\n        }\n        else if (this._data instanceof Uint8Array) {\n            assert(this._layout);\n            const dest = toUint8Array(destination);\n            dest.set(this._data);\n            return this._layout;\n        }\n        else {\n            const canvas = this._data;\n            const context = canvas.getContext('2d');\n            assert(context);\n            const imageData = context.getImageData(0, 0, this.codedWidth, this.codedHeight);\n            const dest = toUint8Array(destination);\n            dest.set(imageData.data);\n            return [{\n                    offset: 0,\n                    stride: 4 * this.codedWidth,\n                }];\n        }\n    }\n    /**\n     * Converts this video sample to a VideoFrame for use with the WebCodecs API. The VideoFrame returned by this\n     * method *must* be closed separately from this video sample.\n     */\n    toVideoFrame() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            return new VideoFrame(this._data, {\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration || undefined, // Drag 0 duration to undefined, glitches some codecs\n            });\n        }\n        else if (this._data instanceof Uint8Array) {\n            return new VideoFrame(this._data, {\n                format: this.format,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration || undefined,\n                colorSpace: this.colorSpace,\n            });\n        }\n        else {\n            return new VideoFrame(this._data, {\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration || undefined,\n            });\n        }\n    }\n    draw(context, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {\n        let sx = 0;\n        let sy = 0;\n        let sWidth = this.displayWidth;\n        let sHeight = this.displayHeight;\n        let dx = 0;\n        let dy = 0;\n        let dWidth = this.displayWidth;\n        let dHeight = this.displayHeight;\n        if (arg5 !== undefined) {\n            sx = arg1;\n            sy = arg2;\n            sWidth = arg3;\n            sHeight = arg4;\n            dx = arg5;\n            dy = arg6;\n            if (arg7 !== undefined) {\n                dWidth = arg7;\n                dHeight = arg8;\n            }\n            else {\n                dWidth = sWidth;\n                dHeight = sHeight;\n            }\n        }\n        else {\n            dx = arg1;\n            dy = arg2;\n            if (arg3 !== undefined) {\n                dWidth = arg3;\n                dHeight = arg4;\n            }\n        }\n        if (!((typeof CanvasRenderingContext2D !== 'undefined' && context instanceof CanvasRenderingContext2D)\n            || (typeof OffscreenCanvasRenderingContext2D !== 'undefined'\n                && context instanceof OffscreenCanvasRenderingContext2D))) {\n            throw new TypeError('context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.');\n        }\n        if (!Number.isFinite(sx)) {\n            throw new TypeError('sx must be a number.');\n        }\n        if (!Number.isFinite(sy)) {\n            throw new TypeError('sy must be a number.');\n        }\n        if (!Number.isFinite(sWidth) || sWidth < 0) {\n            throw new TypeError('sWidth must be a non-negative number.');\n        }\n        if (!Number.isFinite(sHeight) || sHeight < 0) {\n            throw new TypeError('sHeight must be a non-negative number.');\n        }\n        if (!Number.isFinite(dx)) {\n            throw new TypeError('dx must be a number.');\n        }\n        if (!Number.isFinite(dy)) {\n            throw new TypeError('dy must be a number.');\n        }\n        if (!Number.isFinite(dWidth) || dWidth < 0) {\n            throw new TypeError('dWidth must be a non-negative number.');\n        }\n        if (!Number.isFinite(dHeight) || dHeight < 0) {\n            throw new TypeError('dHeight must be a non-negative number.');\n        }\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        ({ sx, sy, sWidth, sHeight } = this._rotateSourceRegion(sx, sy, sWidth, sHeight, this.rotation));\n        const source = this.toCanvasImageSource();\n        context.save();\n        const centerX = dx + dWidth / 2;\n        const centerY = dy + dHeight / 2;\n        context.translate(centerX, centerY);\n        context.rotate(this.rotation * Math.PI / 180);\n        const aspectRatioChange = this.rotation % 180 === 0 ? 1 : dWidth / dHeight;\n        // Scale to compensate for aspect ratio changes when rotated\n        context.scale(1 / aspectRatioChange, aspectRatioChange);\n        context.drawImage(source, sx, sy, sWidth, sHeight, -dWidth / 2, -dHeight / 2, dWidth, dHeight);\n        context.restore();\n    }\n    /**\n     * Draws the sample in the middle of the canvas corresponding to the context with the specified fit behavior.\n     */\n    drawWithFit(context, options) {\n        if (!((typeof CanvasRenderingContext2D !== 'undefined' && context instanceof CanvasRenderingContext2D)\n            || (typeof OffscreenCanvasRenderingContext2D !== 'undefined'\n                && context instanceof OffscreenCanvasRenderingContext2D))) {\n            throw new TypeError('context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!['fill', 'contain', 'cover'].includes(options.fit)) {\n            throw new TypeError('options.fit must be \\'fill\\', \\'contain\\', or \\'cover\\'.');\n        }\n        if (options.rotation !== undefined && ![0, 90, 180, 270].includes(options.rotation)) {\n            throw new TypeError('options.rotation, when provided, must be 0, 90, 180, or 270.');\n        }\n        if (options.crop !== undefined) {\n            validateCropRectangle(options.crop, 'options.');\n        }\n        const canvasWidth = context.canvas.width;\n        const canvasHeight = context.canvas.height;\n        const rotation = options.rotation ?? this.rotation;\n        const [rotatedWidth, rotatedHeight] = rotation % 180 === 0\n            ? [this.codedWidth, this.codedHeight]\n            : [this.codedHeight, this.codedWidth];\n        if (options.crop) {\n            clampCropRectangle(options.crop, rotatedWidth, rotatedHeight);\n        }\n        // These variables specify where the final sample will be drawn on the canvas\n        let dx;\n        let dy;\n        let newWidth;\n        let newHeight;\n        const { sx, sy, sWidth, sHeight } = this._rotateSourceRegion(options.crop?.left ?? 0, options.crop?.top ?? 0, options.crop?.width ?? rotatedWidth, options.crop?.height ?? rotatedHeight, rotation);\n        if (options.fit === 'fill') {\n            dx = 0;\n            dy = 0;\n            newWidth = canvasWidth;\n            newHeight = canvasHeight;\n        }\n        else {\n            const [sampleWidth, sampleHeight] = options.crop\n                ? [options.crop.width, options.crop.height]\n                : [rotatedWidth, rotatedHeight];\n            const scale = options.fit === 'contain'\n                ? Math.min(canvasWidth / sampleWidth, canvasHeight / sampleHeight)\n                : Math.max(canvasWidth / sampleWidth, canvasHeight / sampleHeight);\n            newWidth = sampleWidth * scale;\n            newHeight = sampleHeight * scale;\n            dx = (canvasWidth - newWidth) / 2;\n            dy = (canvasHeight - newHeight) / 2;\n        }\n        context.save();\n        const aspectRatioChange = rotation % 180 === 0 ? 1 : newWidth / newHeight;\n        context.translate(canvasWidth / 2, canvasHeight / 2);\n        context.rotate(rotation * Math.PI / 180);\n        // This aspect ratio compensation is done so that we can draw the sample with the intended dimensions and\n        // don't need to think about how those dimensions change after the rotation\n        context.scale(1 / aspectRatioChange, aspectRatioChange);\n        context.translate(-canvasWidth / 2, -canvasHeight / 2);\n        // Important that we don't use .draw() here since that would take rotation into account, but we wanna handle it\n        // ourselves here\n        context.drawImage(this.toCanvasImageSource(), sx, sy, sWidth, sHeight, dx, dy, newWidth, newHeight);\n        context.restore();\n    }\n    /** @internal */\n    _rotateSourceRegion(sx, sy, sWidth, sHeight, rotation) {\n        // The provided sx,sy,sWidth,sHeight refer to the final rotated image, but that's not actually how the image is\n        // stored. Therefore, we must map these back onto the original, pre-rotation image.\n        if (rotation === 90) {\n            [sx, sy, sWidth, sHeight] = [\n                sy,\n                this.codedHeight - sx - sWidth,\n                sHeight,\n                sWidth,\n            ];\n        }\n        else if (rotation === 180) {\n            [sx, sy] = [\n                this.codedWidth - sx - sWidth,\n                this.codedHeight - sy - sHeight,\n            ];\n        }\n        else if (rotation === 270) {\n            [sx, sy, sWidth, sHeight] = [\n                this.codedWidth - sy - sHeight,\n                sx,\n                sHeight,\n                sWidth,\n            ];\n        }\n        return { sx, sy, sWidth, sHeight };\n    }\n    /**\n     * Converts this video sample to a\n     * [`CanvasImageSource`](https://udn.realityripple.com/docs/Web/API/CanvasImageSource) for drawing to a canvas.\n     *\n     * You must use the value returned by this method immediately, as any VideoFrame created internally will\n     * automatically be closed in the next microtask.\n     */\n    toCanvasImageSource() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (this._data instanceof Uint8Array) {\n            // Requires VideoFrame to be defined\n            const videoFrame = this.toVideoFrame();\n            queueMicrotask(() => videoFrame.close()); // Let's automatically close the frame in the next microtask\n            return videoFrame;\n        }\n        else {\n            return this._data;\n        }\n    }\n    /** Sets the rotation metadata of this video sample. */\n    setRotation(newRotation) {\n        if (![0, 90, 180, 270].includes(newRotation)) {\n            throw new TypeError('newRotation must be 0, 90, 180, or 270.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.rotation = newRotation;\n    }\n    /** Sets the presentation timestamp of this video sample, in seconds. */\n    setTimestamp(newTimestamp) {\n        if (!Number.isFinite(newTimestamp)) {\n            throw new TypeError('newTimestamp must be a number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.timestamp = newTimestamp;\n    }\n    /** Sets the duration of this video sample, in seconds. */\n    setDuration(newDuration) {\n        if (!Number.isFinite(newDuration) || newDuration < 0) {\n            throw new TypeError('newDuration must be a non-negative number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.duration = newDuration;\n    }\n    /** Calls `.close()`. */\n    [Symbol.dispose]() {\n        this.close();\n    }\n}\n/**\n * Describes the color space of a {@link VideoSample}. Corresponds to the WebCodecs API's VideoColorSpace.\n * @group Samples\n * @public\n */\nexport class VideoSampleColorSpace {\n    /** Creates a new VideoSampleColorSpace. */\n    constructor(init) {\n        this.primaries = init?.primaries ?? null;\n        this.transfer = init?.transfer ?? null;\n        this.matrix = init?.matrix ?? null;\n        this.fullRange = init?.fullRange ?? null;\n    }\n    /** Serializes the color space to a JSON object. */\n    toJSON() {\n        return {\n            primaries: this.primaries,\n            transfer: this.transfer,\n            matrix: this.matrix,\n            fullRange: this.fullRange,\n        };\n    }\n}\nconst isVideoFrame = (x) => {\n    return typeof VideoFrame !== 'undefined' && x instanceof VideoFrame;\n};\nexport const clampCropRectangle = (crop, outerWidth, outerHeight) => {\n    crop.left = Math.min(crop.left, outerWidth);\n    crop.top = Math.min(crop.top, outerHeight);\n    crop.width = Math.min(crop.width, outerWidth - crop.left);\n    crop.height = Math.min(crop.height, outerHeight - crop.top);\n    assert(crop.width >= 0);\n    assert(crop.height >= 0);\n};\nexport const validateCropRectangle = (crop, prefix) => {\n    if (!crop || typeof crop !== 'object') {\n        throw new TypeError(prefix + 'crop, when provided, must be an object.');\n    }\n    if (!Number.isInteger(crop.left) || crop.left < 0) {\n        throw new TypeError(prefix + 'crop.left must be a non-negative integer.');\n    }\n    if (!Number.isInteger(crop.top) || crop.top < 0) {\n        throw new TypeError(prefix + 'crop.top must be a non-negative integer.');\n    }\n    if (!Number.isInteger(crop.width) || crop.width < 0) {\n        throw new TypeError(prefix + 'crop.width must be a non-negative integer.');\n    }\n    if (!Number.isInteger(crop.height) || crop.height < 0) {\n        throw new TypeError(prefix + 'crop.height must be a non-negative integer.');\n    }\n};\nconst validateVideoFrameCopyToOptions = (options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('options must be an object.');\n    }\n    if (options.colorSpace !== undefined && !['display-p3', 'srgb'].includes(options.colorSpace)) {\n        throw new TypeError('options.colorSpace, when provided, must be \\'display-p3\\' or \\'srgb\\'.');\n    }\n    if (options.format !== undefined && typeof options.format !== 'string') {\n        throw new TypeError('options.format, when provided, must be a string.');\n    }\n    if (options.layout !== undefined) {\n        if (!Array.isArray(options.layout)) {\n            throw new TypeError('options.layout, when provided, must be an array.');\n        }\n        for (const plane of options.layout) {\n            if (!plane || typeof plane !== 'object') {\n                throw new TypeError('Each entry in options.layout must be an object.');\n            }\n            if (!Number.isInteger(plane.offset) || plane.offset < 0) {\n                throw new TypeError('plane.offset must be a non-negative integer.');\n            }\n            if (!Number.isInteger(plane.stride) || plane.stride < 0) {\n                throw new TypeError('plane.stride must be a non-negative integer.');\n            }\n        }\n    }\n    if (options.rect !== undefined) {\n        if (!options.rect || typeof options.rect !== 'object') {\n            throw new TypeError('options.rect, when provided, must be an object.');\n        }\n        if (options.rect.x !== undefined && (!Number.isInteger(options.rect.x) || options.rect.x < 0)) {\n            throw new TypeError('options.rect.x, when provided, must be a non-negative integer.');\n        }\n        if (options.rect.y !== undefined && (!Number.isInteger(options.rect.y) || options.rect.y < 0)) {\n            throw new TypeError('options.rect.y, when provided, must be a non-negative integer.');\n        }\n        if (options.rect.width !== undefined && (!Number.isInteger(options.rect.width) || options.rect.width < 0)) {\n            throw new TypeError('options.rect.width, when provided, must be a non-negative integer.');\n        }\n        if (options.rect.height !== undefined && (!Number.isInteger(options.rect.height) || options.rect.height < 0)) {\n            throw new TypeError('options.rect.height, when provided, must be a non-negative integer.');\n        }\n    }\n};\n/** Implements logic from WebCodecs  9.4.6 \"Compute Layout and Allocation Size\" */\nconst createDefaultPlaneLayout = (format, codedWidth, codedHeight) => {\n    const planes = getPlaneConfigs(format);\n    const layouts = [];\n    let currentOffset = 0;\n    for (const plane of planes) {\n        // Per  9.8, dimensions are usually \"rounded up to the nearest integer\".\n        const planeWidth = Math.ceil(codedWidth / plane.widthDivisor);\n        const planeHeight = Math.ceil(codedHeight / plane.heightDivisor);\n        const stride = planeWidth * plane.sampleBytes;\n        // Tight packing\n        const planeSize = stride * planeHeight;\n        layouts.push({\n            offset: currentOffset,\n            stride: stride,\n        });\n        currentOffset += planeSize;\n    }\n    return layouts;\n};\n/** Helper to retrieve plane configurations based on WebCodecs  9.8 Pixel Format definitions. */\nconst getPlaneConfigs = (format) => {\n    // Helper for standard YUV planes\n    const yuv = (yBytes, uvBytes, subX, subY, hasAlpha) => {\n        const configs = [\n            { sampleBytes: yBytes, widthDivisor: 1, heightDivisor: 1 },\n            { sampleBytes: uvBytes, widthDivisor: subX, heightDivisor: subY },\n            { sampleBytes: uvBytes, widthDivisor: subX, heightDivisor: subY },\n        ];\n        if (hasAlpha) {\n            // Match luma dimensions\n            configs.push({ sampleBytes: yBytes, widthDivisor: 1, heightDivisor: 1 });\n        }\n        return configs;\n    };\n    switch (format) {\n        case 'I420':\n            return yuv(1, 1, 2, 2, false);\n        case 'I420P10':\n        case 'I420P12':\n            return yuv(2, 2, 2, 2, false);\n        case 'I420A':\n            return yuv(1, 1, 2, 2, true);\n        case 'I420AP10':\n        case 'I420AP12':\n            return yuv(2, 2, 2, 2, true);\n        case 'I422':\n            return yuv(1, 1, 2, 1, false);\n        case 'I422P10':\n        case 'I422P12':\n            return yuv(2, 2, 2, 1, false);\n        case 'I422A':\n            return yuv(1, 1, 2, 1, true);\n        case 'I422AP10':\n        case 'I422AP12':\n            return yuv(2, 2, 2, 1, true);\n        case 'I444':\n            return yuv(1, 1, 1, 1, false);\n        case 'I444P10':\n        case 'I444P12':\n            return yuv(2, 2, 1, 1, false);\n        case 'I444A':\n            return yuv(1, 1, 1, 1, true);\n        case 'I444AP10':\n        case 'I444AP12':\n            return yuv(2, 2, 1, 1, true);\n        case 'NV12':\n            return [\n                { sampleBytes: 1, widthDivisor: 1, heightDivisor: 1 },\n                { sampleBytes: 2, widthDivisor: 2, heightDivisor: 2 }, // Interleaved U and V\n            ];\n        case 'RGBA':\n        case 'RGBX':\n        case 'BGRA':\n        case 'BGRX':\n            return [\n                { sampleBytes: 4, widthDivisor: 1, heightDivisor: 1 },\n            ];\n        default:\n            assertNever(format);\n            assert(false);\n    }\n};\nconst AUDIO_SAMPLE_FORMATS = new Set(['f32', 'f32-planar', 's16', 's16-planar', 's32', 's32-planar', 'u8', 'u8-planar']);\n/**\n * Represents a raw, unencoded audio sample. Mainly used as an expressive wrapper around WebCodecs API's\n * [`AudioData`](https://developer.mozilla.org/en-US/docs/Web/API/AudioData), but can also be used standalone.\n * @group Samples\n * @public\n */\nexport class AudioSample {\n    /** The presentation timestamp of the sample in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of the sample in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    /**\n     * Creates a new {@link AudioSample}, either from an existing\n     * [`AudioData`](https://developer.mozilla.org/en-US/docs/Web/API/AudioData) or from raw bytes specified in\n     * {@link AudioSampleInit}.\n     */\n    constructor(init) {\n        /** @internal */\n        this._closed = false;\n        if (isAudioData(init)) {\n            if (init.format === null) {\n                throw new TypeError('AudioData with null format is not supported.');\n            }\n            this._data = init;\n            this.format = init.format;\n            this.sampleRate = init.sampleRate;\n            this.numberOfFrames = init.numberOfFrames;\n            this.numberOfChannels = init.numberOfChannels;\n            this.timestamp = init.timestamp / 1e6;\n            this.duration = init.numberOfFrames / init.sampleRate;\n        }\n        else {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('Invalid AudioDataInit: must be an object.');\n            }\n            if (!AUDIO_SAMPLE_FORMATS.has(init.format)) {\n                throw new TypeError('Invalid AudioDataInit: invalid format.');\n            }\n            if (!Number.isFinite(init.sampleRate) || init.sampleRate <= 0) {\n                throw new TypeError('Invalid AudioDataInit: sampleRate must be > 0.');\n            }\n            if (!Number.isInteger(init.numberOfChannels) || init.numberOfChannels === 0) {\n                throw new TypeError('Invalid AudioDataInit: numberOfChannels must be an integer > 0.');\n            }\n            if (!Number.isFinite(init?.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            const numberOfFrames = init.data.byteLength / (getBytesPerSample(init.format) * init.numberOfChannels);\n            if (!Number.isInteger(numberOfFrames)) {\n                throw new TypeError('Invalid AudioDataInit: data size is not a multiple of frame size.');\n            }\n            this.format = init.format;\n            this.sampleRate = init.sampleRate;\n            this.numberOfFrames = numberOfFrames;\n            this.numberOfChannels = init.numberOfChannels;\n            this.timestamp = init.timestamp;\n            this.duration = numberOfFrames / init.sampleRate;\n            let dataBuffer;\n            if (init.data instanceof ArrayBuffer) {\n                dataBuffer = new Uint8Array(init.data);\n            }\n            else if (ArrayBuffer.isView(init.data)) {\n                dataBuffer = new Uint8Array(init.data.buffer, init.data.byteOffset, init.data.byteLength);\n            }\n            else {\n                throw new TypeError('Invalid AudioDataInit: data is not a BufferSource.');\n            }\n            const expectedSize = this.numberOfFrames * this.numberOfChannels * getBytesPerSample(this.format);\n            if (dataBuffer.byteLength < expectedSize) {\n                throw new TypeError('Invalid AudioDataInit: insufficient data size.');\n            }\n            this._data = dataBuffer;\n        }\n        finalizationRegistry?.register(this, { type: 'audio', data: this._data }, this);\n    }\n    /** Returns the number of bytes required to hold the audio sample's data as specified by the given options. */\n    allocationSize(options) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!Number.isInteger(options.planeIndex) || options.planeIndex < 0) {\n            throw new TypeError('planeIndex must be a non-negative integer.');\n        }\n        if (options.format !== undefined && !AUDIO_SAMPLE_FORMATS.has(options.format)) {\n            throw new TypeError('Invalid format.');\n        }\n        if (options.frameOffset !== undefined && (!Number.isInteger(options.frameOffset) || options.frameOffset < 0)) {\n            throw new TypeError('frameOffset must be a non-negative integer.');\n        }\n        if (options.frameCount !== undefined && (!Number.isInteger(options.frameCount) || options.frameCount < 0)) {\n            throw new TypeError('frameCount must be a non-negative integer.');\n        }\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const destFormat = options.format ?? this.format;\n        const frameOffset = options.frameOffset ?? 0;\n        if (frameOffset >= this.numberOfFrames) {\n            throw new RangeError('frameOffset out of range');\n        }\n        const copyFrameCount = options.frameCount !== undefined ? options.frameCount : (this.numberOfFrames - frameOffset);\n        if (copyFrameCount > (this.numberOfFrames - frameOffset)) {\n            throw new RangeError('frameCount out of range');\n        }\n        const bytesPerSample = getBytesPerSample(destFormat);\n        const isPlanar = formatIsPlanar(destFormat);\n        if (isPlanar && options.planeIndex >= this.numberOfChannels) {\n            throw new RangeError('planeIndex out of range');\n        }\n        if (!isPlanar && options.planeIndex !== 0) {\n            throw new RangeError('planeIndex out of range');\n        }\n        const elementCount = isPlanar ? copyFrameCount : copyFrameCount * this.numberOfChannels;\n        return elementCount * bytesPerSample;\n    }\n    /** Copies the audio sample's data to an ArrayBuffer or ArrayBufferView as specified by the given options. */\n    copyTo(destination, options) {\n        if (!isAllowSharedBufferSource(destination)) {\n            throw new TypeError('destination must be an ArrayBuffer or an ArrayBuffer view.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!Number.isInteger(options.planeIndex) || options.planeIndex < 0) {\n            throw new TypeError('planeIndex must be a non-negative integer.');\n        }\n        if (options.format !== undefined && !AUDIO_SAMPLE_FORMATS.has(options.format)) {\n            throw new TypeError('Invalid format.');\n        }\n        if (options.frameOffset !== undefined && (!Number.isInteger(options.frameOffset) || options.frameOffset < 0)) {\n            throw new TypeError('frameOffset must be a non-negative integer.');\n        }\n        if (options.frameCount !== undefined && (!Number.isInteger(options.frameCount) || options.frameCount < 0)) {\n            throw new TypeError('frameCount must be a non-negative integer.');\n        }\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const { planeIndex, format, frameCount: optFrameCount, frameOffset: optFrameOffset } = options;\n        const srcFormat = this.format;\n        const destFormat = format ?? this.format;\n        if (!destFormat)\n            throw new Error('Destination format not determined');\n        const numFrames = this.numberOfFrames;\n        const numChannels = this.numberOfChannels;\n        const frameOffset = optFrameOffset ?? 0;\n        if (frameOffset >= numFrames) {\n            throw new RangeError('frameOffset out of range');\n        }\n        const copyFrameCount = optFrameCount !== undefined ? optFrameCount : (numFrames - frameOffset);\n        if (copyFrameCount > (numFrames - frameOffset)) {\n            throw new RangeError('frameCount out of range');\n        }\n        const destBytesPerSample = getBytesPerSample(destFormat);\n        const destIsPlanar = formatIsPlanar(destFormat);\n        if (destIsPlanar && planeIndex >= numChannels) {\n            throw new RangeError('planeIndex out of range');\n        }\n        if (!destIsPlanar && planeIndex !== 0) {\n            throw new RangeError('planeIndex out of range');\n        }\n        const destElementCount = destIsPlanar ? copyFrameCount : copyFrameCount * numChannels;\n        const requiredSize = destElementCount * destBytesPerSample;\n        if (destination.byteLength < requiredSize) {\n            throw new RangeError('Destination buffer is too small');\n        }\n        const destView = toDataView(destination);\n        const writeFn = getWriteFunction(destFormat);\n        if (isAudioData(this._data)) {\n            if (isWebKit() && numChannels > 2 && destFormat !== srcFormat) {\n                // WebKit bug workaround\n                doAudioDataCopyToWebKitWorkaround(this._data, destView, srcFormat, destFormat, numChannels, planeIndex, frameOffset, copyFrameCount);\n            }\n            else {\n                // Per spec, only f32-planar conversion must be supported, but in practice, all browsers support all\n                // destination formats, so let's just delegate here:\n                this._data.copyTo(destination, {\n                    planeIndex,\n                    frameOffset,\n                    frameCount: copyFrameCount,\n                    format: destFormat,\n                });\n            }\n        }\n        else {\n            const uint8Data = this._data;\n            const srcView = toDataView(uint8Data);\n            const readFn = getReadFunction(srcFormat);\n            const srcBytesPerSample = getBytesPerSample(srcFormat);\n            const srcIsPlanar = formatIsPlanar(srcFormat);\n            for (let i = 0; i < copyFrameCount; i++) {\n                if (destIsPlanar) {\n                    const destOffset = i * destBytesPerSample;\n                    let srcOffset;\n                    if (srcIsPlanar) {\n                        srcOffset = (planeIndex * numFrames + (i + frameOffset)) * srcBytesPerSample;\n                    }\n                    else {\n                        srcOffset = (((i + frameOffset) * numChannels) + planeIndex) * srcBytesPerSample;\n                    }\n                    const normalized = readFn(srcView, srcOffset);\n                    writeFn(destView, destOffset, normalized);\n                }\n                else {\n                    for (let ch = 0; ch < numChannels; ch++) {\n                        const destIndex = i * numChannels + ch;\n                        const destOffset = destIndex * destBytesPerSample;\n                        let srcOffset;\n                        if (srcIsPlanar) {\n                            srcOffset = (ch * numFrames + (i + frameOffset)) * srcBytesPerSample;\n                        }\n                        else {\n                            srcOffset = (((i + frameOffset) * numChannels) + ch) * srcBytesPerSample;\n                        }\n                        const normalized = readFn(srcView, srcOffset);\n                        writeFn(destView, destOffset, normalized);\n                    }\n                }\n            }\n        }\n    }\n    /** Clones this audio sample. */\n    clone() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        if (isAudioData(this._data)) {\n            const sample = new AudioSample(this._data.clone());\n            sample.setTimestamp(this.timestamp); // Make sure the timestamp is precise (beyond microsecond accuracy)\n            return sample;\n        }\n        else {\n            return new AudioSample({\n                format: this.format,\n                sampleRate: this.sampleRate,\n                numberOfFrames: this.numberOfFrames,\n                numberOfChannels: this.numberOfChannels,\n                timestamp: this.timestamp,\n                data: this._data,\n            });\n        }\n    }\n    /**\n     * Closes this audio sample, releasing held resources. Audio samples should be closed as soon as they are not\n     * needed anymore.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        finalizationRegistry?.unregister(this);\n        if (isAudioData(this._data)) {\n            this._data.close();\n        }\n        else {\n            this._data = new Uint8Array(0);\n        }\n        this._closed = true;\n    }\n    /**\n     * Converts this audio sample to an AudioData for use with the WebCodecs API. The AudioData returned by this\n     * method *must* be closed separately from this audio sample.\n     */\n    toAudioData() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        if (isAudioData(this._data)) {\n            if (this._data.timestamp === this.microsecondTimestamp) {\n                // Timestamp matches, let's just return the data (but cloned)\n                return this._data.clone();\n            }\n            else {\n                // It's impossible to simply change an AudioData's timestamp, so we'll need to create a new one\n                if (formatIsPlanar(this.format)) {\n                    const size = this.allocationSize({ planeIndex: 0, format: this.format });\n                    const data = new ArrayBuffer(size * this.numberOfChannels);\n                    // We gotta read out each plane individually\n                    for (let i = 0; i < this.numberOfChannels; i++) {\n                        this.copyTo(new Uint8Array(data, i * size, size), { planeIndex: i, format: this.format });\n                    }\n                    return new AudioData({\n                        format: this.format,\n                        sampleRate: this.sampleRate,\n                        numberOfFrames: this.numberOfFrames,\n                        numberOfChannels: this.numberOfChannels,\n                        timestamp: this.microsecondTimestamp,\n                        data,\n                    });\n                }\n                else {\n                    const data = new ArrayBuffer(this.allocationSize({ planeIndex: 0, format: this.format }));\n                    this.copyTo(data, { planeIndex: 0, format: this.format });\n                    return new AudioData({\n                        format: this.format,\n                        sampleRate: this.sampleRate,\n                        numberOfFrames: this.numberOfFrames,\n                        numberOfChannels: this.numberOfChannels,\n                        timestamp: this.microsecondTimestamp,\n                        data,\n                    });\n                }\n            }\n        }\n        else {\n            return new AudioData({\n                format: this.format,\n                sampleRate: this.sampleRate,\n                numberOfFrames: this.numberOfFrames,\n                numberOfChannels: this.numberOfChannels,\n                timestamp: this.microsecondTimestamp,\n                data: this._data.buffer instanceof ArrayBuffer\n                    ? this._data.buffer\n                    : this._data.slice(), // In the case of SharedArrayBuffer, convert to ArrayBuffer\n            });\n        }\n    }\n    /** Convert this audio sample to an AudioBuffer for use with the Web Audio API. */\n    toAudioBuffer() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const audioBuffer = new AudioBuffer({\n            numberOfChannels: this.numberOfChannels,\n            length: this.numberOfFrames,\n            sampleRate: this.sampleRate,\n        });\n        const dataBytes = new Float32Array(this.allocationSize({ planeIndex: 0, format: 'f32-planar' }) / 4);\n        for (let i = 0; i < this.numberOfChannels; i++) {\n            this.copyTo(dataBytes, { planeIndex: i, format: 'f32-planar' });\n            audioBuffer.copyToChannel(dataBytes, i);\n        }\n        return audioBuffer;\n    }\n    /** Sets the presentation timestamp of this audio sample, in seconds. */\n    setTimestamp(newTimestamp) {\n        if (!Number.isFinite(newTimestamp)) {\n            throw new TypeError('newTimestamp must be a number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.timestamp = newTimestamp;\n    }\n    /** Calls `.close()`. */\n    [Symbol.dispose]() {\n        this.close();\n    }\n    /** @internal */\n    static *_fromAudioBuffer(audioBuffer, timestamp) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const MAX_FLOAT_COUNT = 48000 * 5; // 5 seconds of mono 48 kHz audio per sample\n        const numberOfChannels = audioBuffer.numberOfChannels;\n        const sampleRate = audioBuffer.sampleRate;\n        const totalFrames = audioBuffer.length;\n        const maxFramesPerChunk = Math.floor(MAX_FLOAT_COUNT / numberOfChannels);\n        let currentRelativeFrame = 0;\n        let remainingFrames = totalFrames;\n        // Create AudioSamples in a chunked fashion so we don't create huge Float32Arrays\n        while (remainingFrames > 0) {\n            const framesToCopy = Math.min(maxFramesPerChunk, remainingFrames);\n            const chunkData = new Float32Array(numberOfChannels * framesToCopy);\n            for (let channel = 0; channel < numberOfChannels; channel++) {\n                audioBuffer.copyFromChannel(chunkData.subarray(channel * framesToCopy, (channel + 1) * framesToCopy), channel, currentRelativeFrame);\n            }\n            yield new AudioSample({\n                format: 'f32-planar',\n                sampleRate,\n                numberOfFrames: framesToCopy,\n                numberOfChannels,\n                timestamp: timestamp + currentRelativeFrame / sampleRate,\n                data: chunkData,\n            });\n            currentRelativeFrame += framesToCopy;\n            remainingFrames -= framesToCopy;\n        }\n    }\n    /**\n     * Creates AudioSamples from an AudioBuffer, starting at the given timestamp in seconds. Typically creates exactly\n     * one sample, but may create multiple if the AudioBuffer is exceedingly large.\n     */\n    static fromAudioBuffer(audioBuffer, timestamp) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const MAX_FLOAT_COUNT = 48000 * 5; // 5 seconds of mono 48 kHz audio per sample\n        const numberOfChannels = audioBuffer.numberOfChannels;\n        const sampleRate = audioBuffer.sampleRate;\n        const totalFrames = audioBuffer.length;\n        const maxFramesPerChunk = Math.floor(MAX_FLOAT_COUNT / numberOfChannels);\n        let currentRelativeFrame = 0;\n        let remainingFrames = totalFrames;\n        const result = [];\n        // Create AudioSamples in a chunked fashion so we don't create huge Float32Arrays\n        while (remainingFrames > 0) {\n            const framesToCopy = Math.min(maxFramesPerChunk, remainingFrames);\n            const chunkData = new Float32Array(numberOfChannels * framesToCopy);\n            for (let channel = 0; channel < numberOfChannels; channel++) {\n                audioBuffer.copyFromChannel(chunkData.subarray(channel * framesToCopy, (channel + 1) * framesToCopy), channel, currentRelativeFrame);\n            }\n            const audioSample = new AudioSample({\n                format: 'f32-planar',\n                sampleRate,\n                numberOfFrames: framesToCopy,\n                numberOfChannels,\n                timestamp: timestamp + currentRelativeFrame / sampleRate,\n                data: chunkData,\n            });\n            result.push(audioSample);\n            currentRelativeFrame += framesToCopy;\n            remainingFrames -= framesToCopy;\n        }\n        return result;\n    }\n}\nconst getBytesPerSample = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return 1;\n        case 's16':\n        case 's16-planar':\n            return 2;\n        case 's32':\n        case 's32-planar':\n            return 4;\n        case 'f32':\n        case 'f32-planar':\n            return 4;\n        default:\n            throw new Error('Unknown AudioSampleFormat');\n    }\n};\nconst formatIsPlanar = (format) => {\n    switch (format) {\n        case 'u8-planar':\n        case 's16-planar':\n        case 's32-planar':\n        case 'f32-planar':\n            return true;\n        default:\n            return false;\n    }\n};\nconst getReadFunction = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return (view, offset) => (view.getUint8(offset) - 128) / 128;\n        case 's16':\n        case 's16-planar':\n            return (view, offset) => view.getInt16(offset, true) / 32768;\n        case 's32':\n        case 's32-planar':\n            return (view, offset) => view.getInt32(offset, true) / 2147483648;\n        case 'f32':\n        case 'f32-planar':\n            return (view, offset) => view.getFloat32(offset, true);\n    }\n};\nconst getWriteFunction = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return (view, offset, value) => view.setUint8(offset, clamp((value + 1) * 127.5, 0, 255));\n        case 's16':\n        case 's16-planar':\n            return (view, offset, value) => view.setInt16(offset, clamp(Math.round(value * 32767), -32768, 32767), true);\n        case 's32':\n        case 's32-planar':\n            return (view, offset, value) => view.setInt32(offset, clamp(Math.round(value * 2147483647), -2147483648, 2147483647), true);\n        case 'f32':\n        case 'f32-planar':\n            return (view, offset, value) => view.setFloat32(offset, value, true);\n    }\n};\nconst isAudioData = (x) => {\n    return typeof AudioData !== 'undefined' && x instanceof AudioData;\n};\n/**\n * WebKit has a bug where calling AudioData.copyTo with a format different from the source format\n * crashes the tab when there are more than 2 channels. This function works around that by always\n * copying with the source format and then manually converting to the destination format.\n *\n * See https://bugs.webkit.org/show_bug.cgi?id=302521.\n */\nconst doAudioDataCopyToWebKitWorkaround = (audioData, destView, srcFormat, destFormat, numChannels, planeIndex, frameOffset, copyFrameCount) => {\n    const readFn = getReadFunction(srcFormat);\n    const writeFn = getWriteFunction(destFormat);\n    const srcBytesPerSample = getBytesPerSample(srcFormat);\n    const destBytesPerSample = getBytesPerSample(destFormat);\n    const srcIsPlanar = formatIsPlanar(srcFormat);\n    const destIsPlanar = formatIsPlanar(destFormat);\n    if (destIsPlanar) {\n        if (srcIsPlanar) {\n            // src planar -> dest planar: copy single plane and convert\n            const data = new ArrayBuffer(copyFrameCount * srcBytesPerSample);\n            const dataView = toDataView(data);\n            audioData.copyTo(data, {\n                planeIndex,\n                frameOffset,\n                frameCount: copyFrameCount,\n                format: srcFormat,\n            });\n            for (let i = 0; i < copyFrameCount; i++) {\n                const srcOffset = i * srcBytesPerSample;\n                const destOffset = i * destBytesPerSample;\n                const sample = readFn(dataView, srcOffset);\n                writeFn(destView, destOffset, sample);\n            }\n        }\n        else {\n            // src interleaved -> dest planar: copy all interleaved data, extract one channel\n            const data = new ArrayBuffer(copyFrameCount * numChannels * srcBytesPerSample);\n            const dataView = toDataView(data);\n            audioData.copyTo(data, {\n                planeIndex: 0,\n                frameOffset,\n                frameCount: copyFrameCount,\n                format: srcFormat,\n            });\n            for (let i = 0; i < copyFrameCount; i++) {\n                const srcOffset = (i * numChannels + planeIndex) * srcBytesPerSample;\n                const destOffset = i * destBytesPerSample;\n                const sample = readFn(dataView, srcOffset);\n                writeFn(destView, destOffset, sample);\n            }\n        }\n    }\n    else {\n        if (srcIsPlanar) {\n            // src planar -> dest interleaved: copy each plane and interleave\n            const planeSize = copyFrameCount * srcBytesPerSample;\n            const data = new ArrayBuffer(planeSize);\n            const dataView = toDataView(data);\n            for (let ch = 0; ch < numChannels; ch++) {\n                audioData.copyTo(data, {\n                    planeIndex: ch,\n                    frameOffset,\n                    frameCount: copyFrameCount,\n                    format: srcFormat,\n                });\n                for (let i = 0; i < copyFrameCount; i++) {\n                    const srcOffset = i * srcBytesPerSample;\n                    const destOffset = (i * numChannels + ch) * destBytesPerSample;\n                    const sample = readFn(dataView, srcOffset);\n                    writeFn(destView, destOffset, sample);\n                }\n            }\n        }\n        else {\n            // src interleaved -> dest interleaved: copy all and convert\n            const data = new ArrayBuffer(copyFrameCount * numChannels * srcBytesPerSample);\n            const dataView = toDataView(data);\n            audioData.copyTo(data, {\n                planeIndex: 0,\n                frameOffset,\n                frameCount: copyFrameCount,\n                format: srcFormat,\n            });\n            for (let i = 0; i < copyFrameCount; i++) {\n                for (let ch = 0; ch < numChannels; ch++) {\n                    const idx = i * numChannels + ch;\n                    const srcOffset = idx * srcBytesPerSample;\n                    const destOffset = idx * destBytesPerSample;\n                    const sample = readFn(dataView, srcOffset);\n                    writeFn(destView, destOffset, sample);\n                }\n            }\n        }\n    }\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { parsePcmCodec, PCM_AUDIO_CODECS } from './codec.js';\nimport { concatAvcNalUnits, deserializeAvcDecoderConfigurationRecord, determineVideoPacketType, extractAvcNalUnits, extractHevcNalUnits, extractNalUnitTypeForAvc, extractNalUnitTypeForHevc, HevcNalUnitType, parseAvcSps, } from './codec-data.js';\nimport { customVideoDecoders, customAudioDecoders } from './custom-coder.js';\nimport { InputDisposedError } from './input.js';\nimport { InputAudioTrack, InputTrack, InputVideoTrack } from './input-track.js';\nimport { assert, assertNever, CallSerializer, getInt24, getUint24, insertSorted, isChromium, isFirefox, isNumber, isWebKit, last, mapAsyncGenerator, promiseWithResolvers, toAsyncIterator, toDataView, toUint8Array, validateAnyIterable, } from './misc.js';\nimport { EncodedPacket } from './packet.js';\nimport { fromAlaw, fromUlaw } from './pcm.js';\nimport { AudioSample, clampCropRectangle, validateCropRectangle, VideoSample } from './sample.js';\nconst validatePacketRetrievalOptions = (options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('options must be an object.');\n    }\n    if (options.metadataOnly !== undefined && typeof options.metadataOnly !== 'boolean') {\n        throw new TypeError('options.metadataOnly, when defined, must be a boolean.');\n    }\n    if (options.verifyKeyPackets !== undefined && typeof options.verifyKeyPackets !== 'boolean') {\n        throw new TypeError('options.verifyKeyPackets, when defined, must be a boolean.');\n    }\n    if (options.verifyKeyPackets && options.metadataOnly) {\n        throw new TypeError('options.verifyKeyPackets and options.metadataOnly cannot be enabled together.');\n    }\n};\nconst validateTimestamp = (timestamp) => {\n    if (!isNumber(timestamp)) {\n        throw new TypeError('timestamp must be a number.'); // It can be non-finite, that's fine\n    }\n};\nconst maybeFixPacketType = (track, promise, options) => {\n    if (options.verifyKeyPackets) {\n        return promise.then(async (packet) => {\n            if (!packet || packet.type === 'delta') {\n                return packet;\n            }\n            const determinedType = await track.determinePacketType(packet);\n            if (determinedType) {\n                // @ts-expect-error Technically readonly\n                packet.type = determinedType;\n            }\n            return packet;\n        });\n    }\n    else {\n        return promise;\n    }\n};\n/**\n * Sink for retrieving encoded packets from an input track.\n * @group Media sinks\n * @public\n */\nexport class EncodedPacketSink {\n    /** Creates a new {@link EncodedPacketSink} for the given {@link InputTrack}. */\n    constructor(track) {\n        if (!(track instanceof InputTrack)) {\n            throw new TypeError('track must be an InputTrack.');\n        }\n        this._track = track;\n    }\n    /**\n     * Retrieves the track's first packet (in decode order), or null if it has no packets. The first packet is very\n     * likely to be a key packet.\n     */\n    getFirstPacket(options = {}) {\n        validatePacketRetrievalOptions(options);\n        if (this._track.input._disposed) {\n            throw new InputDisposedError();\n        }\n        return maybeFixPacketType(this._track, this._track._backing.getFirstPacket(options), options);\n    }\n    /**\n     * Retrieves the packet corresponding to the given timestamp, in seconds. More specifically, returns the last packet\n     * (in presentation order) with a start timestamp less than or equal to the given timestamp. This method can be\n     * used to retrieve a track's last packet using `getPacket(Infinity)`. The method returns null if the timestamp\n     * is before the first packet in the track.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    getPacket(timestamp, options = {}) {\n        validateTimestamp(timestamp);\n        validatePacketRetrievalOptions(options);\n        if (this._track.input._disposed) {\n            throw new InputDisposedError();\n        }\n        return maybeFixPacketType(this._track, this._track._backing.getPacket(timestamp, options), options);\n    }\n    /**\n     * Retrieves the packet following the given packet (in decode order), or null if the given packet is the\n     * last packet.\n     */\n    getNextPacket(packet, options = {}) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        validatePacketRetrievalOptions(options);\n        if (this._track.input._disposed) {\n            throw new InputDisposedError();\n        }\n        return maybeFixPacketType(this._track, this._track._backing.getNextPacket(packet, options), options);\n    }\n    /**\n     * Retrieves the key packet corresponding to the given timestamp, in seconds. More specifically, returns the last\n     * key packet (in presentation order) with a start timestamp less than or equal to the given timestamp. A key packet\n     * is a packet that doesn't require previous packets to be decoded. This method can be used to retrieve a track's\n     * last key packet using `getKeyPacket(Infinity)`. The method returns null if the timestamp is before the first\n     * key packet in the track.\n     *\n     * To ensure that the returned packet is guaranteed to be a real key frame, enable `options.verifyKeyPackets`.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    async getKeyPacket(timestamp, options = {}) {\n        validateTimestamp(timestamp);\n        validatePacketRetrievalOptions(options);\n        if (this._track.input._disposed) {\n            throw new InputDisposedError();\n        }\n        if (!options.verifyKeyPackets) {\n            return this._track._backing.getKeyPacket(timestamp, options);\n        }\n        const packet = await this._track._backing.getKeyPacket(timestamp, options);\n        if (!packet) {\n            return packet;\n        }\n        assert(packet.type === 'key');\n        const determinedType = await this._track.determinePacketType(packet);\n        if (determinedType === 'delta') {\n            // Try returning the previous key packet (in hopes that it's actually a key packet)\n            return this.getKeyPacket(packet.timestamp - 1 / this._track.timeResolution, options);\n        }\n        return packet;\n    }\n    /**\n     * Retrieves the key packet following the given packet (in decode order), or null if the given packet is the last\n     * key packet.\n     *\n     * To ensure that the returned packet is guaranteed to be a real key frame, enable `options.verifyKeyPackets`.\n     */\n    async getNextKeyPacket(packet, options = {}) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        validatePacketRetrievalOptions(options);\n        if (this._track.input._disposed) {\n            throw new InputDisposedError();\n        }\n        if (!options.verifyKeyPackets) {\n            return this._track._backing.getNextKeyPacket(packet, options);\n        }\n        const nextPacket = await this._track._backing.getNextKeyPacket(packet, options);\n        if (!nextPacket) {\n            return nextPacket;\n        }\n        assert(nextPacket.type === 'key');\n        const determinedType = await this._track.determinePacketType(nextPacket);\n        if (determinedType === 'delta') {\n            // Try returning the next key packet (in hopes that it's actually a key packet)\n            return this.getNextKeyPacket(nextPacket, options);\n        }\n        return nextPacket;\n    }\n    /**\n     * Creates an async iterator that yields the packets in this track in decode order. To enable fast iteration, this\n     * method will intelligently preload packets based on the speed of the consumer.\n     *\n     * @param startPacket - (optional) The packet from which iteration should begin. This packet will also be yielded.\n     * @param endTimestamp - (optional) The timestamp at which iteration should end. This packet will _not_ be yielded.\n     */\n    packets(startPacket, endPacket, options = {}) {\n        if (startPacket !== undefined && !(startPacket instanceof EncodedPacket)) {\n            throw new TypeError('startPacket must be an EncodedPacket.');\n        }\n        if (startPacket !== undefined && startPacket.isMetadataOnly && !options?.metadataOnly) {\n            throw new TypeError('startPacket can only be metadata-only if options.metadataOnly is enabled.');\n        }\n        if (endPacket !== undefined && !(endPacket instanceof EncodedPacket)) {\n            throw new TypeError('endPacket must be an EncodedPacket.');\n        }\n        validatePacketRetrievalOptions(options);\n        if (this._track.input._disposed) {\n            throw new InputDisposedError();\n        }\n        const packetQueue = [];\n        let { promise: queueNotEmpty, resolve: onQueueNotEmpty } = promiseWithResolvers();\n        let { promise: queueDequeue, resolve: onQueueDequeue } = promiseWithResolvers();\n        let ended = false;\n        let terminated = false;\n        // This stores errors that are \"out of band\" in the sense that they didn't occur in the normal flow of this\n        // method but instead in a different context. This error should not go unnoticed and must be bubbled up to\n        // the consumer.\n        let outOfBandError = null;\n        const timestamps = [];\n        // The queue should always be big enough to hold 1 second worth of packets\n        const maxQueueSize = () => Math.max(2, timestamps.length);\n        // The following is the \"pump\" process that keeps pumping packets into the queue\n        (async () => {\n            let packet = startPacket ?? await this.getFirstPacket(options);\n            while (packet && !terminated && !this._track.input._disposed) {\n                if (endPacket && packet.sequenceNumber >= endPacket?.sequenceNumber) {\n                    break;\n                }\n                if (packetQueue.length > maxQueueSize()) {\n                    ({ promise: queueDequeue, resolve: onQueueDequeue } = promiseWithResolvers());\n                    await queueDequeue;\n                    continue;\n                }\n                packetQueue.push(packet);\n                onQueueNotEmpty();\n                ({ promise: queueNotEmpty, resolve: onQueueNotEmpty } = promiseWithResolvers());\n                packet = await this.getNextPacket(packet, options);\n            }\n            ended = true;\n            onQueueNotEmpty();\n        })().catch((error) => {\n            if (!outOfBandError) {\n                outOfBandError = error;\n                onQueueNotEmpty();\n            }\n        });\n        const track = this._track;\n        return {\n            async next() {\n                while (true) {\n                    if (track.input._disposed) {\n                        throw new InputDisposedError();\n                    }\n                    else if (terminated) {\n                        return { value: undefined, done: true };\n                    }\n                    else if (outOfBandError) {\n                        throw outOfBandError;\n                    }\n                    else if (packetQueue.length > 0) {\n                        const value = packetQueue.shift();\n                        const now = performance.now();\n                        timestamps.push(now);\n                        while (timestamps.length > 0 && now - timestamps[0] >= 1000) {\n                            timestamps.shift();\n                        }\n                        onQueueDequeue();\n                        return { value, done: false };\n                    }\n                    else if (ended) {\n                        return { value: undefined, done: true };\n                    }\n                    else {\n                        await queueNotEmpty;\n                    }\n                }\n            },\n            async return() {\n                terminated = true;\n                onQueueDequeue();\n                onQueueNotEmpty();\n                return { value: undefined, done: true };\n            },\n            async throw(error) {\n                throw error;\n            },\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n}\nclass DecoderWrapper {\n    constructor(onSample, onError) {\n        this.onSample = onSample;\n        this.onError = onError;\n    }\n}\n/**\n * Base class for decoded media sample sinks.\n * @group Media sinks\n * @public\n */\nexport class BaseMediaSampleSink {\n    /** @internal */\n    mediaSamplesInRange(startTimestamp = 0, endTimestamp = Infinity) {\n        validateTimestamp(startTimestamp);\n        validateTimestamp(endTimestamp);\n        const sampleQueue = [];\n        let firstSampleQueued = false;\n        let lastSample = null;\n        let { promise: queueNotEmpty, resolve: onQueueNotEmpty } = promiseWithResolvers();\n        let { promise: queueDequeue, resolve: onQueueDequeue } = promiseWithResolvers();\n        let decoderIsFlushed = false;\n        let ended = false;\n        let terminated = false;\n        // This stores errors that are \"out of band\" in the sense that they didn't occur in the normal flow of this\n        // method but instead in a different context. This error should not go unnoticed and must be bubbled up to\n        // the consumer.\n        let outOfBandError = null;\n        // The following is the \"pump\" process that keeps pumping packets into the decoder\n        (async () => {\n            const decoder = await this._createDecoder((sample) => {\n                onQueueDequeue();\n                if (sample.timestamp >= endTimestamp) {\n                    ended = true;\n                }\n                if (ended) {\n                    sample.close();\n                    return;\n                }\n                if (lastSample) {\n                    if (sample.timestamp > startTimestamp) {\n                        // We don't know ahead of time what the first first is. This is because the first first is the\n                        // last first whose timestamp is less than or equal to the start timestamp. Therefore we need to\n                        // wait for the first first after the start timestamp, and then we'll know that the previous\n                        // first was the first first.\n                        sampleQueue.push(lastSample);\n                        firstSampleQueued = true;\n                    }\n                    else {\n                        lastSample.close();\n                    }\n                }\n                if (sample.timestamp >= startTimestamp) {\n                    sampleQueue.push(sample);\n                    firstSampleQueued = true;\n                }\n                lastSample = firstSampleQueued ? null : sample;\n                if (sampleQueue.length > 0) {\n                    onQueueNotEmpty();\n                    ({ promise: queueNotEmpty, resolve: onQueueNotEmpty } = promiseWithResolvers());\n                }\n            }, (error) => {\n                if (!outOfBandError) {\n                    outOfBandError = error;\n                    onQueueNotEmpty();\n                }\n            });\n            const packetSink = this._createPacketSink();\n            const keyPacket = await packetSink.getKeyPacket(startTimestamp, { verifyKeyPackets: true })\n                ?? await packetSink.getFirstPacket();\n            let currentPacket = keyPacket;\n            let endPacket = undefined;\n            if (endTimestamp < Infinity) {\n                // When an end timestamp is set, we cannot simply use that for the packet iterator due to out-of-order\n                // frames (B-frames). Instead, we'll need to keep decoding packets until we get a frame that exceeds\n                // this end time. However, we can still put a bound on it: Since key frames are by definition never\n                // out of order, we can stop at the first key frame after the end timestamp.\n                const packet = await packetSink.getPacket(endTimestamp);\n                const keyPacket = !packet\n                    ? null\n                    : packet.type === 'key' && packet.timestamp === endTimestamp\n                        ? packet\n                        : await packetSink.getNextKeyPacket(packet, { verifyKeyPackets: true });\n                if (keyPacket) {\n                    endPacket = keyPacket;\n                }\n            }\n            const packets = packetSink.packets(keyPacket ?? undefined, endPacket);\n            await packets.next(); // Skip the start packet as we already have it\n            while (currentPacket && !ended && !this._track.input._disposed) {\n                const maxQueueSize = computeMaxQueueSize(sampleQueue.length);\n                if (sampleQueue.length + decoder.getDecodeQueueSize() > maxQueueSize) {\n                    ({ promise: queueDequeue, resolve: onQueueDequeue } = promiseWithResolvers());\n                    await queueDequeue;\n                    continue;\n                }\n                decoder.decode(currentPacket);\n                const packetResult = await packets.next();\n                if (packetResult.done) {\n                    break;\n                }\n                currentPacket = packetResult.value;\n            }\n            await packets.return();\n            if (!terminated && !this._track.input._disposed) {\n                await decoder.flush();\n            }\n            decoder.close();\n            if (!firstSampleQueued && lastSample) {\n                sampleQueue.push(lastSample);\n            }\n            decoderIsFlushed = true;\n            onQueueNotEmpty(); // To unstuck the generator\n        })().catch((error) => {\n            if (!outOfBandError) {\n                outOfBandError = error;\n                onQueueNotEmpty();\n            }\n        });\n        const track = this._track;\n        const closeSamples = () => {\n            lastSample?.close();\n            for (const sample of sampleQueue) {\n                sample.close();\n            }\n        };\n        return {\n            async next() {\n                while (true) {\n                    if (track.input._disposed) {\n                        closeSamples();\n                        throw new InputDisposedError();\n                    }\n                    else if (terminated) {\n                        return { value: undefined, done: true };\n                    }\n                    else if (outOfBandError) {\n                        closeSamples();\n                        throw outOfBandError;\n                    }\n                    else if (sampleQueue.length > 0) {\n                        const value = sampleQueue.shift();\n                        onQueueDequeue();\n                        return { value, done: false };\n                    }\n                    else if (!decoderIsFlushed) {\n                        await queueNotEmpty;\n                    }\n                    else {\n                        return { value: undefined, done: true };\n                    }\n                }\n            },\n            async return() {\n                terminated = true;\n                ended = true;\n                onQueueDequeue();\n                onQueueNotEmpty();\n                closeSamples();\n                return { value: undefined, done: true };\n            },\n            async throw(error) {\n                throw error;\n            },\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n    /** @internal */\n    mediaSamplesAtTimestamps(timestamps) {\n        validateAnyIterable(timestamps);\n        const timestampIterator = toAsyncIterator(timestamps);\n        const timestampsOfInterest = [];\n        const sampleQueue = [];\n        let { promise: queueNotEmpty, resolve: onQueueNotEmpty } = promiseWithResolvers();\n        let { promise: queueDequeue, resolve: onQueueDequeue } = promiseWithResolvers();\n        let decoderIsFlushed = false;\n        let terminated = false;\n        // This stores errors that are \"out of band\" in the sense that they didn't occur in the normal flow of this\n        // method but instead in a different context. This error should not go unnoticed and must be bubbled up to\n        // the consumer.\n        let outOfBandError = null;\n        const pushToQueue = (sample) => {\n            sampleQueue.push(sample);\n            onQueueNotEmpty();\n            ({ promise: queueNotEmpty, resolve: onQueueNotEmpty } = promiseWithResolvers());\n        };\n        // The following is the \"pump\" process that keeps pumping packets into the decoder\n        (async () => {\n            const decoder = await this._createDecoder((sample) => {\n                onQueueDequeue();\n                if (terminated) {\n                    sample.close();\n                    return;\n                }\n                let sampleUses = 0;\n                while (timestampsOfInterest.length > 0\n                    && sample.timestamp - timestampsOfInterest[0] > -1e-10 // Give it a little epsilon\n                ) {\n                    sampleUses++;\n                    timestampsOfInterest.shift();\n                }\n                if (sampleUses > 0) {\n                    for (let i = 0; i < sampleUses; i++) {\n                        // Clone the sample if we need to emit it multiple times\n                        pushToQueue((i < sampleUses - 1 ? sample.clone() : sample));\n                    }\n                }\n                else {\n                    sample.close();\n                }\n            }, (error) => {\n                if (!outOfBandError) {\n                    outOfBandError = error;\n                    onQueueNotEmpty();\n                }\n            });\n            const packetSink = this._createPacketSink();\n            let lastPacket = null;\n            let lastKeyPacket = null;\n            // The end sequence number (inclusive) in the next batch of packets that will be decoded. The batch starts\n            // at the last key frame and goes until this sequence number.\n            let maxSequenceNumber = -1;\n            const decodePackets = async () => {\n                assert(lastKeyPacket);\n                // Start at the current key packet\n                let currentPacket = lastKeyPacket;\n                decoder.decode(currentPacket);\n                while (currentPacket.sequenceNumber < maxSequenceNumber) {\n                    const maxQueueSize = computeMaxQueueSize(sampleQueue.length);\n                    while (sampleQueue.length + decoder.getDecodeQueueSize() > maxQueueSize && !terminated) {\n                        ({ promise: queueDequeue, resolve: onQueueDequeue } = promiseWithResolvers());\n                        await queueDequeue;\n                    }\n                    if (terminated) {\n                        break;\n                    }\n                    const nextPacket = await packetSink.getNextPacket(currentPacket);\n                    assert(nextPacket);\n                    decoder.decode(nextPacket);\n                    currentPacket = nextPacket;\n                }\n                maxSequenceNumber = -1;\n            };\n            const flushDecoder = async () => {\n                await decoder.flush();\n                // We don't expect this list to have any elements in it anymore, but in case it does, let's emit\n                // nulls for every remaining element, then clear it.\n                for (let i = 0; i < timestampsOfInterest.length; i++) {\n                    pushToQueue(null);\n                }\n                timestampsOfInterest.length = 0;\n            };\n            for await (const timestamp of timestampIterator) {\n                validateTimestamp(timestamp);\n                if (terminated || this._track.input._disposed) {\n                    break;\n                }\n                const targetPacket = await packetSink.getPacket(timestamp);\n                const keyPacket = targetPacket && await packetSink.getKeyPacket(timestamp, { verifyKeyPackets: true });\n                if (!keyPacket) {\n                    if (maxSequenceNumber !== -1) {\n                        await decodePackets();\n                        await flushDecoder();\n                    }\n                    pushToQueue(null);\n                    lastPacket = null;\n                    continue;\n                }\n                // Check if the key packet has changed or if we're going back in time\n                if (lastPacket\n                    && (keyPacket.sequenceNumber !== lastKeyPacket.sequenceNumber\n                        || targetPacket.timestamp < lastPacket.timestamp)) {\n                    await decodePackets();\n                    await flushDecoder(); // Always flush here, improves decoder compatibility\n                }\n                timestampsOfInterest.push(targetPacket.timestamp);\n                maxSequenceNumber = Math.max(targetPacket.sequenceNumber, maxSequenceNumber);\n                lastPacket = targetPacket;\n                lastKeyPacket = keyPacket;\n            }\n            if (!terminated && !this._track.input._disposed) {\n                if (maxSequenceNumber !== -1) {\n                    // We still need to decode packets\n                    await decodePackets();\n                }\n                await flushDecoder();\n            }\n            decoder.close();\n            decoderIsFlushed = true;\n            onQueueNotEmpty(); // To unstuck the generator\n        })().catch((error) => {\n            if (!outOfBandError) {\n                outOfBandError = error;\n                onQueueNotEmpty();\n            }\n        });\n        const track = this._track;\n        const closeSamples = () => {\n            for (const sample of sampleQueue) {\n                sample?.close();\n            }\n        };\n        return {\n            async next() {\n                while (true) {\n                    if (track.input._disposed) {\n                        closeSamples();\n                        throw new InputDisposedError();\n                    }\n                    else if (terminated) {\n                        return { value: undefined, done: true };\n                    }\n                    else if (outOfBandError) {\n                        closeSamples();\n                        throw outOfBandError;\n                    }\n                    else if (sampleQueue.length > 0) {\n                        const value = sampleQueue.shift();\n                        assert(value !== undefined);\n                        onQueueDequeue();\n                        return { value, done: false };\n                    }\n                    else if (!decoderIsFlushed) {\n                        await queueNotEmpty;\n                    }\n                    else {\n                        return { value: undefined, done: true };\n                    }\n                }\n            },\n            async return() {\n                terminated = true;\n                onQueueDequeue();\n                onQueueNotEmpty();\n                closeSamples();\n                return { value: undefined, done: true };\n            },\n            async throw(error) {\n                throw error;\n            },\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n}\nconst computeMaxQueueSize = (decodedSampleQueueSize) => {\n    // If we have decoded samples lying around, limit the total queue size to a small value (decoded samples can use up\n    // a lot of memory). If not, we're fine with a much bigger queue of encoded packets waiting to be decoded. In fact,\n    // some decoders only start flushing out decoded chunks when the packet queue is large enough.\n    return decodedSampleQueueSize === 0 ? 40 : 8;\n};\nclass VideoDecoderWrapper extends DecoderWrapper {\n    constructor(onSample, onError, codec, decoderConfig, rotation, timeResolution) {\n        super(onSample, onError);\n        this.codec = codec;\n        this.decoderConfig = decoderConfig;\n        this.rotation = rotation;\n        this.timeResolution = timeResolution;\n        this.decoder = null;\n        this.customDecoder = null;\n        this.customDecoderCallSerializer = new CallSerializer();\n        this.customDecoderQueueSize = 0;\n        this.inputTimestamps = []; // Timestamps input into the decoder, sorted.\n        this.sampleQueue = []; // Safari-specific thing, check usage.\n        this.currentPacketIndex = 0;\n        this.raslSkipped = false; // For HEVC stuff\n        // Alpha stuff\n        this.alphaDecoder = null;\n        this.alphaHadKeyframe = false;\n        this.colorQueue = [];\n        this.alphaQueue = [];\n        this.merger = null;\n        this.mergerCreationFailed = false;\n        this.decodedAlphaChunkCount = 0;\n        this.alphaDecoderQueueSize = 0;\n        /** Each value is the number of decoded alpha chunks at which a null alpha frame should be added. */\n        this.nullAlphaFrameQueue = [];\n        this.currentAlphaPacketIndex = 0;\n        this.alphaRaslSkipped = false; // For HEVC stuff\n        const MatchingCustomDecoder = customVideoDecoders.find(x => x.supports(codec, decoderConfig));\n        if (MatchingCustomDecoder) {\n            // @ts-expect-error \"Can't create instance of abstract class \"\n            this.customDecoder = new MatchingCustomDecoder();\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.codec = codec;\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.config = decoderConfig;\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.onSample = (sample) => {\n                if (!(sample instanceof VideoSample)) {\n                    throw new TypeError('The argument passed to onSample must be a VideoSample.');\n                }\n                this.finalizeAndEmitSample(sample);\n            };\n            void this.customDecoderCallSerializer.call(() => this.customDecoder.init());\n        }\n        else {\n            const colorHandler = (frame) => {\n                if (this.alphaQueue.length > 0) {\n                    // Even when no alpha data is present (most of the time), there will be nulls in this queue\n                    const alphaFrame = this.alphaQueue.shift();\n                    assert(alphaFrame !== undefined);\n                    this.mergeAlpha(frame, alphaFrame);\n                }\n                else {\n                    this.colorQueue.push(frame);\n                }\n            };\n            if (codec === 'avc' && this.decoderConfig.description && isChromium()) {\n                // Chromium has/had a bug with playing interlaced AVC (https://issues.chromium.org/issues/456919096)\n                // which can be worked around by requesting that software decoding be used. So, here we peek into the\n                // AVC description, if present, and switch to software decoding if we find interlaced content.\n                const record = deserializeAvcDecoderConfigurationRecord(toUint8Array(this.decoderConfig.description));\n                if (record && record.sequenceParameterSets.length > 0) {\n                    const sps = parseAvcSps(record.sequenceParameterSets[0]);\n                    if (sps && sps.frameMbsOnlyFlag === 0) {\n                        this.decoderConfig = {\n                            ...this.decoderConfig,\n                            hardwareAcceleration: 'prefer-software',\n                        };\n                    }\n                }\n            }\n            const stack = new Error('Decoding error').stack;\n            this.decoder = new VideoDecoder({\n                output: (frame) => {\n                    try {\n                        colorHandler(frame);\n                    }\n                    catch (error) {\n                        this.onError(error);\n                    }\n                },\n                error: (error) => {\n                    error.stack = stack; // Provide a more useful stack trace, the default one sucks\n                    this.onError(error);\n                },\n            });\n            this.decoder.configure(this.decoderConfig);\n        }\n    }\n    getDecodeQueueSize() {\n        if (this.customDecoder) {\n            return this.customDecoderQueueSize;\n        }\n        else {\n            assert(this.decoder);\n            return Math.max(this.decoder.decodeQueueSize, this.alphaDecoder?.decodeQueueSize ?? 0);\n        }\n    }\n    decode(packet) {\n        if (this.codec === 'hevc' && this.currentPacketIndex > 0 && !this.raslSkipped) {\n            if (this.hasHevcRaslPicture(packet.data)) {\n                return; // Drop\n            }\n            this.raslSkipped = true;\n        }\n        if (this.customDecoder) {\n            this.customDecoderQueueSize++;\n            void this.customDecoderCallSerializer\n                .call(() => this.customDecoder.decode(packet))\n                .then(() => this.customDecoderQueueSize--);\n        }\n        else {\n            assert(this.decoder);\n            if (!isWebKit()) {\n                insertSorted(this.inputTimestamps, packet.timestamp, x => x);\n            }\n            // Workaround for https://issues.chromium.org/issues/470109459\n            if (isChromium() && this.currentPacketIndex === 0 && this.codec === 'avc') {\n                const nalUnits = extractAvcNalUnits(packet.data, this.decoderConfig);\n                const filteredNalUnits = nalUnits.filter((x) => {\n                    const type = extractNalUnitTypeForAvc(x);\n                    // These trip up Chromium's key frame detection, so let's strip them\n                    return !(type >= 20 && type <= 31);\n                });\n                const newData = concatAvcNalUnits(filteredNalUnits, this.decoderConfig);\n                packet = new EncodedPacket(newData, packet.type, packet.timestamp, packet.duration);\n            }\n            this.decoder.decode(packet.toEncodedVideoChunk());\n            this.decodeAlphaData(packet);\n        }\n        this.currentPacketIndex++;\n    }\n    decodeAlphaData(packet) {\n        if (!packet.sideData.alpha || this.mergerCreationFailed) {\n            // No alpha side data in the packet, most common case\n            this.pushNullAlphaFrame();\n            return;\n        }\n        if (!this.merger) {\n            try {\n                this.merger = new ColorAlphaMerger();\n            }\n            catch (error) {\n                console.error('Due to an error, only color data will be decoded.', error);\n                this.mergerCreationFailed = true;\n                this.decodeAlphaData(packet); // Go again\n                return;\n            }\n        }\n        // Check if we need to set up the alpha decoder\n        if (!this.alphaDecoder) {\n            const alphaHandler = (frame) => {\n                this.alphaDecoderQueueSize--;\n                if (this.colorQueue.length > 0) {\n                    const colorFrame = this.colorQueue.shift();\n                    assert(colorFrame !== undefined);\n                    this.mergeAlpha(colorFrame, frame);\n                }\n                else {\n                    this.alphaQueue.push(frame);\n                }\n                // Check if any null frames have been queued for this point\n                this.decodedAlphaChunkCount++;\n                while (this.nullAlphaFrameQueue.length > 0\n                    && this.nullAlphaFrameQueue[0] === this.decodedAlphaChunkCount) {\n                    this.nullAlphaFrameQueue.shift();\n                    if (this.colorQueue.length > 0) {\n                        const colorFrame = this.colorQueue.shift();\n                        assert(colorFrame !== undefined);\n                        this.mergeAlpha(colorFrame, null);\n                    }\n                    else {\n                        this.alphaQueue.push(null);\n                    }\n                }\n            };\n            const stack = new Error('Decoding error').stack;\n            this.alphaDecoder = new VideoDecoder({\n                output: (frame) => {\n                    try {\n                        alphaHandler(frame);\n                    }\n                    catch (error) {\n                        this.onError(error);\n                    }\n                },\n                error: (error) => {\n                    error.stack = stack; // Provide a more useful stack trace, the default one sucks\n                    this.onError(error);\n                },\n            });\n            this.alphaDecoder.configure(this.decoderConfig);\n        }\n        const type = determineVideoPacketType(this.codec, this.decoderConfig, packet.sideData.alpha);\n        // Alpha packets might follow a different key frame rhythm than the main packets. Therefore, before we start\n        // decoding, we must first find a packet that's actually a key frame. Until then, we treat the image as opaque.\n        if (!this.alphaHadKeyframe) {\n            this.alphaHadKeyframe = type === 'key';\n        }\n        if (this.alphaHadKeyframe) {\n            // Same RASL skipping logic as for color, unlikely to be hit (since who uses HEVC with separate alpha??) but\n            // here for symmetry.\n            if (this.codec === 'hevc' && this.currentAlphaPacketIndex > 0 && !this.alphaRaslSkipped) {\n                if (this.hasHevcRaslPicture(packet.sideData.alpha)) {\n                    this.pushNullAlphaFrame();\n                    return;\n                }\n                this.alphaRaslSkipped = true;\n            }\n            this.currentAlphaPacketIndex++;\n            this.alphaDecoder.decode(packet.alphaToEncodedVideoChunk(type ?? packet.type));\n            this.alphaDecoderQueueSize++;\n        }\n        else {\n            this.pushNullAlphaFrame();\n        }\n    }\n    pushNullAlphaFrame() {\n        if (this.alphaDecoderQueueSize === 0) {\n            // Easy\n            this.alphaQueue.push(null);\n        }\n        else {\n            // There are still alpha chunks being decoded, so pushing `null` immediately would result in out-of-order\n            // data and be incorrect. Instead, we need to enqueue a \"null frame\" for when the current decoder workload\n            // has finished.\n            this.nullAlphaFrameQueue.push(this.decodedAlphaChunkCount + this.alphaDecoderQueueSize);\n        }\n    }\n    /**\n     * If we're using HEVC, we need to make sure to skip any RASL slices that follow a non-IDR key frame such as\n     * CRA_NUT. This is because RASL slices cannot be decoded without data before the CRA_NUT. Browsers behave\n     * differently here: Chromium drops the packets, Safari throws a decoder error. Either way, it's not good\n     * and causes bugs upstream. So, let's take the dropping into our own hands.\n     */\n    hasHevcRaslPicture(packetData) {\n        const nalUnits = extractHevcNalUnits(packetData, this.decoderConfig);\n        return nalUnits.some((x) => {\n            const type = extractNalUnitTypeForHevc(x);\n            return type === HevcNalUnitType.RASL_N || type === HevcNalUnitType.RASL_R;\n        });\n    }\n    /** Handler for the WebCodecs VideoDecoder for ironing out browser differences. */\n    sampleHandler(sample) {\n        if (isWebKit()) {\n            // For correct B-frame handling, we don't just hand over the frames directly but instead add them to\n            // a queue, because we want to ensure frames are emitted in presentation order. We flush the queue\n            // each time we receive a frame with a timestamp larger than the highest we've seen so far, as we\n            // can sure that is not a B-frame. Typically, WebCodecs automatically guarantees that frames are\n            // emitted in presentation order, but Safari doesn't always follow this rule.\n            if (this.sampleQueue.length > 0 && (sample.timestamp >= last(this.sampleQueue).timestamp)) {\n                for (const sample of this.sampleQueue) {\n                    this.finalizeAndEmitSample(sample);\n                }\n                this.sampleQueue.length = 0;\n            }\n            insertSorted(this.sampleQueue, sample, x => x.timestamp);\n        }\n        else {\n            // Assign it the next earliest timestamp from the input. We do this because browsers, by spec, are\n            // required to emit decoded frames in presentation order *while* retaining the timestamp of their\n            // originating EncodedVideoChunk. For files with B-frames but no out-of-order timestamps (like a\n            // missing ctts box, for example), this causes a mismatch. We therefore fix the timestamps and\n            // ensure they are sorted by doing this.\n            const timestamp = this.inputTimestamps.shift();\n            // There's no way we'd have more decoded frames than encoded packets we passed in. Actually, the\n            // correspondence should be 1:1.\n            assert(timestamp !== undefined);\n            sample.setTimestamp(timestamp);\n            this.finalizeAndEmitSample(sample);\n        }\n    }\n    finalizeAndEmitSample(sample) {\n        // Round the timestamps to the time resolution\n        sample.setTimestamp(Math.round(sample.timestamp * this.timeResolution) / this.timeResolution);\n        sample.setDuration(Math.round(sample.duration * this.timeResolution) / this.timeResolution);\n        sample.setRotation(this.rotation);\n        this.onSample(sample);\n    }\n    mergeAlpha(color, alpha) {\n        if (!alpha) {\n            // Nothing needs to be merged\n            const finalSample = new VideoSample(color);\n            this.sampleHandler(finalSample);\n            return;\n        }\n        assert(this.merger);\n        this.merger.update(color, alpha);\n        color.close();\n        alpha.close();\n        const finalFrame = new VideoFrame(this.merger.canvas, {\n            timestamp: color.timestamp,\n            duration: color.duration ?? undefined,\n        });\n        const finalSample = new VideoSample(finalFrame);\n        this.sampleHandler(finalSample);\n    }\n    async flush() {\n        if (this.customDecoder) {\n            await this.customDecoderCallSerializer.call(() => this.customDecoder.flush());\n        }\n        else {\n            assert(this.decoder);\n            await Promise.all([\n                this.decoder.flush(),\n                this.alphaDecoder?.flush(),\n            ]);\n            this.colorQueue.forEach(x => x.close());\n            this.colorQueue.length = 0;\n            this.alphaQueue.forEach(x => x?.close());\n            this.alphaQueue.length = 0;\n            this.alphaHadKeyframe = false;\n            this.decodedAlphaChunkCount = 0;\n            this.alphaDecoderQueueSize = 0;\n            this.nullAlphaFrameQueue.length = 0;\n            this.currentAlphaPacketIndex = 0;\n            this.alphaRaslSkipped = false;\n        }\n        if (isWebKit()) {\n            for (const sample of this.sampleQueue) {\n                this.finalizeAndEmitSample(sample);\n            }\n            this.sampleQueue.length = 0;\n        }\n        this.currentPacketIndex = 0;\n        this.raslSkipped = false;\n    }\n    close() {\n        if (this.customDecoder) {\n            void this.customDecoderCallSerializer.call(() => this.customDecoder.close());\n        }\n        else {\n            assert(this.decoder);\n            this.decoder.close();\n            this.alphaDecoder?.close();\n            this.colorQueue.forEach(x => x.close());\n            this.colorQueue.length = 0;\n            this.alphaQueue.forEach(x => x?.close());\n            this.alphaQueue.length = 0;\n            this.merger?.close();\n        }\n        for (const sample of this.sampleQueue) {\n            sample.close();\n        }\n        this.sampleQueue.length = 0;\n    }\n}\n/** Utility class that merges together color and alpha information using simple WebGL 2 shaders. */\nclass ColorAlphaMerger {\n    constructor() {\n        // Canvas will be resized later\n        if (typeof OffscreenCanvas !== 'undefined') {\n            // Prefer OffscreenCanvas for Worker environments\n            this.canvas = new OffscreenCanvas(300, 150);\n        }\n        else {\n            this.canvas = document.createElement('canvas');\n        }\n        const gl = this.canvas.getContext('webgl2', {\n            premultipliedAlpha: false,\n        }); // Casting because of some TypeScript weirdness\n        if (!gl) {\n            throw new Error('Couldn\\'t acquire WebGL 2 context.');\n        }\n        this.gl = gl;\n        this.program = this.createProgram();\n        this.vao = this.createVAO();\n        this.colorTexture = this.createTexture();\n        this.alphaTexture = this.createTexture();\n        this.gl.useProgram(this.program);\n        this.gl.uniform1i(this.gl.getUniformLocation(this.program, 'u_colorTexture'), 0);\n        this.gl.uniform1i(this.gl.getUniformLocation(this.program, 'u_alphaTexture'), 1);\n    }\n    createProgram() {\n        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, `#version 300 es\n\t\t\tin vec2 a_position;\n\t\t\tin vec2 a_texCoord;\n\t\t\tout vec2 v_texCoord;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tgl_Position = vec4(a_position, 0.0, 1.0);\n\t\t\t\tv_texCoord = a_texCoord;\n\t\t\t}\n\t\t`);\n        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, `#version 300 es\n\t\t\tprecision highp float;\n\t\t\t\n\t\t\tuniform sampler2D u_colorTexture;\n\t\t\tuniform sampler2D u_alphaTexture;\n\t\t\tin vec2 v_texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tvec3 color = texture(u_colorTexture, v_texCoord).rgb;\n\t\t\t\tfloat alpha = texture(u_alphaTexture, v_texCoord).r;\n\t\t\t\tfragColor = vec4(color, alpha);\n\t\t\t}\n\t\t`);\n        const program = this.gl.createProgram();\n        this.gl.attachShader(program, vertexShader);\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.linkProgram(program);\n        return program;\n    }\n    createShader(type, source) {\n        const shader = this.gl.createShader(type);\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        return shader;\n    }\n    createVAO() {\n        const vao = this.gl.createVertexArray();\n        this.gl.bindVertexArray(vao);\n        const vertices = new Float32Array([\n            -1, -1, 0, 1,\n            1, -1, 1, 1,\n            -1, 1, 0, 0,\n            1, 1, 1, 0,\n        ]);\n        const buffer = this.gl.createBuffer();\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);\n        const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');\n        const texCoordLocation = this.gl.getAttribLocation(this.program, 'a_texCoord');\n        this.gl.enableVertexAttribArray(positionLocation);\n        this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 16, 0);\n        this.gl.enableVertexAttribArray(texCoordLocation);\n        this.gl.vertexAttribPointer(texCoordLocation, 2, this.gl.FLOAT, false, 16, 8);\n        return vao;\n    }\n    createTexture() {\n        const texture = this.gl.createTexture();\n        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n        return texture;\n    }\n    update(color, alpha) {\n        if (color.displayWidth !== this.canvas.width || color.displayHeight !== this.canvas.height) {\n            this.canvas.width = color.displayWidth;\n            this.canvas.height = color.displayHeight;\n        }\n        this.gl.activeTexture(this.gl.TEXTURE0);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.colorTexture);\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, color);\n        this.gl.activeTexture(this.gl.TEXTURE1);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.alphaTexture);\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, alpha);\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.bindVertexArray(this.vao);\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n    }\n    close() {\n        this.gl.getExtension('WEBGL_lose_context')?.loseContext();\n        this.gl = null;\n    }\n}\n/**\n * A sink that retrieves decoded video samples (video frames) from a video track.\n * @group Media sinks\n * @public\n */\nexport class VideoSampleSink extends BaseMediaSampleSink {\n    /** Creates a new {@link VideoSampleSink} for the given {@link InputVideoTrack}. */\n    constructor(videoTrack) {\n        if (!(videoTrack instanceof InputVideoTrack)) {\n            throw new TypeError('videoTrack must be an InputVideoTrack.');\n        }\n        super();\n        this._track = videoTrack;\n    }\n    /** @internal */\n    async _createDecoder(onSample, onError) {\n        if (!(await this._track.canDecode())) {\n            throw new Error('This video track cannot be decoded by this browser. Make sure to check decodability before using'\n                + ' a track.');\n        }\n        const codec = this._track.codec;\n        const rotation = this._track.rotation;\n        const decoderConfig = await this._track.getDecoderConfig();\n        const timeResolution = this._track.timeResolution;\n        assert(codec && decoderConfig);\n        return new VideoDecoderWrapper(onSample, onError, codec, decoderConfig, rotation, timeResolution);\n    }\n    /** @internal */\n    _createPacketSink() {\n        return new EncodedPacketSink(this._track);\n    }\n    /**\n     * Retrieves the video sample (frame) corresponding to the given timestamp, in seconds. More specifically, returns\n     * the last video sample (in presentation order) with a start timestamp less than or equal to the given timestamp.\n     * Returns null if the timestamp is before the track's first timestamp.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    async getSample(timestamp) {\n        validateTimestamp(timestamp);\n        for await (const sample of this.mediaSamplesAtTimestamps([timestamp])) {\n            return sample;\n        }\n        throw new Error('Internal error: Iterator returned nothing.');\n    }\n    /**\n     * Creates an async iterator that yields the video samples (frames) of this track in presentation order. This method\n     * will intelligently pre-decode a few frames ahead to enable fast iteration.\n     *\n     * @param startTimestamp - The timestamp in seconds at which to start yielding samples (inclusive).\n     * @param endTimestamp - The timestamp in seconds at which to stop yielding samples (exclusive).\n     */\n    samples(startTimestamp = 0, endTimestamp = Infinity) {\n        return this.mediaSamplesInRange(startTimestamp, endTimestamp);\n    }\n    /**\n     * Creates an async iterator that yields a video sample (frame) for each timestamp in the argument. This method\n     * uses an optimized decoding pipeline if these timestamps are monotonically sorted, decoding each packet at most\n     * once, and is therefore more efficient than manually getting the sample for every timestamp. The iterator may\n     * yield null if no frame is available for a given timestamp.\n     *\n     * @param timestamps - An iterable or async iterable of timestamps in seconds.\n     */\n    samplesAtTimestamps(timestamps) {\n        return this.mediaSamplesAtTimestamps(timestamps);\n    }\n}\n/**\n * A sink that renders video samples (frames) of the given video track to canvases. This is often more useful than\n * directly retrieving frames, as it comes with common preprocessing steps such as resizing or applying rotation\n * metadata.\n *\n * This sink will yield `HTMLCanvasElement`s when in a DOM context, and `OffscreenCanvas`es otherwise.\n *\n * @group Media sinks\n * @public\n */\nexport class CanvasSink {\n    /** Creates a new {@link CanvasSink} for the given {@link InputVideoTrack}. */\n    constructor(videoTrack, options = {}) {\n        /** @internal */\n        this._nextCanvasIndex = 0;\n        if (!(videoTrack instanceof InputVideoTrack)) {\n            throw new TypeError('videoTrack must be an InputVideoTrack.');\n        }\n        if (options && typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.alpha !== undefined && typeof options.alpha !== 'boolean') {\n            throw new TypeError('options.alpha, when provided, must be a boolean.');\n        }\n        if (options.width !== undefined && (!Number.isInteger(options.width) || options.width <= 0)) {\n            throw new TypeError('options.width, when defined, must be a positive integer.');\n        }\n        if (options.height !== undefined && (!Number.isInteger(options.height) || options.height <= 0)) {\n            throw new TypeError('options.height, when defined, must be a positive integer.');\n        }\n        if (options.fit !== undefined && !['fill', 'contain', 'cover'].includes(options.fit)) {\n            throw new TypeError('options.fit, when provided, must be one of \"fill\", \"contain\", or \"cover\".');\n        }\n        if (options.width !== undefined\n            && options.height !== undefined\n            && options.fit === undefined) {\n            throw new TypeError('When both options.width and options.height are provided, options.fit must also be provided.');\n        }\n        if (options.rotation !== undefined && ![0, 90, 180, 270].includes(options.rotation)) {\n            throw new TypeError('options.rotation, when provided, must be 0, 90, 180 or 270.');\n        }\n        if (options.crop !== undefined) {\n            validateCropRectangle(options.crop, 'options.');\n        }\n        if (options.poolSize !== undefined\n            && (typeof options.poolSize !== 'number' || !Number.isInteger(options.poolSize) || options.poolSize < 0)) {\n            throw new TypeError('poolSize must be a non-negative integer.');\n        }\n        const rotation = options.rotation ?? videoTrack.rotation;\n        const [rotatedWidth, rotatedHeight] = rotation % 180 === 0\n            ? [videoTrack.codedWidth, videoTrack.codedHeight]\n            : [videoTrack.codedHeight, videoTrack.codedWidth];\n        const crop = options.crop;\n        if (crop) {\n            clampCropRectangle(crop, rotatedWidth, rotatedHeight);\n        }\n        let [width, height] = crop\n            ? [crop.width, crop.height]\n            : [rotatedWidth, rotatedHeight];\n        const originalAspectRatio = width / height;\n        // If width and height aren't defined together, deduce the missing value using the aspect ratio\n        if (options.width !== undefined && options.height === undefined) {\n            width = options.width;\n            height = Math.round(width / originalAspectRatio);\n        }\n        else if (options.width === undefined && options.height !== undefined) {\n            height = options.height;\n            width = Math.round(height * originalAspectRatio);\n        }\n        else if (options.width !== undefined && options.height !== undefined) {\n            width = options.width;\n            height = options.height;\n        }\n        this._videoTrack = videoTrack;\n        this._alpha = options.alpha ?? false;\n        this._width = width;\n        this._height = height;\n        this._rotation = rotation;\n        this._crop = crop;\n        this._fit = options.fit ?? 'fill';\n        this._videoSampleSink = new VideoSampleSink(videoTrack);\n        this._canvasPool = Array.from({ length: options.poolSize ?? 0 }, () => null);\n    }\n    /** @internal */\n    _videoSampleToWrappedCanvas(sample) {\n        let canvas = this._canvasPool[this._nextCanvasIndex];\n        let canvasIsNew = false;\n        if (!canvas) {\n            if (typeof document !== 'undefined') {\n                // Prefer an HTMLCanvasElement\n                canvas = document.createElement('canvas');\n                canvas.width = this._width;\n                canvas.height = this._height;\n            }\n            else {\n                canvas = new OffscreenCanvas(this._width, this._height);\n            }\n            if (this._canvasPool.length > 0) {\n                this._canvasPool[this._nextCanvasIndex] = canvas;\n            }\n            canvasIsNew = true;\n        }\n        if (this._canvasPool.length > 0) {\n            this._nextCanvasIndex = (this._nextCanvasIndex + 1) % this._canvasPool.length;\n        }\n        const context = canvas.getContext('2d', {\n            alpha: this._alpha || isFirefox(), // Firefox has VideoFrame glitches with opaque canvases\n        });\n        assert(context);\n        context.resetTransform();\n        if (!canvasIsNew) {\n            if (!this._alpha && isFirefox()) {\n                context.fillStyle = 'black';\n                context.fillRect(0, 0, this._width, this._height);\n            }\n            else {\n                context.clearRect(0, 0, this._width, this._height);\n            }\n        }\n        sample.drawWithFit(context, {\n            fit: this._fit,\n            rotation: this._rotation,\n            crop: this._crop,\n        });\n        const result = {\n            canvas,\n            timestamp: sample.timestamp,\n            duration: sample.duration,\n        };\n        sample.close();\n        return result;\n    }\n    /**\n     * Retrieves a canvas with the video frame corresponding to the given timestamp, in seconds. More specifically,\n     * returns the last video frame (in presentation order) with a start timestamp less than or equal to the given\n     * timestamp. Returns null if the timestamp is before the track's first timestamp.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    async getCanvas(timestamp) {\n        validateTimestamp(timestamp);\n        const sample = await this._videoSampleSink.getSample(timestamp);\n        return sample && this._videoSampleToWrappedCanvas(sample);\n    }\n    /**\n     * Creates an async iterator that yields canvases with the video frames of this track in presentation order. This\n     * method will intelligently pre-decode a few frames ahead to enable fast iteration.\n     *\n     * @param startTimestamp - The timestamp in seconds at which to start yielding canvases (inclusive).\n     * @param endTimestamp - The timestamp in seconds at which to stop yielding canvases (exclusive).\n     */\n    canvases(startTimestamp = 0, endTimestamp = Infinity) {\n        return mapAsyncGenerator(this._videoSampleSink.samples(startTimestamp, endTimestamp), sample => this._videoSampleToWrappedCanvas(sample));\n    }\n    /**\n     * Creates an async iterator that yields a canvas for each timestamp in the argument. This method uses an optimized\n     * decoding pipeline if these timestamps are monotonically sorted, decoding each packet at most once, and is\n     * therefore more efficient than manually getting the canvas for every timestamp. The iterator may yield null if\n     * no frame is available for a given timestamp.\n     *\n     * @param timestamps - An iterable or async iterable of timestamps in seconds.\n     */\n    canvasesAtTimestamps(timestamps) {\n        return mapAsyncGenerator(this._videoSampleSink.samplesAtTimestamps(timestamps), sample => sample && this._videoSampleToWrappedCanvas(sample));\n    }\n}\nclass AudioDecoderWrapper extends DecoderWrapper {\n    constructor(onSample, onError, codec, decoderConfig) {\n        super(onSample, onError);\n        this.decoder = null;\n        this.customDecoder = null;\n        this.customDecoderCallSerializer = new CallSerializer();\n        this.customDecoderQueueSize = 0;\n        // Internal state to accumulate a precise current timestamp based on audio durations, not the (potentially\n        // inaccurate) packet timestamps.\n        this.currentTimestamp = null;\n        const sampleHandler = (sample) => {\n            if (this.currentTimestamp === null\n                || Math.abs(sample.timestamp - this.currentTimestamp) >= sample.duration) {\n                // We need to sync with the sample timestamp again\n                this.currentTimestamp = sample.timestamp;\n            }\n            const preciseTimestamp = this.currentTimestamp;\n            this.currentTimestamp += sample.duration;\n            if (sample.numberOfFrames === 0) {\n                // We skip zero-data (empty) AudioSamples. These are sometimes emitted, for example, by Firefox when it\n                // decodes Vorbis (at the start).\n                sample.close();\n                return;\n            }\n            // Round the timestamp to the sample rate\n            const sampleRate = decoderConfig.sampleRate;\n            sample.setTimestamp(Math.round(preciseTimestamp * sampleRate) / sampleRate);\n            onSample(sample);\n        };\n        const MatchingCustomDecoder = customAudioDecoders.find(x => x.supports(codec, decoderConfig));\n        if (MatchingCustomDecoder) {\n            // @ts-expect-error \"Can't create instance of abstract class \"\n            this.customDecoder = new MatchingCustomDecoder();\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.codec = codec;\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.config = decoderConfig;\n            // @ts-expect-error It's technically readonly\n            this.customDecoder.onSample = (sample) => {\n                if (!(sample instanceof AudioSample)) {\n                    throw new TypeError('The argument passed to onSample must be an AudioSample.');\n                }\n                sampleHandler(sample);\n            };\n            void this.customDecoderCallSerializer.call(() => this.customDecoder.init());\n        }\n        else {\n            const stack = new Error('Decoding error').stack;\n            this.decoder = new AudioDecoder({\n                output: (data) => {\n                    try {\n                        sampleHandler(new AudioSample(data));\n                    }\n                    catch (error) {\n                        this.onError(error);\n                    }\n                },\n                error: (error) => {\n                    error.stack = stack; // Provide a more useful stack trace, the default one sucks\n                    this.onError(error);\n                },\n            });\n            this.decoder.configure(decoderConfig);\n        }\n    }\n    getDecodeQueueSize() {\n        if (this.customDecoder) {\n            return this.customDecoderQueueSize;\n        }\n        else {\n            assert(this.decoder);\n            return this.decoder.decodeQueueSize;\n        }\n    }\n    decode(packet) {\n        if (this.customDecoder) {\n            this.customDecoderQueueSize++;\n            void this.customDecoderCallSerializer\n                .call(() => this.customDecoder.decode(packet))\n                .then(() => this.customDecoderQueueSize--);\n        }\n        else {\n            assert(this.decoder);\n            this.decoder.decode(packet.toEncodedAudioChunk());\n        }\n    }\n    flush() {\n        if (this.customDecoder) {\n            return this.customDecoderCallSerializer.call(() => this.customDecoder.flush());\n        }\n        else {\n            assert(this.decoder);\n            return this.decoder.flush();\n        }\n    }\n    close() {\n        if (this.customDecoder) {\n            void this.customDecoderCallSerializer.call(() => this.customDecoder.close());\n        }\n        else {\n            assert(this.decoder);\n            this.decoder.close();\n        }\n    }\n}\n// There are a lot of PCM variants not natively supported by the browser and by AudioData. Therefore we need a simple\n// decoder that maps any input PCM format into a PCM format supported by the browser.\nclass PcmAudioDecoderWrapper extends DecoderWrapper {\n    constructor(onSample, onError, decoderConfig) {\n        super(onSample, onError);\n        this.decoderConfig = decoderConfig;\n        // Internal state to accumulate a precise current timestamp based on audio durations, not the (potentially\n        // inaccurate) packet timestamps.\n        this.currentTimestamp = null;\n        assert(PCM_AUDIO_CODECS.includes(decoderConfig.codec));\n        this.codec = decoderConfig.codec;\n        const { dataType, sampleSize, littleEndian } = parsePcmCodec(this.codec);\n        this.inputSampleSize = sampleSize;\n        switch (sampleSize) {\n            case 1:\n                {\n                    if (dataType === 'unsigned') {\n                        this.readInputValue = (view, byteOffset) => view.getUint8(byteOffset) - 2 ** 7;\n                    }\n                    else if (dataType === 'signed') {\n                        this.readInputValue = (view, byteOffset) => view.getInt8(byteOffset);\n                    }\n                    else if (dataType === 'ulaw') {\n                        this.readInputValue = (view, byteOffset) => fromUlaw(view.getUint8(byteOffset));\n                    }\n                    else if (dataType === 'alaw') {\n                        this.readInputValue = (view, byteOffset) => fromAlaw(view.getUint8(byteOffset));\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 2:\n                {\n                    if (dataType === 'unsigned') {\n                        this.readInputValue = (view, byteOffset) => view.getUint16(byteOffset, littleEndian) - 2 ** 15;\n                    }\n                    else if (dataType === 'signed') {\n                        this.readInputValue = (view, byteOffset) => view.getInt16(byteOffset, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 3:\n                {\n                    if (dataType === 'unsigned') {\n                        this.readInputValue = (view, byteOffset) => getUint24(view, byteOffset, littleEndian) - 2 ** 23;\n                    }\n                    else if (dataType === 'signed') {\n                        this.readInputValue = (view, byteOffset) => getInt24(view, byteOffset, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 4:\n                {\n                    if (dataType === 'unsigned') {\n                        this.readInputValue = (view, byteOffset) => view.getUint32(byteOffset, littleEndian) - 2 ** 31;\n                    }\n                    else if (dataType === 'signed') {\n                        this.readInputValue = (view, byteOffset) => view.getInt32(byteOffset, littleEndian);\n                    }\n                    else if (dataType === 'float') {\n                        this.readInputValue = (view, byteOffset) => view.getFloat32(byteOffset, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 8:\n                {\n                    if (dataType === 'float') {\n                        this.readInputValue = (view, byteOffset) => view.getFloat64(byteOffset, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            default:\n                {\n                    assertNever(sampleSize);\n                    assert(false);\n                }\n                ;\n        }\n        switch (sampleSize) {\n            case 1:\n                {\n                    if (dataType === 'ulaw' || dataType === 'alaw') {\n                        this.outputSampleSize = 2;\n                        this.outputFormat = 's16';\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt16(byteOffset, value, true);\n                    }\n                    else {\n                        this.outputSampleSize = 1;\n                        this.outputFormat = 'u8';\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint8(byteOffset, value + 2 ** 7);\n                    }\n                }\n                ;\n                break;\n            case 2:\n                {\n                    this.outputSampleSize = 2;\n                    this.outputFormat = 's16';\n                    this.writeOutputValue = (view, byteOffset, value) => view.setInt16(byteOffset, value, true);\n                }\n                ;\n                break;\n            case 3:\n                {\n                    this.outputSampleSize = 4;\n                    this.outputFormat = 's32';\n                    // From https://www.w3.org/TR/webcodecs:\n                    // AudioData containing 24-bit samples SHOULD store those samples in s32 or f32. When samples are\n                    // stored in s32, each sample MUST be left-shifted by 8 bits.\n                    this.writeOutputValue = (view, byteOffset, value) => view.setInt32(byteOffset, value << 8, true);\n                }\n                ;\n                break;\n            case 4:\n                {\n                    this.outputSampleSize = 4;\n                    if (dataType === 'float') {\n                        this.outputFormat = 'f32';\n                        this.writeOutputValue = (view, byteOffset, value) => view.setFloat32(byteOffset, value, true);\n                    }\n                    else {\n                        this.outputFormat = 's32';\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt32(byteOffset, value, true);\n                    }\n                }\n                ;\n                break;\n            case 8:\n                {\n                    this.outputSampleSize = 4;\n                    this.outputFormat = 'f32';\n                    this.writeOutputValue = (view, byteOffset, value) => view.setFloat32(byteOffset, value, true);\n                }\n                ;\n                break;\n            default:\n                {\n                    assertNever(sampleSize);\n                    assert(false);\n                }\n                ;\n        }\n        ;\n    }\n    getDecodeQueueSize() {\n        return 0;\n    }\n    decode(packet) {\n        const inputView = toDataView(packet.data);\n        const numberOfFrames = packet.byteLength / this.decoderConfig.numberOfChannels / this.inputSampleSize;\n        const outputBufferSize = numberOfFrames * this.decoderConfig.numberOfChannels * this.outputSampleSize;\n        const outputBuffer = new ArrayBuffer(outputBufferSize);\n        const outputView = new DataView(outputBuffer);\n        for (let i = 0; i < numberOfFrames * this.decoderConfig.numberOfChannels; i++) {\n            const inputIndex = i * this.inputSampleSize;\n            const outputIndex = i * this.outputSampleSize;\n            const value = this.readInputValue(inputView, inputIndex);\n            this.writeOutputValue(outputView, outputIndex, value);\n        }\n        const preciseDuration = numberOfFrames / this.decoderConfig.sampleRate;\n        if (this.currentTimestamp === null || Math.abs(packet.timestamp - this.currentTimestamp) >= preciseDuration) {\n            // We need to sync with the packet timestamp again\n            this.currentTimestamp = packet.timestamp;\n        }\n        const preciseTimestamp = this.currentTimestamp;\n        this.currentTimestamp += preciseDuration;\n        const audioSample = new AudioSample({\n            format: this.outputFormat,\n            data: outputBuffer,\n            numberOfChannels: this.decoderConfig.numberOfChannels,\n            sampleRate: this.decoderConfig.sampleRate,\n            numberOfFrames,\n            timestamp: preciseTimestamp,\n        });\n        this.onSample(audioSample);\n    }\n    async flush() {\n        // Do nothing\n    }\n    close() {\n        // Do nothing\n    }\n}\n/**\n * Sink for retrieving decoded audio samples from an audio track.\n * @group Media sinks\n * @public\n */\nexport class AudioSampleSink extends BaseMediaSampleSink {\n    /** Creates a new {@link AudioSampleSink} for the given {@link InputAudioTrack}. */\n    constructor(audioTrack) {\n        if (!(audioTrack instanceof InputAudioTrack)) {\n            throw new TypeError('audioTrack must be an InputAudioTrack.');\n        }\n        super();\n        this._track = audioTrack;\n    }\n    /** @internal */\n    async _createDecoder(onSample, onError) {\n        if (!(await this._track.canDecode())) {\n            throw new Error('This audio track cannot be decoded by this browser. Make sure to check decodability before using'\n                + ' a track.');\n        }\n        const codec = this._track.codec;\n        const decoderConfig = await this._track.getDecoderConfig();\n        assert(codec && decoderConfig);\n        if (PCM_AUDIO_CODECS.includes(decoderConfig.codec)) {\n            return new PcmAudioDecoderWrapper(onSample, onError, decoderConfig);\n        }\n        else {\n            return new AudioDecoderWrapper(onSample, onError, codec, decoderConfig);\n        }\n    }\n    /** @internal */\n    _createPacketSink() {\n        return new EncodedPacketSink(this._track);\n    }\n    /**\n     * Retrieves the audio sample corresponding to the given timestamp, in seconds. More specifically, returns\n     * the last audio sample (in presentation order) with a start timestamp less than or equal to the given timestamp.\n     * Returns null if the timestamp is before the track's first timestamp.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    async getSample(timestamp) {\n        validateTimestamp(timestamp);\n        for await (const sample of this.mediaSamplesAtTimestamps([timestamp])) {\n            return sample;\n        }\n        throw new Error('Internal error: Iterator returned nothing.');\n    }\n    /**\n     * Creates an async iterator that yields the audio samples of this track in presentation order. This method\n     * will intelligently pre-decode a few samples ahead to enable fast iteration.\n     *\n     * @param startTimestamp - The timestamp in seconds at which to start yielding samples (inclusive).\n     * @param endTimestamp - The timestamp in seconds at which to stop yielding samples (exclusive).\n     */\n    samples(startTimestamp = 0, endTimestamp = Infinity) {\n        return this.mediaSamplesInRange(startTimestamp, endTimestamp);\n    }\n    /**\n     * Creates an async iterator that yields an audio sample for each timestamp in the argument. This method\n     * uses an optimized decoding pipeline if these timestamps are monotonically sorted, decoding each packet at most\n     * once, and is therefore more efficient than manually getting the sample for every timestamp. The iterator may\n     * yield null if no sample is available for a given timestamp.\n     *\n     * @param timestamps - An iterable or async iterable of timestamps in seconds.\n     */\n    samplesAtTimestamps(timestamps) {\n        return this.mediaSamplesAtTimestamps(timestamps);\n    }\n}\n/**\n * A sink that retrieves decoded audio samples from an audio track and converts them to `AudioBuffer` instances. This is\n * often more useful than directly retrieving audio samples, as audio buffers can be directly used with the\n * Web Audio API.\n * @group Media sinks\n * @public\n */\nexport class AudioBufferSink {\n    /** Creates a new {@link AudioBufferSink} for the given {@link InputAudioTrack}. */\n    constructor(audioTrack) {\n        if (!(audioTrack instanceof InputAudioTrack)) {\n            throw new TypeError('audioTrack must be an InputAudioTrack.');\n        }\n        this._audioSampleSink = new AudioSampleSink(audioTrack);\n    }\n    /** @internal */\n    _audioSampleToWrappedArrayBuffer(sample) {\n        const result = {\n            buffer: sample.toAudioBuffer(),\n            timestamp: sample.timestamp,\n            duration: sample.duration,\n        };\n        sample.close();\n        return result;\n    }\n    /**\n     * Retrieves the audio buffer corresponding to the given timestamp, in seconds. More specifically, returns\n     * the last audio buffer (in presentation order) with a start timestamp less than or equal to the given timestamp.\n     * Returns null if the timestamp is before the track's first timestamp.\n     *\n     * @param timestamp - The timestamp used for retrieval, in seconds.\n     */\n    async getBuffer(timestamp) {\n        validateTimestamp(timestamp);\n        const data = await this._audioSampleSink.getSample(timestamp);\n        return data && this._audioSampleToWrappedArrayBuffer(data);\n    }\n    /**\n     * Creates an async iterator that yields audio buffers of this track in presentation order. This method\n     * will intelligently pre-decode a few buffers ahead to enable fast iteration.\n     *\n     * @param startTimestamp - The timestamp in seconds at which to start yielding buffers (inclusive).\n     * @param endTimestamp - The timestamp in seconds at which to stop yielding buffers (exclusive).\n     */\n    buffers(startTimestamp = 0, endTimestamp = Infinity) {\n        return mapAsyncGenerator(this._audioSampleSink.samples(startTimestamp, endTimestamp), data => this._audioSampleToWrappedArrayBuffer(data));\n    }\n    /**\n     * Creates an async iterator that yields an audio buffer for each timestamp in the argument. This method\n     * uses an optimized decoding pipeline if these timestamps are monotonically sorted, decoding each packet at most\n     * once, and is therefore more efficient than manually getting the buffer for every timestamp. The iterator may\n     * yield null if no buffer is available for a given timestamp.\n     *\n     * @param timestamps - An iterable or async iterable of timestamps in seconds.\n     */\n    buffersAtTimestamps(timestamps) {\n        return mapAsyncGenerator(this._audioSampleSink.samplesAtTimestamps(timestamps), data => data && this._audioSampleToWrappedArrayBuffer(data));\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { determineVideoPacketType } from './codec-data.js';\nimport { customAudioDecoders, customVideoDecoders } from './custom-coder.js';\nimport { EncodedPacketSink } from './media-sink.js';\nimport { assert } from './misc.js';\nimport { EncodedPacket } from './packet.js';\n/**\n * Represents a media track in an input file.\n * @group Input files & tracks\n * @public\n */\nexport class InputTrack {\n    /** @internal */\n    constructor(input, backing) {\n        this.input = input;\n        this._backing = backing;\n    }\n    /** Returns true if and only if this track is a video track. */\n    isVideoTrack() {\n        return this instanceof InputVideoTrack;\n    }\n    /** Returns true if and only if this track is an audio track. */\n    isAudioTrack() {\n        return this instanceof InputAudioTrack;\n    }\n    /** The unique ID of this track in the input file. */\n    get id() {\n        return this._backing.getId();\n    }\n    /**\n     * The identifier of the codec used internally by the container. It is not homogenized by Mediabunny\n     * and depends entirely on the container format.\n     *\n     * This field can be used to determine the codec of a track in case Mediabunny doesn't know that codec.\n     *\n     * - For ISOBMFF files, this field returns the name of the Sample Description Box (e.g. `'avc1'`).\n     * - For Matroska files, this field returns the value of the `CodecID` element.\n     * - For WAVE files, this field returns the value of the format tag in the `'fmt '` chunk.\n     * - For ADTS files, this field contains the `MPEG-4 Audio Object Type`.\n     * - In all other cases, this field is `null`.\n     */\n    get internalCodecId() {\n        return this._backing.getInternalCodecId();\n    }\n    /**\n     * The ISO 639-2/T language code for this track. If the language is unknown, this field is `'und'` (undetermined).\n     */\n    get languageCode() {\n        return this._backing.getLanguageCode();\n    }\n    /** A user-defined name for this track. */\n    get name() {\n        return this._backing.getName();\n    }\n    /**\n     * A positive number x such that all timestamps and durations of all packets of this track are\n     * integer multiples of 1/x.\n     */\n    get timeResolution() {\n        return this._backing.getTimeResolution();\n    }\n    /** The track's disposition, i.e. information about its intended usage. */\n    get disposition() {\n        return this._backing.getDisposition();\n    }\n    /**\n     * Returns the start timestamp of the first packet of this track, in seconds. While often near zero, this value\n     * may be positive or even negative. A negative starting timestamp means the track's timing has been offset. Samples\n     * with a negative timestamp should not be presented.\n     */\n    getFirstTimestamp() {\n        return this._backing.getFirstTimestamp();\n    }\n    /** Returns the end timestamp of the last packet of this track, in seconds. */\n    computeDuration() {\n        return this._backing.computeDuration();\n    }\n    /**\n     * Computes aggregate packet statistics for this track, such as average packet rate or bitrate.\n     *\n     * @param targetPacketCount - This optional parameter sets a target for how many packets this method must have\n     * looked at before it can return early; this means, you can use it to aggregate only a subset (prefix) of all\n     * packets. This is very useful for getting a great estimate of video frame rate without having to scan through the\n     * entire file.\n     */\n    async computePacketStats(targetPacketCount = Infinity) {\n        const sink = new EncodedPacketSink(this);\n        let startTimestamp = Infinity;\n        let endTimestamp = -Infinity;\n        let packetCount = 0;\n        let totalPacketBytes = 0;\n        for await (const packet of sink.packets(undefined, undefined, { metadataOnly: true })) {\n            if (packetCount >= targetPacketCount\n                // This additional condition is needed to produce correct results with out-of-presentation-order packets\n                && packet.timestamp >= endTimestamp) {\n                break;\n            }\n            startTimestamp = Math.min(startTimestamp, packet.timestamp);\n            endTimestamp = Math.max(endTimestamp, packet.timestamp + packet.duration);\n            packetCount++;\n            totalPacketBytes += packet.byteLength;\n        }\n        return {\n            packetCount,\n            averagePacketRate: packetCount\n                ? Number((packetCount / (endTimestamp - startTimestamp)).toPrecision(16))\n                : 0,\n            averageBitrate: packetCount\n                ? Number((8 * totalPacketBytes / (endTimestamp - startTimestamp)).toPrecision(16))\n                : 0,\n        };\n    }\n}\n/**\n * Represents a video track in an input file.\n * @group Input files & tracks\n * @public\n */\nexport class InputVideoTrack extends InputTrack {\n    /** @internal */\n    constructor(input, backing) {\n        super(input, backing);\n        this._backing = backing;\n    }\n    get type() {\n        return 'video';\n    }\n    get codec() {\n        return this._backing.getCodec();\n    }\n    /** The width in pixels of the track's coded samples, before any transformations or rotations. */\n    get codedWidth() {\n        return this._backing.getCodedWidth();\n    }\n    /** The height in pixels of the track's coded samples, before any transformations or rotations. */\n    get codedHeight() {\n        return this._backing.getCodedHeight();\n    }\n    /** The angle in degrees by which the track's frames should be rotated (clockwise). */\n    get rotation() {\n        return this._backing.getRotation();\n    }\n    /** The width in pixels of the track's frames after rotation. */\n    get displayWidth() {\n        const rotation = this._backing.getRotation();\n        return rotation % 180 === 0 ? this._backing.getCodedWidth() : this._backing.getCodedHeight();\n    }\n    /** The height in pixels of the track's frames after rotation. */\n    get displayHeight() {\n        const rotation = this._backing.getRotation();\n        return rotation % 180 === 0 ? this._backing.getCodedHeight() : this._backing.getCodedWidth();\n    }\n    /** Returns the color space of the track's samples. */\n    getColorSpace() {\n        return this._backing.getColorSpace();\n    }\n    /** If this method returns true, the track's samples use a high dynamic range (HDR). */\n    async hasHighDynamicRange() {\n        const colorSpace = await this._backing.getColorSpace();\n        return colorSpace.primaries === 'bt2020' || colorSpace.primaries === 'smpte432'\n            || colorSpace.transfer === 'pg' || colorSpace.transfer === 'hlg'\n            || colorSpace.matrix === 'bt2020-ncl';\n    }\n    /** Checks if this track may contain transparent samples with alpha data. */\n    canBeTransparent() {\n        return this._backing.canBeTransparent();\n    }\n    /**\n     * Returns the [decoder configuration](https://www.w3.org/TR/webcodecs/#video-decoder-config) for decoding the\n     * track's packets using a [`VideoDecoder`](https://developer.mozilla.org/en-US/docs/Web/API/VideoDecoder). Returns\n     * null if the track's codec is unknown.\n     */\n    getDecoderConfig() {\n        return this._backing.getDecoderConfig();\n    }\n    async getCodecParameterString() {\n        const decoderConfig = await this._backing.getDecoderConfig();\n        return decoderConfig?.codec ?? null;\n    }\n    async canDecode() {\n        try {\n            const decoderConfig = await this._backing.getDecoderConfig();\n            if (!decoderConfig) {\n                return false;\n            }\n            const codec = this._backing.getCodec();\n            assert(codec !== null);\n            if (customVideoDecoders.some(x => x.supports(codec, decoderConfig))) {\n                return true;\n            }\n            if (typeof VideoDecoder === 'undefined') {\n                return false;\n            }\n            const support = await VideoDecoder.isConfigSupported(decoderConfig);\n            return support.supported === true;\n        }\n        catch (error) {\n            console.error('Error during decodability check:', error);\n            return false;\n        }\n    }\n    async determinePacketType(packet) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (packet.isMetadataOnly) {\n            throw new TypeError('packet must not be metadata-only to determine its type.');\n        }\n        if (this.codec === null) {\n            return null;\n        }\n        const decoderConfig = await this.getDecoderConfig();\n        assert(decoderConfig);\n        return determineVideoPacketType(this.codec, decoderConfig, packet.data);\n    }\n}\n/**\n * Represents an audio track in an input file.\n * @group Input files & tracks\n * @public\n */\nexport class InputAudioTrack extends InputTrack {\n    /** @internal */\n    constructor(input, backing) {\n        super(input, backing);\n        this._backing = backing;\n    }\n    get type() {\n        return 'audio';\n    }\n    get codec() {\n        return this._backing.getCodec();\n    }\n    /** The number of audio channels in the track. */\n    get numberOfChannels() {\n        return this._backing.getNumberOfChannels();\n    }\n    /** The track's audio sample rate in hertz. */\n    get sampleRate() {\n        return this._backing.getSampleRate();\n    }\n    /**\n     * Returns the [decoder configuration](https://www.w3.org/TR/webcodecs/#audio-decoder-config) for decoding the\n     * track's packets using an [`AudioDecoder`](https://developer.mozilla.org/en-US/docs/Web/API/AudioDecoder). Returns\n     * null if the track's codec is unknown.\n     */\n    getDecoderConfig() {\n        return this._backing.getDecoderConfig();\n    }\n    async getCodecParameterString() {\n        const decoderConfig = await this._backing.getDecoderConfig();\n        return decoderConfig?.codec ?? null;\n    }\n    async canDecode() {\n        try {\n            const decoderConfig = await this._backing.getDecoderConfig();\n            if (!decoderConfig) {\n                return false;\n            }\n            const codec = this._backing.getCodec();\n            assert(codec !== null);\n            if (customAudioDecoders.some(x => x.supports(codec, decoderConfig))) {\n                return true;\n            }\n            if (decoderConfig.codec.startsWith('pcm-')) {\n                return true; // Since we decode it ourselves\n            }\n            else {\n                if (typeof AudioDecoder === 'undefined') {\n                    return false;\n                }\n                const support = await AudioDecoder.isConfigSupported(decoderConfig);\n                return support.supported === true;\n            }\n        }\n        catch (error) {\n            console.error('Error during decodability check:', error);\n            return false;\n        }\n    }\n    async determinePacketType(packet) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (this.codec === null) {\n            return null;\n        }\n        return 'key'; // No audio codec with delta packets\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport const buildIsobmffMimeType = (info) => {\n    const base = info.hasVideo\n        ? 'video/'\n        : info.hasAudio\n            ? 'audio/'\n            : 'application/';\n    let string = base + (info.isQuickTime ? 'quicktime' : 'mp4');\n    if (info.codecStrings.length > 0) {\n        const uniqueCodecMimeTypes = [...new Set(info.codecStrings)];\n        string += `; codecs=\"${uniqueCodecMimeTypes.join(', ')}\"`;\n    }\n    return string;\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { RichImageData } from '../metadata.js';\nimport { textDecoder } from '../misc.js';\nimport { readAscii, readBytes, readI32Be, readU16Be, readU32Be, readU64Be, readU8 } from '../reader.js';\nexport const MIN_BOX_HEADER_SIZE = 8;\nexport const MAX_BOX_HEADER_SIZE = 16;\nexport const readBoxHeader = (slice) => {\n    let totalSize = readU32Be(slice);\n    const name = readAscii(slice, 4);\n    let headerSize = 8;\n    const hasLargeSize = totalSize === 1;\n    if (hasLargeSize) {\n        totalSize = readU64Be(slice);\n        headerSize = 16;\n    }\n    const contentSize = totalSize - headerSize;\n    if (contentSize < 0) {\n        return null; // Hardly a box is it\n    }\n    return { name, totalSize, headerSize, contentSize };\n};\nexport const readFixed_16_16 = (slice) => {\n    return readI32Be(slice) / 0x10000;\n};\nexport const readFixed_2_30 = (slice) => {\n    return readI32Be(slice) / 0x40000000;\n};\nexport const readIsomVariableInteger = (slice) => {\n    let result = 0;\n    for (let i = 0; i < 4; i++) {\n        result <<= 7;\n        const nextByte = readU8(slice);\n        result |= nextByte & 0x7f;\n        if ((nextByte & 0x80) === 0) {\n            break;\n        }\n    }\n    return result;\n};\nexport const readMetadataStringShort = (slice) => {\n    let stringLength = readU16Be(slice);\n    slice.skip(2); // Language\n    stringLength = Math.min(stringLength, slice.remainingLength);\n    return textDecoder.decode(readBytes(slice, stringLength));\n};\nexport const readDataBox = (slice) => {\n    const header = readBoxHeader(slice);\n    if (!header || header.name !== 'data') {\n        return null;\n    }\n    if (slice.remainingLength < 8) {\n        // Box is too small\n        return null;\n    }\n    const typeIndicator = readU32Be(slice);\n    slice.skip(4); // Locale indicator\n    const data = readBytes(slice, header.contentSize - 8);\n    switch (typeIndicator) {\n        case 1: return textDecoder.decode(data); // UTF-8\n        case 2: return new TextDecoder('utf-16be').decode(data); // UTF-16-BE\n        case 13: return new RichImageData(data, 'image/jpeg');\n        case 14: return new RichImageData(data, 'image/png');\n        case 27: return new RichImageData(data, 'image/bmp');\n        default: return data;\n    }\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { extractAudioCodecString, extractVideoCodecString, OPUS_SAMPLE_RATE, parseAacAudioSpecificConfig, parsePcmCodec, PCM_AUDIO_CODECS, } from '../codec.js';\nimport { extractAv1CodecInfoFromPacket, extractVp9CodecInfoFromPacket, FlacBlockType, } from '../codec-data.js';\nimport { Demuxer } from '../demuxer.js';\nimport { InputAudioTrack, InputVideoTrack, } from '../input-track.js';\nimport { assert, binarySearchExact, binarySearchLessOrEqual, Bitstream, COLOR_PRIMARIES_MAP_INVERSE, findLastIndex, isIso639Dash2LanguageCode, last, MATRIX_COEFFICIENTS_MAP_INVERSE, normalizeRotation, roundToMultiple, textDecoder, TRANSFER_CHARACTERISTICS_MAP_INVERSE, UNDETERMINED_LANGUAGE, toDataView, roundIfAlmostInteger, } from '../misc.js';\nimport { EncodedPacket, PLACEHOLDER_DATA } from '../packet.js';\nimport { buildIsobmffMimeType } from './isobmff-misc.js';\nimport { MAX_BOX_HEADER_SIZE, MIN_BOX_HEADER_SIZE, readBoxHeader, readDataBox, readFixed_16_16, readFixed_2_30, readIsomVariableInteger, readMetadataStringShort, } from './isobmff-reader.js';\nimport { readBytes, readF64Be, readI16Be, readI32Be, readI64Be, readU16Be, readU24Be, readU32Be, readU64Be, readU8, readAscii, } from '../reader.js';\nimport { DEFAULT_TRACK_DISPOSITION, RichImageData } from '../metadata.js';\nexport class IsobmffDemuxer extends Demuxer {\n    constructor(input) {\n        super(input);\n        this.moovSlice = null;\n        this.currentTrack = null;\n        this.tracks = [];\n        this.metadataPromise = null;\n        this.movieTimescale = -1;\n        this.movieDurationInTimescale = -1;\n        this.isQuickTime = false;\n        this.metadataTags = {};\n        this.currentMetadataKeys = null;\n        this.isFragmented = false;\n        this.fragmentTrackDefaults = [];\n        this.currentFragment = null;\n        /**\n         * Caches the last fragment that was read. Based on the assumption that there will be multiple reads to the\n         * same fragment in quick succession.\n         */\n        this.lastReadFragment = null;\n        this.reader = input._reader;\n    }\n    async computeDuration() {\n        const tracks = await this.getTracks();\n        const trackDurations = await Promise.all(tracks.map(x => x.computeDuration()));\n        return Math.max(0, ...trackDurations);\n    }\n    async getTracks() {\n        await this.readMetadata();\n        return this.tracks.map(track => track.inputTrack);\n    }\n    async getMimeType() {\n        await this.readMetadata();\n        const codecStrings = await Promise.all(this.tracks.map(x => x.inputTrack.getCodecParameterString()));\n        return buildIsobmffMimeType({\n            isQuickTime: this.isQuickTime,\n            hasVideo: this.tracks.some(x => x.info?.type === 'video'),\n            hasAudio: this.tracks.some(x => x.info?.type === 'audio'),\n            codecStrings: codecStrings.filter(Boolean),\n        });\n    }\n    async getMetadataTags() {\n        await this.readMetadata();\n        return this.metadataTags;\n    }\n    readMetadata() {\n        return this.metadataPromise ??= (async () => {\n            let currentPos = 0;\n            while (true) {\n                let slice = this.reader.requestSliceRange(currentPos, MIN_BOX_HEADER_SIZE, MAX_BOX_HEADER_SIZE);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (!slice)\n                    break;\n                const startPos = currentPos;\n                const boxInfo = readBoxHeader(slice);\n                if (!boxInfo) {\n                    break;\n                }\n                if (boxInfo.name === 'ftyp') {\n                    const majorBrand = readAscii(slice, 4);\n                    this.isQuickTime = majorBrand === 'qt  ';\n                }\n                else if (boxInfo.name === 'moov') {\n                    // Found moov, load it\n                    let moovSlice = this.reader.requestSlice(slice.filePos, boxInfo.contentSize);\n                    if (moovSlice instanceof Promise)\n                        moovSlice = await moovSlice;\n                    if (!moovSlice)\n                        break;\n                    this.moovSlice = moovSlice;\n                    this.readContiguousBoxes(this.moovSlice);\n                    // Put default tracks first\n                    this.tracks.sort((a, b) => Number(b.disposition.default) - Number(a.disposition.default));\n                    for (const track of this.tracks) {\n                        // Modify the edit list offset based on the previous segment durations. They are in different\n                        // timescales, so we first convert to seconds and then into the track timescale.\n                        const previousSegmentDurationsInSeconds = track.editListPreviousSegmentDurations / this.movieTimescale;\n                        track.editListOffset -= Math.round(previousSegmentDurationsInSeconds * track.timescale);\n                    }\n                    break;\n                }\n                currentPos = startPos + boxInfo.totalSize;\n            }\n            if (this.isFragmented && this.reader.fileSize !== null) {\n                // The last 4 bytes may contain the size of the mfra box at the end of the file\n                let lastWordSlice = this.reader.requestSlice(this.reader.fileSize - 4, 4);\n                if (lastWordSlice instanceof Promise)\n                    lastWordSlice = await lastWordSlice;\n                assert(lastWordSlice);\n                const lastWord = readU32Be(lastWordSlice);\n                const potentialMfraPos = this.reader.fileSize - lastWord;\n                if (potentialMfraPos >= 0 && potentialMfraPos <= this.reader.fileSize - MAX_BOX_HEADER_SIZE) {\n                    let mfraHeaderSlice = this.reader.requestSliceRange(potentialMfraPos, MIN_BOX_HEADER_SIZE, MAX_BOX_HEADER_SIZE);\n                    if (mfraHeaderSlice instanceof Promise)\n                        mfraHeaderSlice = await mfraHeaderSlice;\n                    if (mfraHeaderSlice) {\n                        const boxInfo = readBoxHeader(mfraHeaderSlice);\n                        if (boxInfo && boxInfo.name === 'mfra') {\n                            // We found the mfra box, allowing for much better random access. Let's parse it.\n                            let mfraSlice = this.reader.requestSlice(mfraHeaderSlice.filePos, boxInfo.contentSize);\n                            if (mfraSlice instanceof Promise)\n                                mfraSlice = await mfraSlice;\n                            if (mfraSlice) {\n                                this.readContiguousBoxes(mfraSlice);\n                            }\n                        }\n                    }\n                }\n            }\n        })();\n    }\n    getSampleTableForTrack(internalTrack) {\n        if (internalTrack.sampleTable) {\n            return internalTrack.sampleTable;\n        }\n        const sampleTable = {\n            sampleTimingEntries: [],\n            sampleCompositionTimeOffsets: [],\n            sampleSizes: [],\n            keySampleIndices: null,\n            chunkOffsets: [],\n            sampleToChunk: [],\n            presentationTimestamps: null,\n            presentationTimestampIndexMap: null,\n        };\n        internalTrack.sampleTable = sampleTable;\n        assert(this.moovSlice);\n        const stblContainerSlice = this.moovSlice.slice(internalTrack.sampleTableByteOffset);\n        this.currentTrack = internalTrack;\n        this.traverseBox(stblContainerSlice);\n        this.currentTrack = null;\n        const isPcmCodec = internalTrack.info?.type === 'audio'\n            && internalTrack.info.codec\n            && PCM_AUDIO_CODECS.includes(internalTrack.info.codec);\n        if (isPcmCodec && sampleTable.sampleCompositionTimeOffsets.length === 0) {\n            // If the audio has PCM samples, the way the samples are defined in the sample table is somewhat\n            // suboptimal: Each individual audio sample is its own sample, meaning we can have 48000 samples per second.\n            // Because we treat each sample as its own atomic unit that can be decoded, this would lead to a huge\n            // amount of very short samples for PCM audio. So instead, we make a transformation: If the audio is in PCM,\n            // we say that each chunk (that normally holds many samples) now is one big sample. We can this because\n            // the samples in the chunk are contiguous and the format is PCM, so the entire chunk as one thing still\n            // encodes valid audio information.\n            assert(internalTrack.info?.type === 'audio');\n            const pcmInfo = parsePcmCodec(internalTrack.info.codec);\n            const newSampleTimingEntries = [];\n            const newSampleSizes = [];\n            for (let i = 0; i < sampleTable.sampleToChunk.length; i++) {\n                const chunkEntry = sampleTable.sampleToChunk[i];\n                const nextEntry = sampleTable.sampleToChunk[i + 1];\n                const chunkCount = (nextEntry ? nextEntry.startChunkIndex : sampleTable.chunkOffsets.length)\n                    - chunkEntry.startChunkIndex;\n                for (let j = 0; j < chunkCount; j++) {\n                    const startSampleIndex = chunkEntry.startSampleIndex + j * chunkEntry.samplesPerChunk;\n                    const endSampleIndex = startSampleIndex + chunkEntry.samplesPerChunk; // Exclusive, outside of chunk\n                    const startTimingEntryIndex = binarySearchLessOrEqual(sampleTable.sampleTimingEntries, startSampleIndex, x => x.startIndex);\n                    const startTimingEntry = sampleTable.sampleTimingEntries[startTimingEntryIndex];\n                    const endTimingEntryIndex = binarySearchLessOrEqual(sampleTable.sampleTimingEntries, endSampleIndex, x => x.startIndex);\n                    const endTimingEntry = sampleTable.sampleTimingEntries[endTimingEntryIndex];\n                    const firstSampleTimestamp = startTimingEntry.startDecodeTimestamp\n                        + (startSampleIndex - startTimingEntry.startIndex) * startTimingEntry.delta;\n                    const lastSampleTimestamp = endTimingEntry.startDecodeTimestamp\n                        + (endSampleIndex - endTimingEntry.startIndex) * endTimingEntry.delta;\n                    const delta = lastSampleTimestamp - firstSampleTimestamp;\n                    const lastSampleTimingEntry = last(newSampleTimingEntries);\n                    if (lastSampleTimingEntry && lastSampleTimingEntry.delta === delta) {\n                        lastSampleTimingEntry.count++;\n                    }\n                    else {\n                        // One sample for the entire chunk\n                        newSampleTimingEntries.push({\n                            startIndex: chunkEntry.startChunkIndex + j,\n                            startDecodeTimestamp: firstSampleTimestamp,\n                            count: 1,\n                            delta,\n                        });\n                    }\n                    // Instead of determining the chunk's size by looping over the samples sizes in the sample table, we\n                    // can directly compute it as we know how many PCM frames are in this chunk, and the size of each\n                    // PCM frame. This also improves compatibility with some files which fail to write proper sample\n                    // size values into their sample tables in the PCM case.\n                    const chunkSize = chunkEntry.samplesPerChunk\n                        * pcmInfo.sampleSize\n                        * internalTrack.info.numberOfChannels;\n                    newSampleSizes.push(chunkSize);\n                }\n                chunkEntry.startSampleIndex = chunkEntry.startChunkIndex;\n                chunkEntry.samplesPerChunk = 1;\n            }\n            sampleTable.sampleTimingEntries = newSampleTimingEntries;\n            sampleTable.sampleSizes = newSampleSizes;\n        }\n        if (sampleTable.sampleCompositionTimeOffsets.length > 0) {\n            // If composition time offsets are defined, we must build a list of all presentation timestamps and then\n            // sort them\n            sampleTable.presentationTimestamps = [];\n            for (const entry of sampleTable.sampleTimingEntries) {\n                for (let i = 0; i < entry.count; i++) {\n                    sampleTable.presentationTimestamps.push({\n                        presentationTimestamp: entry.startDecodeTimestamp + i * entry.delta,\n                        sampleIndex: entry.startIndex + i,\n                    });\n                }\n            }\n            for (const entry of sampleTable.sampleCompositionTimeOffsets) {\n                for (let i = 0; i < entry.count; i++) {\n                    const sampleIndex = entry.startIndex + i;\n                    const sample = sampleTable.presentationTimestamps[sampleIndex];\n                    if (!sample) {\n                        continue;\n                    }\n                    sample.presentationTimestamp += entry.offset;\n                }\n            }\n            sampleTable.presentationTimestamps.sort((a, b) => a.presentationTimestamp - b.presentationTimestamp);\n            sampleTable.presentationTimestampIndexMap = Array(sampleTable.presentationTimestamps.length).fill(-1);\n            for (let i = 0; i < sampleTable.presentationTimestamps.length; i++) {\n                sampleTable.presentationTimestampIndexMap[sampleTable.presentationTimestamps[i].sampleIndex] = i;\n            }\n        }\n        else {\n            // If they're not defined, we can simply use the decode timestamps as presentation timestamps\n        }\n        return sampleTable;\n    }\n    async readFragment(startPos) {\n        if (this.lastReadFragment?.moofOffset === startPos) {\n            return this.lastReadFragment;\n        }\n        let headerSlice = this.reader.requestSliceRange(startPos, MIN_BOX_HEADER_SIZE, MAX_BOX_HEADER_SIZE);\n        if (headerSlice instanceof Promise)\n            headerSlice = await headerSlice;\n        assert(headerSlice);\n        const moofBoxInfo = readBoxHeader(headerSlice);\n        assert(moofBoxInfo?.name === 'moof');\n        let entireSlice = this.reader.requestSlice(startPos, moofBoxInfo.totalSize);\n        if (entireSlice instanceof Promise)\n            entireSlice = await entireSlice;\n        assert(entireSlice);\n        this.traverseBox(entireSlice);\n        const fragment = this.lastReadFragment;\n        assert(fragment && fragment.moofOffset === startPos);\n        for (const [, trackData] of fragment.trackData) {\n            const track = trackData.track;\n            const { fragmentPositionCache } = track;\n            if (!trackData.startTimestampIsFinal) {\n                // It may be that some tracks don't define the base decode time, i.e. when the fragment begins. This\n                // we'll need to figure out the start timestamp another way. We'll compute the timestamp by accessing\n                // the lookup entries and fragment cache, which works out nicely with the lookup algorithm: If these\n                // exist, then the lookup will automatically start at the furthest possible point. If they don't, the\n                // lookup starts sequentially from the start, incrementally summing up all fragment durations. It's sort\n                // of implicit, but it ends up working nicely.\n                const lookupEntry = track.fragmentLookupTable.find(x => x.moofOffset === fragment.moofOffset);\n                if (lookupEntry) {\n                    // There's a lookup entry, let's use its timestamp\n                    offsetFragmentTrackDataByTimestamp(trackData, lookupEntry.timestamp);\n                }\n                else {\n                    const lastCacheIndex = binarySearchLessOrEqual(fragmentPositionCache, fragment.moofOffset - 1, x => x.moofOffset);\n                    if (lastCacheIndex !== -1) {\n                        // Let's use the timestamp of the previous fragment in the cache\n                        const lastCache = fragmentPositionCache[lastCacheIndex];\n                        offsetFragmentTrackDataByTimestamp(trackData, lastCache.endTimestamp);\n                    }\n                    else {\n                        // We're the first fragment I guess, \"offset by 0\"\n                    }\n                }\n                trackData.startTimestampIsFinal = true;\n            }\n            // Let's remember that a fragment with a given timestamp is here, speeding up future lookups if no\n            // lookup table exists\n            const insertionIndex = binarySearchLessOrEqual(fragmentPositionCache, trackData.startTimestamp, x => x.startTimestamp);\n            if (insertionIndex === -1\n                || fragmentPositionCache[insertionIndex].moofOffset !== fragment.moofOffset) {\n                fragmentPositionCache.splice(insertionIndex + 1, 0, {\n                    moofOffset: fragment.moofOffset,\n                    startTimestamp: trackData.startTimestamp,\n                    endTimestamp: trackData.endTimestamp,\n                });\n            }\n        }\n        return fragment;\n    }\n    readContiguousBoxes(slice) {\n        const startIndex = slice.filePos;\n        while (slice.filePos - startIndex <= slice.length - MIN_BOX_HEADER_SIZE) {\n            const foundBox = this.traverseBox(slice);\n            if (!foundBox) {\n                break;\n            }\n        }\n    }\n    // eslint-disable-next-line @stylistic/generator-star-spacing\n    *iterateContiguousBoxes(slice) {\n        const startIndex = slice.filePos;\n        while (slice.filePos - startIndex <= slice.length - MIN_BOX_HEADER_SIZE) {\n            const startPos = slice.filePos;\n            const boxInfo = readBoxHeader(slice);\n            if (!boxInfo) {\n                break;\n            }\n            yield { boxInfo, slice };\n            slice.filePos = startPos + boxInfo.totalSize;\n        }\n    }\n    traverseBox(slice) {\n        const startPos = slice.filePos;\n        const boxInfo = readBoxHeader(slice);\n        if (!boxInfo) {\n            return false;\n        }\n        const contentStartPos = slice.filePos;\n        const boxEndPos = startPos + boxInfo.totalSize;\n        switch (boxInfo.name) {\n            case 'mdia':\n            case 'minf':\n            case 'dinf':\n            case 'mfra':\n            case 'edts':\n                {\n                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                }\n                ;\n                break;\n            case 'mvhd':\n                {\n                    const version = readU8(slice);\n                    slice.skip(3); // Flags\n                    if (version === 1) {\n                        slice.skip(8 + 8);\n                        this.movieTimescale = readU32Be(slice);\n                        this.movieDurationInTimescale = readU64Be(slice);\n                    }\n                    else {\n                        slice.skip(4 + 4);\n                        this.movieTimescale = readU32Be(slice);\n                        this.movieDurationInTimescale = readU32Be(slice);\n                    }\n                }\n                ;\n                break;\n            case 'trak':\n                {\n                    const track = {\n                        id: -1,\n                        demuxer: this,\n                        inputTrack: null,\n                        disposition: {\n                            ...DEFAULT_TRACK_DISPOSITION,\n                        },\n                        info: null,\n                        timescale: -1,\n                        durationInMovieTimescale: -1,\n                        durationInMediaTimescale: -1,\n                        rotation: 0,\n                        internalCodecId: null,\n                        name: null,\n                        languageCode: UNDETERMINED_LANGUAGE,\n                        sampleTableByteOffset: -1,\n                        sampleTable: null,\n                        fragmentLookupTable: [],\n                        currentFragmentState: null,\n                        fragmentPositionCache: [],\n                        editListPreviousSegmentDurations: 0,\n                        editListOffset: 0,\n                    };\n                    this.currentTrack = track;\n                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                    if (track.id !== -1 && track.timescale !== -1 && track.info !== null) {\n                        if (track.info.type === 'video' && track.info.width !== -1) {\n                            const videoTrack = track;\n                            track.inputTrack = new InputVideoTrack(this.input, new IsobmffVideoTrackBacking(videoTrack));\n                            this.tracks.push(track);\n                        }\n                        else if (track.info.type === 'audio' && track.info.numberOfChannels !== -1) {\n                            const audioTrack = track;\n                            track.inputTrack = new InputAudioTrack(this.input, new IsobmffAudioTrackBacking(audioTrack));\n                            this.tracks.push(track);\n                        }\n                    }\n                    this.currentTrack = null;\n                }\n                ;\n                break;\n            case 'tkhd':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    const version = readU8(slice);\n                    const flags = readU24Be(slice);\n                    // Spec says disabled tracks are to be treated like they don't exist, but in practice, they are treated\n                    // more like non-default tracks.\n                    const trackEnabled = !!(flags & 0x1);\n                    track.disposition.default = trackEnabled;\n                    // Skip over creation & modification time to reach the track ID\n                    if (version === 0) {\n                        slice.skip(8);\n                        track.id = readU32Be(slice);\n                        slice.skip(4);\n                        track.durationInMovieTimescale = readU32Be(slice);\n                    }\n                    else if (version === 1) {\n                        slice.skip(16);\n                        track.id = readU32Be(slice);\n                        slice.skip(4);\n                        track.durationInMovieTimescale = readU64Be(slice);\n                    }\n                    else {\n                        throw new Error(`Incorrect track header version ${version}.`);\n                    }\n                    slice.skip(2 * 4 + 2 + 2 + 2 + 2);\n                    const matrix = [\n                        readFixed_16_16(slice),\n                        readFixed_16_16(slice),\n                        readFixed_2_30(slice),\n                        readFixed_16_16(slice),\n                        readFixed_16_16(slice),\n                        readFixed_2_30(slice),\n                        readFixed_16_16(slice),\n                        readFixed_16_16(slice),\n                        readFixed_2_30(slice),\n                    ];\n                    const rotation = normalizeRotation(roundToMultiple(extractRotationFromMatrix(matrix), 90));\n                    assert(rotation === 0 || rotation === 90 || rotation === 180 || rotation === 270);\n                    track.rotation = rotation;\n                }\n                ;\n                break;\n            case 'elst':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    const version = readU8(slice);\n                    slice.skip(3); // Flags\n                    let relevantEntryFound = false;\n                    let previousSegmentDurations = 0;\n                    const entryCount = readU32Be(slice);\n                    for (let i = 0; i < entryCount; i++) {\n                        const segmentDuration = version === 1\n                            ? readU64Be(slice)\n                            : readU32Be(slice);\n                        const mediaTime = version === 1\n                            ? readI64Be(slice)\n                            : readI32Be(slice);\n                        const mediaRate = readFixed_16_16(slice);\n                        if (segmentDuration === 0) {\n                            // Don't care\n                            continue;\n                        }\n                        if (relevantEntryFound) {\n                            console.warn('Unsupported edit list: multiple edits are not currently supported. Only using first edit.');\n                            break;\n                        }\n                        if (mediaTime === -1) {\n                            previousSegmentDurations += segmentDuration;\n                            continue;\n                        }\n                        if (mediaRate !== 1) {\n                            console.warn('Unsupported edit list entry: media rate must be 1.');\n                            break;\n                        }\n                        track.editListPreviousSegmentDurations = previousSegmentDurations;\n                        track.editListOffset = mediaTime;\n                        relevantEntryFound = true;\n                    }\n                }\n                ;\n                break;\n            case 'mdhd':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    const version = readU8(slice);\n                    slice.skip(3); // Flags\n                    if (version === 0) {\n                        slice.skip(8);\n                        track.timescale = readU32Be(slice);\n                        track.durationInMediaTimescale = readU32Be(slice);\n                    }\n                    else if (version === 1) {\n                        slice.skip(16);\n                        track.timescale = readU32Be(slice);\n                        track.durationInMediaTimescale = readU64Be(slice);\n                    }\n                    let language = readU16Be(slice);\n                    if (language > 0) {\n                        track.languageCode = '';\n                        for (let i = 0; i < 3; i++) {\n                            track.languageCode = String.fromCharCode(0x60 + (language & 0b11111)) + track.languageCode;\n                            language >>= 5;\n                        }\n                        if (!isIso639Dash2LanguageCode(track.languageCode)) {\n                            // Sometimes the bytes are garbage\n                            track.languageCode = UNDETERMINED_LANGUAGE;\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'hdlr':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    slice.skip(8); // Version + flags + pre-defined\n                    const handlerType = readAscii(slice, 4);\n                    if (handlerType === 'vide') {\n                        track.info = {\n                            type: 'video',\n                            width: -1,\n                            height: -1,\n                            codec: null,\n                            codecDescription: null,\n                            colorSpace: null,\n                            avcType: null,\n                            avcCodecInfo: null,\n                            hevcCodecInfo: null,\n                            vp9CodecInfo: null,\n                            av1CodecInfo: null,\n                        };\n                    }\n                    else if (handlerType === 'soun') {\n                        track.info = {\n                            type: 'audio',\n                            numberOfChannels: -1,\n                            sampleRate: -1,\n                            codec: null,\n                            codecDescription: null,\n                            aacCodecInfo: null,\n                        };\n                    }\n                }\n                ;\n                break;\n            case 'stbl':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    track.sampleTableByteOffset = startPos;\n                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                }\n                ;\n                break;\n            case 'stsd':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (track.info === null || track.sampleTable) {\n                        break;\n                    }\n                    const stsdVersion = readU8(slice);\n                    slice.skip(3); // Flags\n                    const entries = readU32Be(slice);\n                    for (let i = 0; i < entries; i++) {\n                        const sampleBoxStartPos = slice.filePos;\n                        const sampleBoxInfo = readBoxHeader(slice);\n                        if (!sampleBoxInfo) {\n                            break;\n                        }\n                        track.internalCodecId = sampleBoxInfo.name;\n                        const lowercaseBoxName = sampleBoxInfo.name.toLowerCase();\n                        if (track.info.type === 'video') {\n                            if (lowercaseBoxName === 'avc1' || lowercaseBoxName === 'avc3') {\n                                track.info.codec = 'avc';\n                                track.info.avcType = lowercaseBoxName === 'avc1' ? 1 : 3;\n                            }\n                            else if (lowercaseBoxName === 'hvc1' || lowercaseBoxName === 'hev1') {\n                                track.info.codec = 'hevc';\n                            }\n                            else if (lowercaseBoxName === 'vp08') {\n                                track.info.codec = 'vp8';\n                            }\n                            else if (lowercaseBoxName === 'vp09') {\n                                track.info.codec = 'vp9';\n                            }\n                            else if (lowercaseBoxName === 'av01') {\n                                track.info.codec = 'av1';\n                            }\n                            else {\n                                console.warn(`Unsupported video codec (sample entry type '${sampleBoxInfo.name}').`);\n                            }\n                            slice.skip(6 * 1 + 2 + 2 + 2 + 3 * 4);\n                            track.info.width = readU16Be(slice);\n                            track.info.height = readU16Be(slice);\n                            slice.skip(4 + 4 + 4 + 2 + 32 + 2 + 2);\n                            this.readContiguousBoxes(slice.slice(slice.filePos, (sampleBoxStartPos + sampleBoxInfo.totalSize) - slice.filePos));\n                        }\n                        else {\n                            if (lowercaseBoxName === 'mp4a') {\n                                // We don't know the codec yet (might be AAC, might be MP3), need to read the esds box\n                            }\n                            else if (lowercaseBoxName === 'opus') {\n                                track.info.codec = 'opus';\n                            }\n                            else if (lowercaseBoxName === 'flac') {\n                                track.info.codec = 'flac';\n                            }\n                            else if (lowercaseBoxName === 'twos'\n                                || lowercaseBoxName === 'sowt'\n                                || lowercaseBoxName === 'raw '\n                                || lowercaseBoxName === 'in24'\n                                || lowercaseBoxName === 'in32'\n                                || lowercaseBoxName === 'fl32'\n                                || lowercaseBoxName === 'fl64'\n                                || lowercaseBoxName === 'lpcm'\n                                || lowercaseBoxName === 'ipcm' // ISO/IEC 23003-5\n                                || lowercaseBoxName === 'fpcm' // \"\n                            ) {\n                                // It's PCM\n                                // developer.apple.com/documentation/quicktime-file-format/sound_sample_descriptions/\n                            }\n                            else if (lowercaseBoxName === 'ulaw') {\n                                track.info.codec = 'ulaw';\n                            }\n                            else if (lowercaseBoxName === 'alaw') {\n                                track.info.codec = 'alaw';\n                            }\n                            else {\n                                console.warn(`Unsupported audio codec (sample entry type '${sampleBoxInfo.name}').`);\n                            }\n                            slice.skip(6 * 1 + 2);\n                            const version = readU16Be(slice);\n                            slice.skip(3 * 2);\n                            let channelCount = readU16Be(slice);\n                            let sampleSize = readU16Be(slice);\n                            slice.skip(2 * 2);\n                            // Can't use fixed16_16 as that's signed\n                            let sampleRate = readU32Be(slice) / 0x10000;\n                            if (stsdVersion === 0 && version > 0) {\n                                // Additional QuickTime fields\n                                if (version === 1) {\n                                    slice.skip(4);\n                                    sampleSize = 8 * readU32Be(slice);\n                                    slice.skip(2 * 4);\n                                }\n                                else if (version === 2) {\n                                    slice.skip(4);\n                                    sampleRate = readF64Be(slice);\n                                    channelCount = readU32Be(slice);\n                                    slice.skip(4); // Always 0x7f000000\n                                    sampleSize = readU32Be(slice);\n                                    const flags = readU32Be(slice);\n                                    slice.skip(2 * 4);\n                                    if (lowercaseBoxName === 'lpcm') {\n                                        const bytesPerSample = (sampleSize + 7) >> 3;\n                                        const isFloat = Boolean(flags & 1);\n                                        const isBigEndian = Boolean(flags & 2);\n                                        const sFlags = flags & 4 ? -1 : 0; // I guess it means \"signed flags\" or something?\n                                        if (sampleSize > 0 && sampleSize <= 64) {\n                                            if (isFloat) {\n                                                if (sampleSize === 32) {\n                                                    track.info.codec = isBigEndian ? 'pcm-f32be' : 'pcm-f32';\n                                                }\n                                            }\n                                            else {\n                                                if (sFlags & (1 << (bytesPerSample - 1))) {\n                                                    if (bytesPerSample === 1) {\n                                                        track.info.codec = 'pcm-s8';\n                                                    }\n                                                    else if (bytesPerSample === 2) {\n                                                        track.info.codec = isBigEndian ? 'pcm-s16be' : 'pcm-s16';\n                                                    }\n                                                    else if (bytesPerSample === 3) {\n                                                        track.info.codec = isBigEndian ? 'pcm-s24be' : 'pcm-s24';\n                                                    }\n                                                    else if (bytesPerSample === 4) {\n                                                        track.info.codec = isBigEndian ? 'pcm-s32be' : 'pcm-s32';\n                                                    }\n                                                }\n                                                else {\n                                                    if (bytesPerSample === 1) {\n                                                        track.info.codec = 'pcm-u8';\n                                                    }\n                                                }\n                                            }\n                                        }\n                                        if (track.info.codec === null) {\n                                            console.warn('Unsupported PCM format.');\n                                        }\n                                    }\n                                }\n                            }\n                            if (track.info.codec === 'opus') {\n                                sampleRate = OPUS_SAMPLE_RATE; // Always the same\n                            }\n                            track.info.numberOfChannels = channelCount;\n                            track.info.sampleRate = sampleRate;\n                            // PCM codec assignments\n                            if (lowercaseBoxName === 'twos') {\n                                if (sampleSize === 8) {\n                                    track.info.codec = 'pcm-s8';\n                                }\n                                else if (sampleSize === 16) {\n                                    track.info.codec = 'pcm-s16be';\n                                }\n                                else {\n                                    console.warn(`Unsupported sample size ${sampleSize} for codec 'twos'.`);\n                                    track.info.codec = null;\n                                }\n                            }\n                            else if (lowercaseBoxName === 'sowt') {\n                                if (sampleSize === 8) {\n                                    track.info.codec = 'pcm-s8';\n                                }\n                                else if (sampleSize === 16) {\n                                    track.info.codec = 'pcm-s16';\n                                }\n                                else {\n                                    console.warn(`Unsupported sample size ${sampleSize} for codec 'sowt'.`);\n                                    track.info.codec = null;\n                                }\n                            }\n                            else if (lowercaseBoxName === 'raw ') {\n                                track.info.codec = 'pcm-u8';\n                            }\n                            else if (lowercaseBoxName === 'in24') {\n                                track.info.codec = 'pcm-s24be';\n                            }\n                            else if (lowercaseBoxName === 'in32') {\n                                track.info.codec = 'pcm-s32be';\n                            }\n                            else if (lowercaseBoxName === 'fl32') {\n                                track.info.codec = 'pcm-f32be';\n                            }\n                            else if (lowercaseBoxName === 'fl64') {\n                                track.info.codec = 'pcm-f64be';\n                            }\n                            else if (lowercaseBoxName === 'ipcm') {\n                                track.info.codec = 'pcm-s16be'; // Placeholder, will be adjusted by the pcmC box\n                            }\n                            else if (lowercaseBoxName === 'fpcm') {\n                                track.info.codec = 'pcm-f32be'; // Placeholder, will be adjusted by the pcmC box\n                            }\n                            this.readContiguousBoxes(slice.slice(slice.filePos, (sampleBoxStartPos + sampleBoxInfo.totalSize) - slice.filePos));\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'avcC':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info);\n                    track.info.codecDescription = readBytes(slice, boxInfo.contentSize);\n                }\n                ;\n                break;\n            case 'hvcC':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info);\n                    track.info.codecDescription = readBytes(slice, boxInfo.contentSize);\n                }\n                ;\n                break;\n            case 'vpcC':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'video');\n                    slice.skip(4); // Version + flags\n                    const profile = readU8(slice);\n                    const level = readU8(slice);\n                    const thirdByte = readU8(slice);\n                    const bitDepth = thirdByte >> 4;\n                    const chromaSubsampling = (thirdByte >> 1) & 0b111;\n                    const videoFullRangeFlag = thirdByte & 1;\n                    const colourPrimaries = readU8(slice);\n                    const transferCharacteristics = readU8(slice);\n                    const matrixCoefficients = readU8(slice);\n                    track.info.vp9CodecInfo = {\n                        profile,\n                        level,\n                        bitDepth,\n                        chromaSubsampling,\n                        videoFullRangeFlag,\n                        colourPrimaries,\n                        transferCharacteristics,\n                        matrixCoefficients,\n                    };\n                }\n                ;\n                break;\n            case 'av1C':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'video');\n                    slice.skip(1); // Marker + version\n                    const secondByte = readU8(slice);\n                    const profile = secondByte >> 5;\n                    const level = secondByte & 0b11111;\n                    const thirdByte = readU8(slice);\n                    const tier = thirdByte >> 7;\n                    const highBitDepth = (thirdByte >> 6) & 1;\n                    const twelveBit = (thirdByte >> 5) & 1;\n                    const monochrome = (thirdByte >> 4) & 1;\n                    const chromaSubsamplingX = (thirdByte >> 3) & 1;\n                    const chromaSubsamplingY = (thirdByte >> 2) & 1;\n                    const chromaSamplePosition = thirdByte & 0b11;\n                    // Logic from https://aomediacodec.github.io/av1-spec/av1-spec.pdf\n                    const bitDepth = profile === 2 && highBitDepth ? (twelveBit ? 12 : 10) : (highBitDepth ? 10 : 8);\n                    track.info.av1CodecInfo = {\n                        profile,\n                        level,\n                        tier,\n                        bitDepth,\n                        monochrome,\n                        chromaSubsamplingX,\n                        chromaSubsamplingY,\n                        chromaSamplePosition,\n                    };\n                }\n                ;\n                break;\n            case 'colr':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'video');\n                    const colourType = readAscii(slice, 4);\n                    if (colourType !== 'nclx') {\n                        break;\n                    }\n                    const colourPrimaries = readU16Be(slice);\n                    const transferCharacteristics = readU16Be(slice);\n                    const matrixCoefficients = readU16Be(slice);\n                    const fullRangeFlag = Boolean(readU8(slice) & 0x80);\n                    track.info.colorSpace = {\n                        primaries: COLOR_PRIMARIES_MAP_INVERSE[colourPrimaries],\n                        transfer: TRANSFER_CHARACTERISTICS_MAP_INVERSE[transferCharacteristics],\n                        matrix: MATRIX_COEFFICIENTS_MAP_INVERSE[matrixCoefficients],\n                        fullRange: fullRangeFlag,\n                    };\n                }\n                ;\n                break;\n            case 'wave':\n                {\n                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                }\n                ;\n                break;\n            case 'esds':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'audio');\n                    slice.skip(4); // Version + flags\n                    const tag = readU8(slice);\n                    assert(tag === 0x03); // ES Descriptor\n                    readIsomVariableInteger(slice); // Length\n                    slice.skip(2); // ES ID\n                    const mixed = readU8(slice);\n                    const streamDependenceFlag = (mixed & 0x80) !== 0;\n                    const urlFlag = (mixed & 0x40) !== 0;\n                    const ocrStreamFlag = (mixed & 0x20) !== 0;\n                    if (streamDependenceFlag) {\n                        slice.skip(2);\n                    }\n                    if (urlFlag) {\n                        const urlLength = readU8(slice);\n                        slice.skip(urlLength);\n                    }\n                    if (ocrStreamFlag) {\n                        slice.skip(2);\n                    }\n                    const decoderConfigTag = readU8(slice);\n                    assert(decoderConfigTag === 0x04); // DecoderConfigDescriptor\n                    const decoderConfigDescriptorLength = readIsomVariableInteger(slice); // Length\n                    const payloadStart = slice.filePos;\n                    const objectTypeIndication = readU8(slice);\n                    if (objectTypeIndication === 0x40 || objectTypeIndication === 0x67) {\n                        track.info.codec = 'aac';\n                        track.info.aacCodecInfo = { isMpeg2: objectTypeIndication === 0x67 };\n                    }\n                    else if (objectTypeIndication === 0x69 || objectTypeIndication === 0x6b) {\n                        track.info.codec = 'mp3';\n                    }\n                    else if (objectTypeIndication === 0xdd) {\n                        track.info.codec = 'vorbis'; // \"nonstandard, gpac uses it\" - FFmpeg\n                    }\n                    else {\n                        console.warn(`Unsupported audio codec (objectTypeIndication ${objectTypeIndication}) - discarding track.`);\n                    }\n                    slice.skip(1 + 3 + 4 + 4);\n                    if (decoderConfigDescriptorLength > slice.filePos - payloadStart) {\n                        // There's a DecoderSpecificInfo at the end, let's read it\n                        const decoderSpecificInfoTag = readU8(slice);\n                        assert(decoderSpecificInfoTag === 0x05); // DecoderSpecificInfo\n                        const decoderSpecificInfoLength = readIsomVariableInteger(slice);\n                        track.info.codecDescription = readBytes(slice, decoderSpecificInfoLength);\n                        if (track.info.codec === 'aac') {\n                            // Let's try to deduce more accurate values directly from the AudioSpecificConfig:\n                            const audioSpecificConfig = parseAacAudioSpecificConfig(track.info.codecDescription);\n                            if (audioSpecificConfig.numberOfChannels !== null) {\n                                track.info.numberOfChannels = audioSpecificConfig.numberOfChannels;\n                            }\n                            if (audioSpecificConfig.sampleRate !== null) {\n                                track.info.sampleRate = audioSpecificConfig.sampleRate;\n                            }\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'enda':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'audio');\n                    const littleEndian = readU16Be(slice) & 0xff; // 0xff is from FFmpeg\n                    if (littleEndian) {\n                        if (track.info.codec === 'pcm-s16be') {\n                            track.info.codec = 'pcm-s16';\n                        }\n                        else if (track.info.codec === 'pcm-s24be') {\n                            track.info.codec = 'pcm-s24';\n                        }\n                        else if (track.info.codec === 'pcm-s32be') {\n                            track.info.codec = 'pcm-s32';\n                        }\n                        else if (track.info.codec === 'pcm-f32be') {\n                            track.info.codec = 'pcm-f32';\n                        }\n                        else if (track.info.codec === 'pcm-f64be') {\n                            track.info.codec = 'pcm-f64';\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'pcmC':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'audio');\n                    slice.skip(1 + 3); // Version + flags\n                    // ISO/IEC 23003-5\n                    const formatFlags = readU8(slice);\n                    const isLittleEndian = Boolean(formatFlags & 0x01);\n                    const pcmSampleSize = readU8(slice);\n                    if (track.info.codec === 'pcm-s16be') {\n                        // ipcm\n                        if (isLittleEndian) {\n                            if (pcmSampleSize === 16) {\n                                track.info.codec = 'pcm-s16';\n                            }\n                            else if (pcmSampleSize === 24) {\n                                track.info.codec = 'pcm-s24';\n                            }\n                            else if (pcmSampleSize === 32) {\n                                track.info.codec = 'pcm-s32';\n                            }\n                            else {\n                                console.warn(`Invalid ipcm sample size ${pcmSampleSize}.`);\n                                track.info.codec = null;\n                            }\n                        }\n                        else {\n                            if (pcmSampleSize === 16) {\n                                track.info.codec = 'pcm-s16be';\n                            }\n                            else if (pcmSampleSize === 24) {\n                                track.info.codec = 'pcm-s24be';\n                            }\n                            else if (pcmSampleSize === 32) {\n                                track.info.codec = 'pcm-s32be';\n                            }\n                            else {\n                                console.warn(`Invalid ipcm sample size ${pcmSampleSize}.`);\n                                track.info.codec = null;\n                            }\n                        }\n                    }\n                    else if (track.info.codec === 'pcm-f32be') {\n                        // fpcm\n                        if (isLittleEndian) {\n                            if (pcmSampleSize === 32) {\n                                track.info.codec = 'pcm-f32';\n                            }\n                            else if (pcmSampleSize === 64) {\n                                track.info.codec = 'pcm-f64';\n                            }\n                            else {\n                                console.warn(`Invalid fpcm sample size ${pcmSampleSize}.`);\n                                track.info.codec = null;\n                            }\n                        }\n                        else {\n                            if (pcmSampleSize === 32) {\n                                track.info.codec = 'pcm-f32be';\n                            }\n                            else if (pcmSampleSize === 64) {\n                                track.info.codec = 'pcm-f64be';\n                            }\n                            else {\n                                console.warn(`Invalid fpcm sample size ${pcmSampleSize}.`);\n                                track.info.codec = null;\n                            }\n                        }\n                    }\n                    break;\n                }\n                ;\n            case 'dOps':\n                { // Used for Opus audio\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'audio');\n                    slice.skip(1); // Version\n                    // https://www.opus-codec.org/docs/opus_in_isobmff.html\n                    const outputChannelCount = readU8(slice);\n                    const preSkip = readU16Be(slice);\n                    const inputSampleRate = readU32Be(slice);\n                    const outputGain = readI16Be(slice);\n                    const channelMappingFamily = readU8(slice);\n                    let channelMappingTable;\n                    if (channelMappingFamily !== 0) {\n                        channelMappingTable = readBytes(slice, 2 + outputChannelCount);\n                    }\n                    else {\n                        channelMappingTable = new Uint8Array(0);\n                    }\n                    // https://datatracker.ietf.org/doc/html/draft-ietf-codec-oggopus-06\n                    const description = new Uint8Array(8 + 1 + 1 + 2 + 4 + 2 + 1 + channelMappingTable.byteLength);\n                    const view = new DataView(description.buffer);\n                    view.setUint32(0, 0x4f707573, false); // 'Opus'\n                    view.setUint32(4, 0x48656164, false); // 'Head'\n                    view.setUint8(8, 1); // Version\n                    view.setUint8(9, outputChannelCount);\n                    view.setUint16(10, preSkip, true);\n                    view.setUint32(12, inputSampleRate, true);\n                    view.setInt16(16, outputGain, true);\n                    view.setUint8(18, channelMappingFamily);\n                    description.set(channelMappingTable, 19);\n                    track.info.codecDescription = description;\n                    track.info.numberOfChannels = outputChannelCount;\n                    // Don't copy the input sample rate, irrelevant, and output sample rate is fixed\n                }\n                ;\n                break;\n            case 'dfLa':\n                { // Used for FLAC audio\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.info?.type === 'audio');\n                    slice.skip(4); // Version + flags\n                    // https://datatracker.ietf.org/doc/rfc9639/\n                    const BLOCK_TYPE_MASK = 0x7f;\n                    const LAST_METADATA_BLOCK_FLAG_MASK = 0x80;\n                    const startPos = slice.filePos;\n                    while (slice.filePos < boxEndPos) {\n                        const flagAndType = readU8(slice);\n                        const metadataBlockLength = readU24Be(slice);\n                        const type = flagAndType & BLOCK_TYPE_MASK;\n                        // It's a STREAMINFO block; let's extract the actual sample rate and channel count\n                        if (type === FlacBlockType.STREAMINFO) {\n                            slice.skip(10);\n                            // Extract sample rate and channel count\n                            const word = readU32Be(slice);\n                            const sampleRate = word >>> 12;\n                            const numberOfChannels = ((word >> 9) & 0b111) + 1;\n                            track.info.sampleRate = sampleRate;\n                            track.info.numberOfChannels = numberOfChannels;\n                            slice.skip(20);\n                        }\n                        else {\n                            // Simply skip ahead to the next block\n                            slice.skip(metadataBlockLength);\n                        }\n                        if (flagAndType & LAST_METADATA_BLOCK_FLAG_MASK) {\n                            break;\n                        }\n                    }\n                    const endPos = slice.filePos;\n                    slice.filePos = startPos;\n                    const bytes = readBytes(slice, endPos - startPos);\n                    const description = new Uint8Array(4 + bytes.byteLength);\n                    const view = new DataView(description.buffer);\n                    view.setUint32(0, 0x664c6143, false); // 'fLaC'\n                    description.set(bytes, 4);\n                    // Set the codec description to be 'fLaC' + all metadata blocks\n                    track.info.codecDescription = description;\n                }\n                ;\n                break;\n            case 'stts':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(4); // Version + flags\n                    const entryCount = readU32Be(slice);\n                    let currentIndex = 0;\n                    let currentTimestamp = 0;\n                    for (let i = 0; i < entryCount; i++) {\n                        const sampleCount = readU32Be(slice);\n                        const sampleDelta = readU32Be(slice);\n                        track.sampleTable.sampleTimingEntries.push({\n                            startIndex: currentIndex,\n                            startDecodeTimestamp: currentTimestamp,\n                            count: sampleCount,\n                            delta: sampleDelta,\n                        });\n                        currentIndex += sampleCount;\n                        currentTimestamp += sampleCount * sampleDelta;\n                    }\n                }\n                ;\n                break;\n            case 'ctts':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(1 + 3); // Version + flags\n                    const entryCount = readU32Be(slice);\n                    let sampleIndex = 0;\n                    for (let i = 0; i < entryCount; i++) {\n                        const sampleCount = readU32Be(slice);\n                        const sampleOffset = readI32Be(slice);\n                        track.sampleTable.sampleCompositionTimeOffsets.push({\n                            startIndex: sampleIndex,\n                            count: sampleCount,\n                            offset: sampleOffset,\n                        });\n                        sampleIndex += sampleCount;\n                    }\n                }\n                ;\n                break;\n            case 'stsz':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(4); // Version + flags\n                    const sampleSize = readU32Be(slice);\n                    const sampleCount = readU32Be(slice);\n                    if (sampleSize === 0) {\n                        for (let i = 0; i < sampleCount; i++) {\n                            const sampleSize = readU32Be(slice);\n                            track.sampleTable.sampleSizes.push(sampleSize);\n                        }\n                    }\n                    else {\n                        track.sampleTable.sampleSizes.push(sampleSize);\n                    }\n                }\n                ;\n                break;\n            case 'stz2':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(4); // Version + flags\n                    slice.skip(3); // Reserved\n                    const fieldSize = readU8(slice); // in bits\n                    const sampleCount = readU32Be(slice);\n                    const bytes = readBytes(slice, Math.ceil(sampleCount * fieldSize / 8));\n                    const bitstream = new Bitstream(bytes);\n                    for (let i = 0; i < sampleCount; i++) {\n                        const sampleSize = bitstream.readBits(fieldSize);\n                        track.sampleTable.sampleSizes.push(sampleSize);\n                    }\n                }\n                ;\n                break;\n            case 'stss':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(4); // Version + flags\n                    track.sampleTable.keySampleIndices = [];\n                    const entryCount = readU32Be(slice);\n                    for (let i = 0; i < entryCount; i++) {\n                        const sampleIndex = readU32Be(slice) - 1; // Convert to 0-indexed\n                        track.sampleTable.keySampleIndices.push(sampleIndex);\n                    }\n                    if (track.sampleTable.keySampleIndices[0] !== 0) {\n                        // Some files don't mark the first sample a key sample, which is basically almost always incorrect.\n                        // Here, we correct for that mistake:\n                        track.sampleTable.keySampleIndices.unshift(0);\n                    }\n                }\n                ;\n                break;\n            case 'stsc':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(4);\n                    const entryCount = readU32Be(slice);\n                    for (let i = 0; i < entryCount; i++) {\n                        const startChunkIndex = readU32Be(slice) - 1; // Convert to 0-indexed\n                        const samplesPerChunk = readU32Be(slice);\n                        const sampleDescriptionIndex = readU32Be(slice);\n                        track.sampleTable.sampleToChunk.push({\n                            startSampleIndex: -1,\n                            startChunkIndex,\n                            samplesPerChunk,\n                            sampleDescriptionIndex,\n                        });\n                    }\n                    let startSampleIndex = 0;\n                    for (let i = 0; i < track.sampleTable.sampleToChunk.length; i++) {\n                        track.sampleTable.sampleToChunk[i].startSampleIndex = startSampleIndex;\n                        if (i < track.sampleTable.sampleToChunk.length - 1) {\n                            const nextChunk = track.sampleTable.sampleToChunk[i + 1];\n                            const chunkCount = nextChunk.startChunkIndex\n                                - track.sampleTable.sampleToChunk[i].startChunkIndex;\n                            startSampleIndex += chunkCount * track.sampleTable.sampleToChunk[i].samplesPerChunk;\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'stco':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(4); // Version + flags\n                    const entryCount = readU32Be(slice);\n                    for (let i = 0; i < entryCount; i++) {\n                        const chunkOffset = readU32Be(slice);\n                        track.sampleTable.chunkOffsets.push(chunkOffset);\n                    }\n                }\n                ;\n                break;\n            case 'co64':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    if (!track.sampleTable) {\n                        break;\n                    }\n                    slice.skip(4); // Version + flags\n                    const entryCount = readU32Be(slice);\n                    for (let i = 0; i < entryCount; i++) {\n                        const chunkOffset = readU64Be(slice);\n                        track.sampleTable.chunkOffsets.push(chunkOffset);\n                    }\n                }\n                ;\n                break;\n            case 'mvex':\n                {\n                    this.isFragmented = true;\n                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                }\n                ;\n                break;\n            case 'mehd':\n                {\n                    const version = readU8(slice);\n                    slice.skip(3); // Flags\n                    const fragmentDuration = version === 1 ? readU64Be(slice) : readU32Be(slice);\n                    this.movieDurationInTimescale = fragmentDuration;\n                }\n                ;\n                break;\n            case 'trex':\n                {\n                    slice.skip(4); // Version + flags\n                    const trackId = readU32Be(slice);\n                    const defaultSampleDescriptionIndex = readU32Be(slice);\n                    const defaultSampleDuration = readU32Be(slice);\n                    const defaultSampleSize = readU32Be(slice);\n                    const defaultSampleFlags = readU32Be(slice);\n                    // We store these separately rather than in the tracks since the tracks may not exist yet\n                    this.fragmentTrackDefaults.push({\n                        trackId,\n                        defaultSampleDescriptionIndex,\n                        defaultSampleDuration,\n                        defaultSampleSize,\n                        defaultSampleFlags,\n                    });\n                }\n                ;\n                break;\n            case 'tfra':\n                {\n                    const version = readU8(slice);\n                    slice.skip(3); // Flags\n                    const trackId = readU32Be(slice);\n                    const track = this.tracks.find(x => x.id === trackId);\n                    if (!track) {\n                        break;\n                    }\n                    const word = readU32Be(slice);\n                    const lengthSizeOfTrafNum = (word & 0b110000) >> 4;\n                    const lengthSizeOfTrunNum = (word & 0b001100) >> 2;\n                    const lengthSizeOfSampleNum = word & 0b000011;\n                    const functions = [readU8, readU16Be, readU24Be, readU32Be];\n                    const readTrafNum = functions[lengthSizeOfTrafNum];\n                    const readTrunNum = functions[lengthSizeOfTrunNum];\n                    const readSampleNum = functions[lengthSizeOfSampleNum];\n                    const numberOfEntries = readU32Be(slice);\n                    for (let i = 0; i < numberOfEntries; i++) {\n                        const time = version === 1 ? readU64Be(slice) : readU32Be(slice);\n                        const moofOffset = version === 1 ? readU64Be(slice) : readU32Be(slice);\n                        readTrafNum(slice);\n                        readTrunNum(slice);\n                        readSampleNum(slice);\n                        track.fragmentLookupTable.push({\n                            timestamp: time,\n                            moofOffset,\n                        });\n                    }\n                    // Sort by timestamp in case it's not naturally sorted\n                    track.fragmentLookupTable.sort((a, b) => a.timestamp - b.timestamp);\n                    // Remove multiple entries for the same time\n                    for (let i = 0; i < track.fragmentLookupTable.length - 1; i++) {\n                        const entry1 = track.fragmentLookupTable[i];\n                        const entry2 = track.fragmentLookupTable[i + 1];\n                        if (entry1.timestamp === entry2.timestamp) {\n                            track.fragmentLookupTable.splice(i + 1, 1);\n                            i--;\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'moof':\n                {\n                    this.currentFragment = {\n                        moofOffset: startPos,\n                        moofSize: boxInfo.totalSize,\n                        implicitBaseDataOffset: startPos,\n                        trackData: new Map(),\n                    };\n                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                    this.lastReadFragment = this.currentFragment;\n                    this.currentFragment = null;\n                }\n                ;\n                break;\n            case 'traf':\n                {\n                    assert(this.currentFragment);\n                    this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                    // It is possible that there is no current track, for example when we don't care about the track\n                    // referenced in the track fragment header.\n                    if (this.currentTrack) {\n                        const trackData = this.currentFragment.trackData.get(this.currentTrack.id);\n                        if (trackData) {\n                            const { currentFragmentState } = this.currentTrack;\n                            assert(currentFragmentState);\n                            if (currentFragmentState.startTimestamp !== null) {\n                                offsetFragmentTrackDataByTimestamp(trackData, currentFragmentState.startTimestamp);\n                                trackData.startTimestampIsFinal = true;\n                            }\n                        }\n                        this.currentTrack.currentFragmentState = null;\n                        this.currentTrack = null;\n                    }\n                }\n                ;\n                break;\n            case 'tfhd':\n                {\n                    assert(this.currentFragment);\n                    slice.skip(1); // Version\n                    const flags = readU24Be(slice);\n                    const baseDataOffsetPresent = Boolean(flags & 0x000001);\n                    const sampleDescriptionIndexPresent = Boolean(flags & 0x000002);\n                    const defaultSampleDurationPresent = Boolean(flags & 0x000008);\n                    const defaultSampleSizePresent = Boolean(flags & 0x000010);\n                    const defaultSampleFlagsPresent = Boolean(flags & 0x000020);\n                    const durationIsEmpty = Boolean(flags & 0x010000);\n                    const defaultBaseIsMoof = Boolean(flags & 0x020000);\n                    const trackId = readU32Be(slice);\n                    const track = this.tracks.find(x => x.id === trackId);\n                    if (!track) {\n                        // We don't care about this track\n                        break;\n                    }\n                    const defaults = this.fragmentTrackDefaults.find(x => x.trackId === trackId);\n                    this.currentTrack = track;\n                    track.currentFragmentState = {\n                        baseDataOffset: this.currentFragment.implicitBaseDataOffset,\n                        sampleDescriptionIndex: defaults?.defaultSampleDescriptionIndex ?? null,\n                        defaultSampleDuration: defaults?.defaultSampleDuration ?? null,\n                        defaultSampleSize: defaults?.defaultSampleSize ?? null,\n                        defaultSampleFlags: defaults?.defaultSampleFlags ?? null,\n                        startTimestamp: null,\n                    };\n                    if (baseDataOffsetPresent) {\n                        track.currentFragmentState.baseDataOffset = readU64Be(slice);\n                    }\n                    else if (defaultBaseIsMoof) {\n                        track.currentFragmentState.baseDataOffset = this.currentFragment.moofOffset;\n                    }\n                    if (sampleDescriptionIndexPresent) {\n                        track.currentFragmentState.sampleDescriptionIndex = readU32Be(slice);\n                    }\n                    if (defaultSampleDurationPresent) {\n                        track.currentFragmentState.defaultSampleDuration = readU32Be(slice);\n                    }\n                    if (defaultSampleSizePresent) {\n                        track.currentFragmentState.defaultSampleSize = readU32Be(slice);\n                    }\n                    if (defaultSampleFlagsPresent) {\n                        track.currentFragmentState.defaultSampleFlags = readU32Be(slice);\n                    }\n                    if (durationIsEmpty) {\n                        track.currentFragmentState.defaultSampleDuration = 0;\n                    }\n                }\n                ;\n                break;\n            case 'tfdt':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(track.currentFragmentState);\n                    const version = readU8(slice);\n                    slice.skip(3); // Flags\n                    const baseMediaDecodeTime = version === 0 ? readU32Be(slice) : readU64Be(slice);\n                    track.currentFragmentState.startTimestamp = baseMediaDecodeTime;\n                }\n                ;\n                break;\n            case 'trun':\n                {\n                    const track = this.currentTrack;\n                    if (!track) {\n                        break;\n                    }\n                    assert(this.currentFragment);\n                    assert(track.currentFragmentState);\n                    if (this.currentFragment.trackData.has(track.id)) {\n                        console.warn('Can\\'t have two trun boxes for the same track in one fragment. Ignoring...');\n                        break;\n                    }\n                    const version = readU8(slice);\n                    const flags = readU24Be(slice);\n                    const dataOffsetPresent = Boolean(flags & 0x000001);\n                    const firstSampleFlagsPresent = Boolean(flags & 0x000004);\n                    const sampleDurationPresent = Boolean(flags & 0x000100);\n                    const sampleSizePresent = Boolean(flags & 0x000200);\n                    const sampleFlagsPresent = Boolean(flags & 0x000400);\n                    const sampleCompositionTimeOffsetsPresent = Boolean(flags & 0x000800);\n                    const sampleCount = readU32Be(slice);\n                    let dataOffset = track.currentFragmentState.baseDataOffset;\n                    if (dataOffsetPresent) {\n                        dataOffset += readI32Be(slice);\n                    }\n                    let firstSampleFlags = null;\n                    if (firstSampleFlagsPresent) {\n                        firstSampleFlags = readU32Be(slice);\n                    }\n                    let currentOffset = dataOffset;\n                    if (sampleCount === 0) {\n                        // Don't associate the fragment with the track if it has no samples, this simplifies other code\n                        this.currentFragment.implicitBaseDataOffset = currentOffset;\n                        break;\n                    }\n                    let currentTimestamp = 0;\n                    const trackData = {\n                        track,\n                        startTimestamp: 0,\n                        endTimestamp: 0,\n                        firstKeyFrameTimestamp: null,\n                        samples: [],\n                        presentationTimestamps: [],\n                        startTimestampIsFinal: false,\n                    };\n                    this.currentFragment.trackData.set(track.id, trackData);\n                    for (let i = 0; i < sampleCount; i++) {\n                        let sampleDuration;\n                        if (sampleDurationPresent) {\n                            sampleDuration = readU32Be(slice);\n                        }\n                        else {\n                            assert(track.currentFragmentState.defaultSampleDuration !== null);\n                            sampleDuration = track.currentFragmentState.defaultSampleDuration;\n                        }\n                        let sampleSize;\n                        if (sampleSizePresent) {\n                            sampleSize = readU32Be(slice);\n                        }\n                        else {\n                            assert(track.currentFragmentState.defaultSampleSize !== null);\n                            sampleSize = track.currentFragmentState.defaultSampleSize;\n                        }\n                        let sampleFlags;\n                        if (sampleFlagsPresent) {\n                            sampleFlags = readU32Be(slice);\n                        }\n                        else {\n                            assert(track.currentFragmentState.defaultSampleFlags !== null);\n                            sampleFlags = track.currentFragmentState.defaultSampleFlags;\n                        }\n                        if (i === 0 && firstSampleFlags !== null) {\n                            sampleFlags = firstSampleFlags;\n                        }\n                        let sampleCompositionTimeOffset = 0;\n                        if (sampleCompositionTimeOffsetsPresent) {\n                            if (version === 0) {\n                                sampleCompositionTimeOffset = readU32Be(slice);\n                            }\n                            else {\n                                sampleCompositionTimeOffset = readI32Be(slice);\n                            }\n                        }\n                        const isKeyFrame = !(sampleFlags & 0x00010000);\n                        trackData.samples.push({\n                            presentationTimestamp: currentTimestamp + sampleCompositionTimeOffset,\n                            duration: sampleDuration,\n                            byteOffset: currentOffset,\n                            byteSize: sampleSize,\n                            isKeyFrame,\n                        });\n                        currentOffset += sampleSize;\n                        currentTimestamp += sampleDuration;\n                    }\n                    trackData.presentationTimestamps = trackData.samples\n                        .map((x, i) => ({ presentationTimestamp: x.presentationTimestamp, sampleIndex: i }))\n                        .sort((a, b) => a.presentationTimestamp - b.presentationTimestamp);\n                    for (let i = 0; i < trackData.presentationTimestamps.length; i++) {\n                        const currentEntry = trackData.presentationTimestamps[i];\n                        const currentSample = trackData.samples[currentEntry.sampleIndex];\n                        if (trackData.firstKeyFrameTimestamp === null && currentSample.isKeyFrame) {\n                            trackData.firstKeyFrameTimestamp = currentSample.presentationTimestamp;\n                        }\n                        if (i < trackData.presentationTimestamps.length - 1) {\n                            // Update sample durations based on presentation order\n                            const nextEntry = trackData.presentationTimestamps[i + 1];\n                            currentSample.duration = nextEntry.presentationTimestamp - currentEntry.presentationTimestamp;\n                        }\n                    }\n                    const firstSample = trackData.samples[trackData.presentationTimestamps[0].sampleIndex];\n                    const lastSample = trackData.samples[last(trackData.presentationTimestamps).sampleIndex];\n                    trackData.startTimestamp = firstSample.presentationTimestamp;\n                    trackData.endTimestamp = lastSample.presentationTimestamp + lastSample.duration;\n                    this.currentFragment.implicitBaseDataOffset = currentOffset;\n                }\n                ;\n                break;\n            // Metadata section\n            // https://exiftool.org/TagNames/QuickTime.html\n            // https://mp4workshop.com/about\n            case 'udta':\n                { // Contains either movie metadata or track metadata\n                    const iterator = this.iterateContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                    for (const { boxInfo, slice } of iterator) {\n                        if (boxInfo.name !== 'meta' && !this.currentTrack) {\n                            const startPos = slice.filePos;\n                            this.metadataTags.raw ??= {};\n                            if (boxInfo.name[0] === '') {\n                                // https://mp4workshop.com/about\n                                // Box name starting with  indicates \"international text\"\n                                this.metadataTags.raw[boxInfo.name] ??= readMetadataStringShort(slice);\n                            }\n                            else {\n                                this.metadataTags.raw[boxInfo.name] ??= readBytes(slice, boxInfo.contentSize);\n                            }\n                            slice.filePos = startPos;\n                        }\n                        switch (boxInfo.name) {\n                            case 'meta':\n                                {\n                                    slice.skip(-boxInfo.headerSize);\n                                    this.traverseBox(slice);\n                                }\n                                ;\n                                break;\n                            case 'nam':\n                            case 'name':\n                                {\n                                    if (this.currentTrack) {\n                                        this.currentTrack.name = textDecoder.decode(readBytes(slice, boxInfo.contentSize));\n                                    }\n                                    else {\n                                        this.metadataTags.title ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'des':\n                                {\n                                    if (!this.currentTrack) {\n                                        this.metadataTags.description ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'ART':\n                                {\n                                    if (!this.currentTrack) {\n                                        this.metadataTags.artist ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'alb':\n                                {\n                                    if (!this.currentTrack) {\n                                        this.metadataTags.album ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'albr':\n                                {\n                                    if (!this.currentTrack) {\n                                        this.metadataTags.albumArtist ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'gen':\n                                {\n                                    if (!this.currentTrack) {\n                                        this.metadataTags.genre ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'day':\n                                {\n                                    if (!this.currentTrack) {\n                                        const date = new Date(readMetadataStringShort(slice));\n                                        if (!Number.isNaN(date.getTime())) {\n                                            this.metadataTags.date ??= date;\n                                        }\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'cmt':\n                                {\n                                    if (!this.currentTrack) {\n                                        this.metadataTags.comment ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'lyr':\n                                {\n                                    if (!this.currentTrack) {\n                                        this.metadataTags.lyrics ??= readMetadataStringShort(slice);\n                                    }\n                                }\n                                ;\n                                break;\n                        }\n                    }\n                }\n                ;\n                break;\n            case 'meta':\n                {\n                    if (this.currentTrack) {\n                        break; // Only care about movie-level metadata for now\n                    }\n                    // The 'meta' box comes in two flavors, one with flags/version and one without. To know which is which,\n                    // let's read the next 4 bytes, which are either the version or the size of the first subbox.\n                    const word = readU32Be(slice);\n                    const isQuickTime = word !== 0;\n                    this.currentMetadataKeys = new Map();\n                    if (isQuickTime) {\n                        this.readContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                    }\n                    else {\n                        this.readContiguousBoxes(slice.slice(contentStartPos + 4, boxInfo.contentSize - 4));\n                    }\n                    this.currentMetadataKeys = null;\n                }\n                ;\n                break;\n            case 'keys':\n                {\n                    if (!this.currentMetadataKeys) {\n                        break;\n                    }\n                    slice.skip(4); // Version + flags\n                    const entryCount = readU32Be(slice);\n                    for (let i = 0; i < entryCount; i++) {\n                        const keySize = readU32Be(slice);\n                        slice.skip(4); // Key namespace\n                        const keyName = textDecoder.decode(readBytes(slice, keySize - 8));\n                        this.currentMetadataKeys.set(i + 1, keyName);\n                    }\n                }\n                ;\n                break;\n            case 'ilst':\n                {\n                    if (!this.currentMetadataKeys) {\n                        break;\n                    }\n                    const iterator = this.iterateContiguousBoxes(slice.slice(contentStartPos, boxInfo.contentSize));\n                    for (const { boxInfo, slice } of iterator) {\n                        let metadataKey = boxInfo.name;\n                        // Interpret the box name as a u32be\n                        const nameAsNumber = (metadataKey.charCodeAt(0) << 24)\n                            + (metadataKey.charCodeAt(1) << 16)\n                            + (metadataKey.charCodeAt(2) << 8)\n                            + metadataKey.charCodeAt(3);\n                        if (this.currentMetadataKeys.has(nameAsNumber)) {\n                            // An entry exists for this number\n                            metadataKey = this.currentMetadataKeys.get(nameAsNumber);\n                        }\n                        const data = readDataBox(slice);\n                        this.metadataTags.raw ??= {};\n                        this.metadataTags.raw[metadataKey] ??= data;\n                        switch (metadataKey) {\n                            case 'nam':\n                            case 'titl':\n                            case 'com.apple.quicktime.title':\n                            case 'title':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.title ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'des':\n                            case 'desc':\n                            case 'dscp':\n                            case 'com.apple.quicktime.description':\n                            case 'description':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.description ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'ART':\n                            case 'com.apple.quicktime.artist':\n                            case 'artist':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.artist ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'alb':\n                            case 'albm':\n                            case 'com.apple.quicktime.album':\n                            case 'album':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.album ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'aART':\n                            case 'album_artist':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.albumArtist ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'cmt':\n                            case 'com.apple.quicktime.comment':\n                            case 'comment':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.comment ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'gen':\n                            case 'gnre':\n                            case 'com.apple.quicktime.genre':\n                            case 'genre':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.genre ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'lyr':\n                            case 'lyrics':\n                                {\n                                    if (typeof data === 'string') {\n                                        this.metadataTags.lyrics ??= data;\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'day':\n                            case 'rldt':\n                            case 'com.apple.quicktime.creationdate':\n                            case 'date':\n                                {\n                                    if (typeof data === 'string') {\n                                        const date = new Date(data);\n                                        if (!Number.isNaN(date.getTime())) {\n                                            this.metadataTags.date ??= date;\n                                        }\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'covr':\n                            case 'com.apple.quicktime.artwork':\n                                {\n                                    if (data instanceof RichImageData) {\n                                        this.metadataTags.images ??= [];\n                                        this.metadataTags.images.push({\n                                            data: data.data,\n                                            kind: 'coverFront',\n                                            mimeType: data.mimeType,\n                                        });\n                                    }\n                                    else if (data instanceof Uint8Array) {\n                                        this.metadataTags.images ??= [];\n                                        this.metadataTags.images.push({\n                                            data,\n                                            kind: 'coverFront',\n                                            mimeType: 'image/*',\n                                        });\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'track':\n                                {\n                                    if (typeof data === 'string') {\n                                        const parts = data.split('/');\n                                        const trackNum = Number.parseInt(parts[0], 10);\n                                        const tracksTotal = parts[1] && Number.parseInt(parts[1], 10);\n                                        if (Number.isInteger(trackNum) && trackNum > 0) {\n                                            this.metadataTags.trackNumber ??= trackNum;\n                                        }\n                                        if (tracksTotal && Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                                            this.metadataTags.tracksTotal ??= tracksTotal;\n                                        }\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'trkn':\n                                {\n                                    if (data instanceof Uint8Array && data.length >= 6) {\n                                        const view = toDataView(data);\n                                        const trackNumber = view.getUint16(2, false);\n                                        const tracksTotal = view.getUint16(4, false);\n                                        if (trackNumber > 0) {\n                                            this.metadataTags.trackNumber ??= trackNumber;\n                                        }\n                                        if (tracksTotal > 0) {\n                                            this.metadataTags.tracksTotal ??= tracksTotal;\n                                        }\n                                    }\n                                }\n                                ;\n                                break;\n                            case 'disc':\n                            case 'disk':\n                                {\n                                    if (data instanceof Uint8Array && data.length >= 6) {\n                                        const view = toDataView(data);\n                                        const discNumber = view.getUint16(2, false);\n                                        const discNumberMax = view.getUint16(4, false);\n                                        if (discNumber > 0) {\n                                            this.metadataTags.discNumber ??= discNumber;\n                                        }\n                                        if (discNumberMax > 0) {\n                                            this.metadataTags.discsTotal ??= discNumberMax;\n                                        }\n                                    }\n                                }\n                                ;\n                                break;\n                        }\n                    }\n                }\n                ;\n                break;\n        }\n        slice.filePos = boxEndPos;\n        return true;\n    }\n}\nclass IsobmffTrackBacking {\n    constructor(internalTrack) {\n        this.internalTrack = internalTrack;\n        this.packetToSampleIndex = new WeakMap();\n        this.packetToFragmentLocation = new WeakMap();\n    }\n    getId() {\n        return this.internalTrack.id;\n    }\n    getCodec() {\n        throw new Error('Not implemented on base class.');\n    }\n    getInternalCodecId() {\n        return this.internalTrack.internalCodecId;\n    }\n    getName() {\n        return this.internalTrack.name;\n    }\n    getLanguageCode() {\n        return this.internalTrack.languageCode;\n    }\n    getTimeResolution() {\n        return this.internalTrack.timescale;\n    }\n    getDisposition() {\n        return this.internalTrack.disposition;\n    }\n    async computeDuration() {\n        const lastPacket = await this.getPacket(Infinity, { metadataOnly: true });\n        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);\n    }\n    async getFirstTimestamp() {\n        const firstPacket = await this.getFirstPacket({ metadataOnly: true });\n        return firstPacket?.timestamp ?? 0;\n    }\n    async getFirstPacket(options) {\n        const regularPacket = await this.fetchPacketForSampleIndex(0, options);\n        if (regularPacket || !this.internalTrack.demuxer.isFragmented) {\n            // If there's a non-fragmented packet, always prefer that\n            return regularPacket;\n        }\n        return this.performFragmentedLookup(null, (fragment) => {\n            const trackData = fragment.trackData.get(this.internalTrack.id);\n            if (trackData) {\n                return {\n                    sampleIndex: 0,\n                    correctSampleFound: true,\n                };\n            }\n            return {\n                sampleIndex: -1,\n                correctSampleFound: false,\n            };\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the lookup entries\n        Infinity, options);\n    }\n    mapTimestampIntoTimescale(timestamp) {\n        // Do a little rounding to catch cases where the result is very close to an integer. If it is, it's likely\n        // that the number was originally an integer divided by the timescale. For stability, it's best\n        // to return the integer in this case.\n        return roundIfAlmostInteger(timestamp * this.internalTrack.timescale) + this.internalTrack.editListOffset;\n    }\n    async getPacket(timestamp, options) {\n        const timestampInTimescale = this.mapTimestampIntoTimescale(timestamp);\n        const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);\n        const sampleIndex = getSampleIndexForTimestamp(sampleTable, timestampInTimescale);\n        const regularPacket = await this.fetchPacketForSampleIndex(sampleIndex, options);\n        if (!sampleTableIsEmpty(sampleTable) || !this.internalTrack.demuxer.isFragmented) {\n            // Prefer the non-fragmented packet\n            return regularPacket;\n        }\n        return this.performFragmentedLookup(null, (fragment) => {\n            const trackData = fragment.trackData.get(this.internalTrack.id);\n            if (!trackData) {\n                return { sampleIndex: -1, correctSampleFound: false };\n            }\n            const index = binarySearchLessOrEqual(trackData.presentationTimestamps, timestampInTimescale, x => x.presentationTimestamp);\n            const sampleIndex = index !== -1 ? trackData.presentationTimestamps[index].sampleIndex : -1;\n            const correctSampleFound = index !== -1 && timestampInTimescale < trackData.endTimestamp;\n            return { sampleIndex, correctSampleFound };\n        }, timestampInTimescale, timestampInTimescale, options);\n    }\n    async getNextPacket(packet, options) {\n        const regularSampleIndex = this.packetToSampleIndex.get(packet);\n        if (regularSampleIndex !== undefined) {\n            // Prefer the non-fragmented packet\n            return this.fetchPacketForSampleIndex(regularSampleIndex + 1, options);\n        }\n        const locationInFragment = this.packetToFragmentLocation.get(packet);\n        if (locationInFragment === undefined) {\n            throw new Error('Packet was not created from this track.');\n        }\n        return this.performFragmentedLookup(locationInFragment.fragment, (fragment) => {\n            if (fragment === locationInFragment.fragment) {\n                const trackData = fragment.trackData.get(this.internalTrack.id);\n                if (locationInFragment.sampleIndex + 1 < trackData.samples.length) {\n                    // We can simply take the next sample in the fragment\n                    return {\n                        sampleIndex: locationInFragment.sampleIndex + 1,\n                        correctSampleFound: true,\n                    };\n                }\n            }\n            else {\n                const trackData = fragment.trackData.get(this.internalTrack.id);\n                if (trackData) {\n                    return {\n                        sampleIndex: 0,\n                        correctSampleFound: true,\n                    };\n                }\n            }\n            return {\n                sampleIndex: -1,\n                correctSampleFound: false,\n            };\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the lookup entries\n        Infinity, options);\n    }\n    async getKeyPacket(timestamp, options) {\n        const timestampInTimescale = this.mapTimestampIntoTimescale(timestamp);\n        const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);\n        const sampleIndex = getKeyframeSampleIndexForTimestamp(sampleTable, timestampInTimescale);\n        const regularPacket = await this.fetchPacketForSampleIndex(sampleIndex, options);\n        if (!sampleTableIsEmpty(sampleTable) || !this.internalTrack.demuxer.isFragmented) {\n            // Prefer the non-fragmented packet\n            return regularPacket;\n        }\n        return this.performFragmentedLookup(null, (fragment) => {\n            const trackData = fragment.trackData.get(this.internalTrack.id);\n            if (!trackData) {\n                return { sampleIndex: -1, correctSampleFound: false };\n            }\n            const index = findLastIndex(trackData.presentationTimestamps, (x) => {\n                const sample = trackData.samples[x.sampleIndex];\n                return sample.isKeyFrame && x.presentationTimestamp <= timestampInTimescale;\n            });\n            const sampleIndex = index !== -1 ? trackData.presentationTimestamps[index].sampleIndex : -1;\n            const correctSampleFound = index !== -1 && timestampInTimescale < trackData.endTimestamp;\n            return { sampleIndex, correctSampleFound };\n        }, timestampInTimescale, timestampInTimescale, options);\n    }\n    async getNextKeyPacket(packet, options) {\n        const regularSampleIndex = this.packetToSampleIndex.get(packet);\n        if (regularSampleIndex !== undefined) {\n            // Prefer the non-fragmented packet\n            const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);\n            const nextKeyFrameSampleIndex = getNextKeyframeIndexForSample(sampleTable, regularSampleIndex);\n            return this.fetchPacketForSampleIndex(nextKeyFrameSampleIndex, options);\n        }\n        const locationInFragment = this.packetToFragmentLocation.get(packet);\n        if (locationInFragment === undefined) {\n            throw new Error('Packet was not created from this track.');\n        }\n        return this.performFragmentedLookup(locationInFragment.fragment, (fragment) => {\n            if (fragment === locationInFragment.fragment) {\n                const trackData = fragment.trackData.get(this.internalTrack.id);\n                const nextKeyFrameIndex = trackData.samples.findIndex((x, i) => x.isKeyFrame && i > locationInFragment.sampleIndex);\n                if (nextKeyFrameIndex !== -1) {\n                    // We can simply take the next key frame in the fragment\n                    return {\n                        sampleIndex: nextKeyFrameIndex,\n                        correctSampleFound: true,\n                    };\n                }\n            }\n            else {\n                const trackData = fragment.trackData.get(this.internalTrack.id);\n                if (trackData && trackData.firstKeyFrameTimestamp !== null) {\n                    const keyFrameIndex = trackData.samples.findIndex(x => x.isKeyFrame);\n                    assert(keyFrameIndex !== -1); // There must be one\n                    return {\n                        sampleIndex: keyFrameIndex,\n                        correctSampleFound: true,\n                    };\n                }\n            }\n            return {\n                sampleIndex: -1,\n                correctSampleFound: false,\n            };\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the lookup entries\n        Infinity, options);\n    }\n    async fetchPacketForSampleIndex(sampleIndex, options) {\n        if (sampleIndex === -1) {\n            return null;\n        }\n        const sampleTable = this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack);\n        const sampleInfo = getSampleInfo(sampleTable, sampleIndex);\n        if (!sampleInfo) {\n            return null;\n        }\n        let data;\n        if (options.metadataOnly) {\n            data = PLACEHOLDER_DATA;\n        }\n        else {\n            let slice = this.internalTrack.demuxer.reader.requestSlice(sampleInfo.sampleOffset, sampleInfo.sampleSize);\n            if (slice instanceof Promise)\n                slice = await slice;\n            assert(slice);\n            data = readBytes(slice, sampleInfo.sampleSize);\n        }\n        const timestamp = (sampleInfo.presentationTimestamp - this.internalTrack.editListOffset)\n            / this.internalTrack.timescale;\n        const duration = sampleInfo.duration / this.internalTrack.timescale;\n        const packet = new EncodedPacket(data, sampleInfo.isKeyFrame ? 'key' : 'delta', timestamp, duration, sampleIndex, sampleInfo.sampleSize);\n        this.packetToSampleIndex.set(packet, sampleIndex);\n        return packet;\n    }\n    async fetchPacketInFragment(fragment, sampleIndex, options) {\n        if (sampleIndex === -1) {\n            return null;\n        }\n        const trackData = fragment.trackData.get(this.internalTrack.id);\n        const fragmentSample = trackData.samples[sampleIndex];\n        assert(fragmentSample);\n        let data;\n        if (options.metadataOnly) {\n            data = PLACEHOLDER_DATA;\n        }\n        else {\n            let slice = this.internalTrack.demuxer.reader.requestSlice(fragmentSample.byteOffset, fragmentSample.byteSize);\n            if (slice instanceof Promise)\n                slice = await slice;\n            assert(slice);\n            data = readBytes(slice, fragmentSample.byteSize);\n        }\n        const timestamp = (fragmentSample.presentationTimestamp - this.internalTrack.editListOffset)\n            / this.internalTrack.timescale;\n        const duration = fragmentSample.duration / this.internalTrack.timescale;\n        const packet = new EncodedPacket(data, fragmentSample.isKeyFrame ? 'key' : 'delta', timestamp, duration, fragment.moofOffset + sampleIndex, fragmentSample.byteSize);\n        this.packetToFragmentLocation.set(packet, { fragment, sampleIndex });\n        return packet;\n    }\n    /** Looks for a packet in the fragments while trying to load as few fragments as possible to retrieve it. */\n    async performFragmentedLookup(\n    // The fragment where we start looking\n    startFragment, \n    // This function returns the best-matching sample in a given fragment\n    getMatchInFragment, \n    // The timestamp with which we can search the lookup table\n    searchTimestamp, \n    // The timestamp for which we know the correct sample will not come after it\n    latestTimestamp, options) {\n        const demuxer = this.internalTrack.demuxer;\n        let currentFragment = null;\n        let bestFragment = null;\n        let bestSampleIndex = -1;\n        if (startFragment) {\n            const { sampleIndex, correctSampleFound } = getMatchInFragment(startFragment);\n            if (correctSampleFound) {\n                return this.fetchPacketInFragment(startFragment, sampleIndex, options);\n            }\n            if (sampleIndex !== -1) {\n                bestFragment = startFragment;\n                bestSampleIndex = sampleIndex;\n            }\n        }\n        // Search for a lookup entry; this way, we won't need to start searching from the start of the file\n        // but can jump right into the correct fragment (or at least nearby).\n        const lookupEntryIndex = binarySearchLessOrEqual(this.internalTrack.fragmentLookupTable, searchTimestamp, x => x.timestamp);\n        const lookupEntry = lookupEntryIndex !== -1\n            ? this.internalTrack.fragmentLookupTable[lookupEntryIndex]\n            : null;\n        const positionCacheIndex = binarySearchLessOrEqual(this.internalTrack.fragmentPositionCache, searchTimestamp, x => x.startTimestamp);\n        const positionCacheEntry = positionCacheIndex !== -1\n            ? this.internalTrack.fragmentPositionCache[positionCacheIndex]\n            : null;\n        const lookupEntryPosition = Math.max(lookupEntry?.moofOffset ?? 0, positionCacheEntry?.moofOffset ?? 0) || null;\n        let currentPos;\n        if (!startFragment) {\n            currentPos = lookupEntryPosition ?? 0;\n        }\n        else {\n            if (lookupEntryPosition === null || startFragment.moofOffset >= lookupEntryPosition) {\n                currentPos = startFragment.moofOffset + startFragment.moofSize;\n                currentFragment = startFragment;\n            }\n            else {\n                // Use the lookup entry\n                currentPos = lookupEntryPosition;\n            }\n        }\n        while (true) {\n            if (currentFragment) {\n                const trackData = currentFragment.trackData.get(this.internalTrack.id);\n                if (trackData && trackData.startTimestamp > latestTimestamp) {\n                    // We're already past the upper bound, no need to keep searching\n                    break;\n                }\n            }\n            // Load the header\n            let slice = demuxer.reader.requestSliceRange(currentPos, MIN_BOX_HEADER_SIZE, MAX_BOX_HEADER_SIZE);\n            if (slice instanceof Promise)\n                slice = await slice;\n            if (!slice)\n                break;\n            const boxStartPos = currentPos;\n            const boxInfo = readBoxHeader(slice);\n            if (!boxInfo) {\n                break;\n            }\n            if (boxInfo.name === 'moof') {\n                currentFragment = await demuxer.readFragment(boxStartPos);\n                const { sampleIndex, correctSampleFound } = getMatchInFragment(currentFragment);\n                if (correctSampleFound) {\n                    return this.fetchPacketInFragment(currentFragment, sampleIndex, options);\n                }\n                if (sampleIndex !== -1) {\n                    bestFragment = currentFragment;\n                    bestSampleIndex = sampleIndex;\n                }\n            }\n            currentPos = boxStartPos + boxInfo.totalSize;\n        }\n        // Catch faulty lookup table entries\n        if (lookupEntry && (!bestFragment || bestFragment.moofOffset < lookupEntry.moofOffset)) {\n            // The lookup table entry lied to us! We found a lookup entry but no fragment there that satisfied\n            // the match. In this case, let's search again but using the lookup entry before that.\n            const previousLookupEntry = this.internalTrack.fragmentLookupTable[lookupEntryIndex - 1];\n            assert(!previousLookupEntry || previousLookupEntry.timestamp < lookupEntry.timestamp);\n            const newSearchTimestamp = previousLookupEntry?.timestamp ?? -Infinity;\n            return this.performFragmentedLookup(null, getMatchInFragment, newSearchTimestamp, latestTimestamp, options);\n        }\n        if (bestFragment) {\n            // If we finished looping but didn't find a perfect match, still return the best match we found\n            return this.fetchPacketInFragment(bestFragment, bestSampleIndex, options);\n        }\n        return null;\n    }\n}\nclass IsobmffVideoTrackBacking extends IsobmffTrackBacking {\n    constructor(internalTrack) {\n        super(internalTrack);\n        this.decoderConfigPromise = null;\n        this.internalTrack = internalTrack;\n    }\n    getCodec() {\n        return this.internalTrack.info.codec;\n    }\n    getCodedWidth() {\n        return this.internalTrack.info.width;\n    }\n    getCodedHeight() {\n        return this.internalTrack.info.height;\n    }\n    getRotation() {\n        return this.internalTrack.rotation;\n    }\n    async getColorSpace() {\n        return {\n            primaries: this.internalTrack.info.colorSpace?.primaries,\n            transfer: this.internalTrack.info.colorSpace?.transfer,\n            matrix: this.internalTrack.info.colorSpace?.matrix,\n            fullRange: this.internalTrack.info.colorSpace?.fullRange,\n        };\n    }\n    async canBeTransparent() {\n        return false;\n    }\n    async getDecoderConfig() {\n        if (!this.internalTrack.info.codec) {\n            return null;\n        }\n        return this.decoderConfigPromise ??= (async () => {\n            if (this.internalTrack.info.codec === 'vp9' && !this.internalTrack.info.vp9CodecInfo) {\n                const firstPacket = await this.getFirstPacket({});\n                this.internalTrack.info.vp9CodecInfo = firstPacket && extractVp9CodecInfoFromPacket(firstPacket.data);\n            }\n            else if (this.internalTrack.info.codec === 'av1' && !this.internalTrack.info.av1CodecInfo) {\n                const firstPacket = await this.getFirstPacket({});\n                this.internalTrack.info.av1CodecInfo = firstPacket && extractAv1CodecInfoFromPacket(firstPacket.data);\n            }\n            return {\n                codec: extractVideoCodecString(this.internalTrack.info),\n                codedWidth: this.internalTrack.info.width,\n                codedHeight: this.internalTrack.info.height,\n                description: this.internalTrack.info.codecDescription ?? undefined,\n                colorSpace: this.internalTrack.info.colorSpace ?? undefined,\n            };\n        })();\n    }\n}\nclass IsobmffAudioTrackBacking extends IsobmffTrackBacking {\n    constructor(internalTrack) {\n        super(internalTrack);\n        this.decoderConfig = null;\n        this.internalTrack = internalTrack;\n    }\n    getCodec() {\n        return this.internalTrack.info.codec;\n    }\n    getNumberOfChannels() {\n        return this.internalTrack.info.numberOfChannels;\n    }\n    getSampleRate() {\n        return this.internalTrack.info.sampleRate;\n    }\n    async getDecoderConfig() {\n        if (!this.internalTrack.info.codec) {\n            return null;\n        }\n        return this.decoderConfig ??= {\n            codec: extractAudioCodecString(this.internalTrack.info),\n            numberOfChannels: this.internalTrack.info.numberOfChannels,\n            sampleRate: this.internalTrack.info.sampleRate,\n            description: this.internalTrack.info.codecDescription ?? undefined,\n        };\n    }\n}\nconst getSampleIndexForTimestamp = (sampleTable, timescaleUnits) => {\n    if (sampleTable.presentationTimestamps) {\n        const index = binarySearchLessOrEqual(sampleTable.presentationTimestamps, timescaleUnits, x => x.presentationTimestamp);\n        if (index === -1) {\n            return -1;\n        }\n        return sampleTable.presentationTimestamps[index].sampleIndex;\n    }\n    else {\n        const index = binarySearchLessOrEqual(sampleTable.sampleTimingEntries, timescaleUnits, x => x.startDecodeTimestamp);\n        if (index === -1) {\n            return -1;\n        }\n        const entry = sampleTable.sampleTimingEntries[index];\n        return entry.startIndex\n            + Math.min(Math.floor((timescaleUnits - entry.startDecodeTimestamp) / entry.delta), entry.count - 1);\n    }\n};\nconst getKeyframeSampleIndexForTimestamp = (sampleTable, timescaleUnits) => {\n    if (!sampleTable.keySampleIndices) {\n        // Every sample is a keyframe\n        return getSampleIndexForTimestamp(sampleTable, timescaleUnits);\n    }\n    if (sampleTable.presentationTimestamps) {\n        const index = binarySearchLessOrEqual(sampleTable.presentationTimestamps, timescaleUnits, x => x.presentationTimestamp);\n        if (index === -1) {\n            return -1;\n        }\n        // Walk the samples in presentation order until we find one that's a keyframe\n        for (let i = index; i >= 0; i--) {\n            const sampleIndex = sampleTable.presentationTimestamps[i].sampleIndex;\n            const isKeyFrame = binarySearchExact(sampleTable.keySampleIndices, sampleIndex, x => x) !== -1;\n            if (isKeyFrame) {\n                return sampleIndex;\n            }\n        }\n        return -1;\n    }\n    else {\n        const sampleIndex = getSampleIndexForTimestamp(sampleTable, timescaleUnits);\n        const index = binarySearchLessOrEqual(sampleTable.keySampleIndices, sampleIndex, x => x);\n        return sampleTable.keySampleIndices[index] ?? -1;\n    }\n};\nconst getSampleInfo = (sampleTable, sampleIndex) => {\n    const timingEntryIndex = binarySearchLessOrEqual(sampleTable.sampleTimingEntries, sampleIndex, x => x.startIndex);\n    const timingEntry = sampleTable.sampleTimingEntries[timingEntryIndex];\n    if (!timingEntry || timingEntry.startIndex + timingEntry.count <= sampleIndex) {\n        return null;\n    }\n    const decodeTimestamp = timingEntry.startDecodeTimestamp\n        + (sampleIndex - timingEntry.startIndex) * timingEntry.delta;\n    let presentationTimestamp = decodeTimestamp;\n    const offsetEntryIndex = binarySearchLessOrEqual(sampleTable.sampleCompositionTimeOffsets, sampleIndex, x => x.startIndex);\n    const offsetEntry = sampleTable.sampleCompositionTimeOffsets[offsetEntryIndex];\n    if (offsetEntry && sampleIndex - offsetEntry.startIndex < offsetEntry.count) {\n        presentationTimestamp += offsetEntry.offset;\n    }\n    const sampleSize = sampleTable.sampleSizes[Math.min(sampleIndex, sampleTable.sampleSizes.length - 1)];\n    const chunkEntryIndex = binarySearchLessOrEqual(sampleTable.sampleToChunk, sampleIndex, x => x.startSampleIndex);\n    const chunkEntry = sampleTable.sampleToChunk[chunkEntryIndex];\n    assert(chunkEntry);\n    const chunkIndex = chunkEntry.startChunkIndex\n        + Math.floor((sampleIndex - chunkEntry.startSampleIndex) / chunkEntry.samplesPerChunk);\n    const chunkOffset = sampleTable.chunkOffsets[chunkIndex];\n    const startSampleIndexOfChunk = chunkEntry.startSampleIndex\n        + (chunkIndex - chunkEntry.startChunkIndex) * chunkEntry.samplesPerChunk;\n    let chunkSize = 0;\n    let sampleOffset = chunkOffset;\n    if (sampleTable.sampleSizes.length === 1) {\n        sampleOffset += sampleSize * (sampleIndex - startSampleIndexOfChunk);\n        chunkSize += sampleSize * chunkEntry.samplesPerChunk;\n    }\n    else {\n        for (let i = startSampleIndexOfChunk; i < startSampleIndexOfChunk + chunkEntry.samplesPerChunk; i++) {\n            const sampleSize = sampleTable.sampleSizes[i];\n            if (i < sampleIndex) {\n                sampleOffset += sampleSize;\n            }\n            chunkSize += sampleSize;\n        }\n    }\n    let duration = timingEntry.delta;\n    if (sampleTable.presentationTimestamps) {\n        // In order to accurately compute the duration, we need to take the duration to the next sample in presentation\n        // order, not in decode order\n        const presentationIndex = sampleTable.presentationTimestampIndexMap[sampleIndex];\n        assert(presentationIndex !== undefined);\n        if (presentationIndex < sampleTable.presentationTimestamps.length - 1) {\n            const nextEntry = sampleTable.presentationTimestamps[presentationIndex + 1];\n            const nextPresentationTimestamp = nextEntry.presentationTimestamp;\n            duration = nextPresentationTimestamp - presentationTimestamp;\n        }\n    }\n    return {\n        presentationTimestamp,\n        duration,\n        sampleOffset,\n        sampleSize,\n        chunkOffset,\n        chunkSize,\n        isKeyFrame: sampleTable.keySampleIndices\n            ? binarySearchExact(sampleTable.keySampleIndices, sampleIndex, x => x) !== -1\n            : true,\n    };\n};\nconst getNextKeyframeIndexForSample = (sampleTable, sampleIndex) => {\n    if (!sampleTable.keySampleIndices) {\n        return sampleIndex + 1;\n    }\n    const index = binarySearchLessOrEqual(sampleTable.keySampleIndices, sampleIndex, x => x);\n    return sampleTable.keySampleIndices[index + 1] ?? -1;\n};\nconst offsetFragmentTrackDataByTimestamp = (trackData, timestamp) => {\n    trackData.startTimestamp += timestamp;\n    trackData.endTimestamp += timestamp;\n    for (const sample of trackData.samples) {\n        sample.presentationTimestamp += timestamp;\n    }\n    for (const entry of trackData.presentationTimestamps) {\n        entry.presentationTimestamp += timestamp;\n    }\n};\n/** Extracts the rotation component from a transformation matrix, in degrees. */\nconst extractRotationFromMatrix = (matrix) => {\n    const [m11, , , m21] = matrix;\n    const scaleX = Math.hypot(m11, m21);\n    const cosTheta = m11 / scaleX;\n    const sinTheta = m21 / scaleX;\n    // Invert the rotation because matrices are post-multiplied in ISOBMFF\n    const result = -Math.atan2(sinTheta, cosTheta) * (180 / Math.PI);\n    if (!Number.isFinite(result)) {\n        // Can happen if the entire matrix is 0, for example\n        return 0;\n    }\n    return result;\n};\nconst sampleTableIsEmpty = (sampleTable) => {\n    return sampleTable.sampleSizes.length === 0;\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assertNever, textDecoder, textEncoder } from '../misc.js';\nimport { readBytes, readF32Be, readF64Be, readU8 } from '../reader.js';\n/** Wrapper around a number to be able to differentiate it in the writer. */\nexport class EBMLFloat32 {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/** Wrapper around a number to be able to differentiate it in the writer. */\nexport class EBMLFloat64 {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/** Wrapper around a number to be able to differentiate it in the writer. */\nexport class EBMLSignedInt {\n    constructor(value) {\n        this.value = value;\n    }\n}\nexport class EBMLUnicodeString {\n    constructor(value) {\n        this.value = value;\n    }\n}\n/** Defines some of the EBML IDs used by Matroska files. */\nexport var EBMLId;\n(function (EBMLId) {\n    EBMLId[EBMLId[\"EBML\"] = 440786851] = \"EBML\";\n    EBMLId[EBMLId[\"EBMLVersion\"] = 17030] = \"EBMLVersion\";\n    EBMLId[EBMLId[\"EBMLReadVersion\"] = 17143] = \"EBMLReadVersion\";\n    EBMLId[EBMLId[\"EBMLMaxIDLength\"] = 17138] = \"EBMLMaxIDLength\";\n    EBMLId[EBMLId[\"EBMLMaxSizeLength\"] = 17139] = \"EBMLMaxSizeLength\";\n    EBMLId[EBMLId[\"DocType\"] = 17026] = \"DocType\";\n    EBMLId[EBMLId[\"DocTypeVersion\"] = 17031] = \"DocTypeVersion\";\n    EBMLId[EBMLId[\"DocTypeReadVersion\"] = 17029] = \"DocTypeReadVersion\";\n    EBMLId[EBMLId[\"Void\"] = 236] = \"Void\";\n    EBMLId[EBMLId[\"Segment\"] = 408125543] = \"Segment\";\n    EBMLId[EBMLId[\"SeekHead\"] = 290298740] = \"SeekHead\";\n    EBMLId[EBMLId[\"Seek\"] = 19899] = \"Seek\";\n    EBMLId[EBMLId[\"SeekID\"] = 21419] = \"SeekID\";\n    EBMLId[EBMLId[\"SeekPosition\"] = 21420] = \"SeekPosition\";\n    EBMLId[EBMLId[\"Duration\"] = 17545] = \"Duration\";\n    EBMLId[EBMLId[\"Info\"] = 357149030] = \"Info\";\n    EBMLId[EBMLId[\"TimestampScale\"] = 2807729] = \"TimestampScale\";\n    EBMLId[EBMLId[\"MuxingApp\"] = 19840] = \"MuxingApp\";\n    EBMLId[EBMLId[\"WritingApp\"] = 22337] = \"WritingApp\";\n    EBMLId[EBMLId[\"Tracks\"] = 374648427] = \"Tracks\";\n    EBMLId[EBMLId[\"TrackEntry\"] = 174] = \"TrackEntry\";\n    EBMLId[EBMLId[\"TrackNumber\"] = 215] = \"TrackNumber\";\n    EBMLId[EBMLId[\"TrackUID\"] = 29637] = \"TrackUID\";\n    EBMLId[EBMLId[\"TrackType\"] = 131] = \"TrackType\";\n    EBMLId[EBMLId[\"FlagEnabled\"] = 185] = \"FlagEnabled\";\n    EBMLId[EBMLId[\"FlagDefault\"] = 136] = \"FlagDefault\";\n    EBMLId[EBMLId[\"FlagForced\"] = 21930] = \"FlagForced\";\n    EBMLId[EBMLId[\"FlagOriginal\"] = 21934] = \"FlagOriginal\";\n    EBMLId[EBMLId[\"FlagHearingImpaired\"] = 21931] = \"FlagHearingImpaired\";\n    EBMLId[EBMLId[\"FlagVisualImpaired\"] = 21932] = \"FlagVisualImpaired\";\n    EBMLId[EBMLId[\"FlagCommentary\"] = 21935] = \"FlagCommentary\";\n    EBMLId[EBMLId[\"FlagLacing\"] = 156] = \"FlagLacing\";\n    EBMLId[EBMLId[\"Name\"] = 21358] = \"Name\";\n    EBMLId[EBMLId[\"Language\"] = 2274716] = \"Language\";\n    EBMLId[EBMLId[\"LanguageBCP47\"] = 2274717] = \"LanguageBCP47\";\n    EBMLId[EBMLId[\"CodecID\"] = 134] = \"CodecID\";\n    EBMLId[EBMLId[\"CodecPrivate\"] = 25506] = \"CodecPrivate\";\n    EBMLId[EBMLId[\"CodecDelay\"] = 22186] = \"CodecDelay\";\n    EBMLId[EBMLId[\"SeekPreRoll\"] = 22203] = \"SeekPreRoll\";\n    EBMLId[EBMLId[\"DefaultDuration\"] = 2352003] = \"DefaultDuration\";\n    EBMLId[EBMLId[\"Video\"] = 224] = \"Video\";\n    EBMLId[EBMLId[\"PixelWidth\"] = 176] = \"PixelWidth\";\n    EBMLId[EBMLId[\"PixelHeight\"] = 186] = \"PixelHeight\";\n    EBMLId[EBMLId[\"AlphaMode\"] = 21440] = \"AlphaMode\";\n    EBMLId[EBMLId[\"Audio\"] = 225] = \"Audio\";\n    EBMLId[EBMLId[\"SamplingFrequency\"] = 181] = \"SamplingFrequency\";\n    EBMLId[EBMLId[\"Channels\"] = 159] = \"Channels\";\n    EBMLId[EBMLId[\"BitDepth\"] = 25188] = \"BitDepth\";\n    EBMLId[EBMLId[\"SimpleBlock\"] = 163] = \"SimpleBlock\";\n    EBMLId[EBMLId[\"BlockGroup\"] = 160] = \"BlockGroup\";\n    EBMLId[EBMLId[\"Block\"] = 161] = \"Block\";\n    EBMLId[EBMLId[\"BlockAdditions\"] = 30113] = \"BlockAdditions\";\n    EBMLId[EBMLId[\"BlockMore\"] = 166] = \"BlockMore\";\n    EBMLId[EBMLId[\"BlockAdditional\"] = 165] = \"BlockAdditional\";\n    EBMLId[EBMLId[\"BlockAddID\"] = 238] = \"BlockAddID\";\n    EBMLId[EBMLId[\"BlockDuration\"] = 155] = \"BlockDuration\";\n    EBMLId[EBMLId[\"ReferenceBlock\"] = 251] = \"ReferenceBlock\";\n    EBMLId[EBMLId[\"Cluster\"] = 524531317] = \"Cluster\";\n    EBMLId[EBMLId[\"Timestamp\"] = 231] = \"Timestamp\";\n    EBMLId[EBMLId[\"Cues\"] = 475249515] = \"Cues\";\n    EBMLId[EBMLId[\"CuePoint\"] = 187] = \"CuePoint\";\n    EBMLId[EBMLId[\"CueTime\"] = 179] = \"CueTime\";\n    EBMLId[EBMLId[\"CueTrackPositions\"] = 183] = \"CueTrackPositions\";\n    EBMLId[EBMLId[\"CueTrack\"] = 247] = \"CueTrack\";\n    EBMLId[EBMLId[\"CueClusterPosition\"] = 241] = \"CueClusterPosition\";\n    EBMLId[EBMLId[\"Colour\"] = 21936] = \"Colour\";\n    EBMLId[EBMLId[\"MatrixCoefficients\"] = 21937] = \"MatrixCoefficients\";\n    EBMLId[EBMLId[\"TransferCharacteristics\"] = 21946] = \"TransferCharacteristics\";\n    EBMLId[EBMLId[\"Primaries\"] = 21947] = \"Primaries\";\n    EBMLId[EBMLId[\"Range\"] = 21945] = \"Range\";\n    EBMLId[EBMLId[\"Projection\"] = 30320] = \"Projection\";\n    EBMLId[EBMLId[\"ProjectionType\"] = 30321] = \"ProjectionType\";\n    EBMLId[EBMLId[\"ProjectionPoseRoll\"] = 30325] = \"ProjectionPoseRoll\";\n    EBMLId[EBMLId[\"Attachments\"] = 423732329] = \"Attachments\";\n    EBMLId[EBMLId[\"AttachedFile\"] = 24999] = \"AttachedFile\";\n    EBMLId[EBMLId[\"FileDescription\"] = 18046] = \"FileDescription\";\n    EBMLId[EBMLId[\"FileName\"] = 18030] = \"FileName\";\n    EBMLId[EBMLId[\"FileMediaType\"] = 18016] = \"FileMediaType\";\n    EBMLId[EBMLId[\"FileData\"] = 18012] = \"FileData\";\n    EBMLId[EBMLId[\"FileUID\"] = 18094] = \"FileUID\";\n    EBMLId[EBMLId[\"Chapters\"] = 272869232] = \"Chapters\";\n    EBMLId[EBMLId[\"Tags\"] = 307544935] = \"Tags\";\n    EBMLId[EBMLId[\"Tag\"] = 29555] = \"Tag\";\n    EBMLId[EBMLId[\"Targets\"] = 25536] = \"Targets\";\n    EBMLId[EBMLId[\"TargetTypeValue\"] = 26826] = \"TargetTypeValue\";\n    EBMLId[EBMLId[\"TargetType\"] = 25546] = \"TargetType\";\n    EBMLId[EBMLId[\"TagTrackUID\"] = 25541] = \"TagTrackUID\";\n    EBMLId[EBMLId[\"TagEditionUID\"] = 25545] = \"TagEditionUID\";\n    EBMLId[EBMLId[\"TagChapterUID\"] = 25540] = \"TagChapterUID\";\n    EBMLId[EBMLId[\"TagAttachmentUID\"] = 25542] = \"TagAttachmentUID\";\n    EBMLId[EBMLId[\"SimpleTag\"] = 26568] = \"SimpleTag\";\n    EBMLId[EBMLId[\"TagName\"] = 17827] = \"TagName\";\n    EBMLId[EBMLId[\"TagLanguage\"] = 17530] = \"TagLanguage\";\n    EBMLId[EBMLId[\"TagString\"] = 17543] = \"TagString\";\n    EBMLId[EBMLId[\"TagBinary\"] = 17541] = \"TagBinary\";\n    EBMLId[EBMLId[\"ContentEncodings\"] = 28032] = \"ContentEncodings\";\n    EBMLId[EBMLId[\"ContentEncoding\"] = 25152] = \"ContentEncoding\";\n    EBMLId[EBMLId[\"ContentEncodingOrder\"] = 20529] = \"ContentEncodingOrder\";\n    EBMLId[EBMLId[\"ContentEncodingScope\"] = 20530] = \"ContentEncodingScope\";\n    EBMLId[EBMLId[\"ContentCompression\"] = 20532] = \"ContentCompression\";\n    EBMLId[EBMLId[\"ContentCompAlgo\"] = 16980] = \"ContentCompAlgo\";\n    EBMLId[EBMLId[\"ContentCompSettings\"] = 16981] = \"ContentCompSettings\";\n    EBMLId[EBMLId[\"ContentEncryption\"] = 20533] = \"ContentEncryption\";\n})(EBMLId || (EBMLId = {}));\nexport const LEVEL_0_EBML_IDS = [\n    EBMLId.EBML,\n    EBMLId.Segment,\n];\n// All the stuff that can appear in a segment, basically\nexport const LEVEL_1_EBML_IDS = [\n    EBMLId.SeekHead,\n    EBMLId.Info,\n    EBMLId.Cluster,\n    EBMLId.Tracks,\n    EBMLId.Cues,\n    EBMLId.Attachments,\n    EBMLId.Chapters,\n    EBMLId.Tags,\n];\nexport const LEVEL_0_AND_1_EBML_IDS = [\n    ...LEVEL_0_EBML_IDS,\n    ...LEVEL_1_EBML_IDS,\n];\nexport const measureUnsignedInt = (value) => {\n    if (value < (1 << 8)) {\n        return 1;\n    }\n    else if (value < (1 << 16)) {\n        return 2;\n    }\n    else if (value < (1 << 24)) {\n        return 3;\n    }\n    else if (value < 2 ** 32) {\n        return 4;\n    }\n    else if (value < 2 ** 40) {\n        return 5;\n    }\n    else {\n        return 6;\n    }\n};\nexport const measureUnsignedBigInt = (value) => {\n    if (value < (1n << 8n)) {\n        return 1;\n    }\n    else if (value < (1n << 16n)) {\n        return 2;\n    }\n    else if (value < (1n << 24n)) {\n        return 3;\n    }\n    else if (value < (1n << 32n)) {\n        return 4;\n    }\n    else if (value < (1n << 40n)) {\n        return 5;\n    }\n    else if (value < (1n << 48n)) {\n        return 6;\n    }\n    else if (value < (1n << 56n)) {\n        return 7;\n    }\n    else {\n        return 8;\n    }\n};\nexport const measureSignedInt = (value) => {\n    if (value >= -(1 << 6) && value < (1 << 6)) {\n        return 1;\n    }\n    else if (value >= -(1 << 13) && value < (1 << 13)) {\n        return 2;\n    }\n    else if (value >= -(1 << 20) && value < (1 << 20)) {\n        return 3;\n    }\n    else if (value >= -(1 << 27) && value < (1 << 27)) {\n        return 4;\n    }\n    else if (value >= -(2 ** 34) && value < 2 ** 34) {\n        return 5;\n    }\n    else {\n        return 6;\n    }\n};\nexport const measureVarInt = (value) => {\n    if (value < (1 << 7) - 1) {\n        /** Top bit is set, leaving 7 bits to hold the integer, but we can't store\n         * 127 because \"all bits set to one\" is a reserved value. Same thing for the\n         * other cases below:\n         */\n        return 1;\n    }\n    else if (value < (1 << 14) - 1) {\n        return 2;\n    }\n    else if (value < (1 << 21) - 1) {\n        return 3;\n    }\n    else if (value < (1 << 28) - 1) {\n        return 4;\n    }\n    else if (value < 2 ** 35 - 1) {\n        return 5;\n    }\n    else if (value < 2 ** 42 - 1) {\n        return 6;\n    }\n    else {\n        throw new Error('EBML varint size not supported ' + value);\n    }\n};\nexport class EBMLWriter {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n        /**\n         * Stores the position from the start of the file to where EBML elements have been written. This is used to\n         * rewrite/edit elements that were already added before, and to measure sizes of things.\n         */\n        this.offsets = new WeakMap();\n        /** Same as offsets, but stores position where the element's data starts (after ID and size fields). */\n        this.dataOffsets = new WeakMap();\n    }\n    writeByte(value) {\n        this.helperView.setUint8(0, value);\n        this.writer.write(this.helper.subarray(0, 1));\n    }\n    writeFloat32(value) {\n        this.helperView.setFloat32(0, value, false);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeFloat64(value) {\n        this.helperView.setFloat64(0, value, false);\n        this.writer.write(this.helper);\n    }\n    writeUnsignedInt(value, width = measureUnsignedInt(value)) {\n        let pos = 0;\n        // Each case falls through:\n        switch (width) {\n            case 6:\n                // Need to use division to access >32 bits of floating point var\n                this.helperView.setUint8(pos++, (value / 2 ** 40) | 0);\n            // eslint-disable-next-line no-fallthrough\n            case 5:\n                this.helperView.setUint8(pos++, (value / 2 ** 32) | 0);\n            // eslint-disable-next-line no-fallthrough\n            case 4:\n                this.helperView.setUint8(pos++, value >> 24);\n            // eslint-disable-next-line no-fallthrough\n            case 3:\n                this.helperView.setUint8(pos++, value >> 16);\n            // eslint-disable-next-line no-fallthrough\n            case 2:\n                this.helperView.setUint8(pos++, value >> 8);\n            // eslint-disable-next-line no-fallthrough\n            case 1:\n                this.helperView.setUint8(pos++, value);\n                break;\n            default:\n                throw new Error('Bad unsigned int size ' + width);\n        }\n        this.writer.write(this.helper.subarray(0, pos));\n    }\n    writeUnsignedBigInt(value, width = measureUnsignedBigInt(value)) {\n        let pos = 0;\n        for (let i = width - 1; i >= 0; i--) {\n            this.helperView.setUint8(pos++, Number((value >> BigInt(i * 8)) & 0xffn));\n        }\n        this.writer.write(this.helper.subarray(0, pos));\n    }\n    writeSignedInt(value, width = measureSignedInt(value)) {\n        if (value < 0) {\n            // Two's complement stuff\n            value += 2 ** (width * 8);\n        }\n        this.writeUnsignedInt(value, width);\n    }\n    writeVarInt(value, width = measureVarInt(value)) {\n        let pos = 0;\n        switch (width) {\n            case 1:\n                this.helperView.setUint8(pos++, (1 << 7) | value);\n                break;\n            case 2:\n                this.helperView.setUint8(pos++, (1 << 6) | (value >> 8));\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 3:\n                this.helperView.setUint8(pos++, (1 << 5) | (value >> 16));\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 4:\n                this.helperView.setUint8(pos++, (1 << 4) | (value >> 24));\n                this.helperView.setUint8(pos++, value >> 16);\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 5:\n                /**\n                 * JavaScript converts its doubles to 32-bit integers for bitwise\n                 * operations, so we need to do a division by 2^32 instead of a\n                 * right-shift of 32 to retain those top 3 bits\n                 */\n                this.helperView.setUint8(pos++, (1 << 3) | ((value / 2 ** 32) & 0x7));\n                this.helperView.setUint8(pos++, value >> 24);\n                this.helperView.setUint8(pos++, value >> 16);\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            case 6:\n                this.helperView.setUint8(pos++, (1 << 2) | ((value / 2 ** 40) & 0x3));\n                this.helperView.setUint8(pos++, (value / 2 ** 32) | 0);\n                this.helperView.setUint8(pos++, value >> 24);\n                this.helperView.setUint8(pos++, value >> 16);\n                this.helperView.setUint8(pos++, value >> 8);\n                this.helperView.setUint8(pos++, value);\n                break;\n            default:\n                throw new Error('Bad EBML varint size ' + width);\n        }\n        this.writer.write(this.helper.subarray(0, pos));\n    }\n    writeAsciiString(str) {\n        this.writer.write(new Uint8Array(str.split('').map(x => x.charCodeAt(0))));\n    }\n    writeEBML(data) {\n        if (data === null)\n            return;\n        if (data instanceof Uint8Array) {\n            this.writer.write(data);\n        }\n        else if (Array.isArray(data)) {\n            for (const elem of data) {\n                this.writeEBML(elem);\n            }\n        }\n        else {\n            this.offsets.set(data, this.writer.getPos());\n            this.writeUnsignedInt(data.id); // ID field\n            if (Array.isArray(data.data)) {\n                const sizePos = this.writer.getPos();\n                const sizeSize = data.size === -1 ? 1 : (data.size ?? 4);\n                if (data.size === -1) {\n                    // Write the reserved all-one-bits marker for unknown/unbounded size.\n                    this.writeByte(0xff);\n                }\n                else {\n                    this.writer.seek(this.writer.getPos() + sizeSize);\n                }\n                const startPos = this.writer.getPos();\n                this.dataOffsets.set(data, startPos);\n                this.writeEBML(data.data);\n                if (data.size !== -1) {\n                    const size = this.writer.getPos() - startPos;\n                    const endPos = this.writer.getPos();\n                    this.writer.seek(sizePos);\n                    this.writeVarInt(size, sizeSize);\n                    this.writer.seek(endPos);\n                }\n            }\n            else if (typeof data.data === 'number') {\n                const size = data.size ?? measureUnsignedInt(data.data);\n                this.writeVarInt(size);\n                this.writeUnsignedInt(data.data, size);\n            }\n            else if (typeof data.data === 'bigint') {\n                const size = data.size ?? measureUnsignedBigInt(data.data);\n                this.writeVarInt(size);\n                this.writeUnsignedBigInt(data.data, size);\n            }\n            else if (typeof data.data === 'string') {\n                this.writeVarInt(data.data.length);\n                this.writeAsciiString(data.data);\n            }\n            else if (data.data instanceof Uint8Array) {\n                this.writeVarInt(data.data.byteLength, data.size);\n                this.writer.write(data.data);\n            }\n            else if (data.data instanceof EBMLFloat32) {\n                this.writeVarInt(4);\n                this.writeFloat32(data.data.value);\n            }\n            else if (data.data instanceof EBMLFloat64) {\n                this.writeVarInt(8);\n                this.writeFloat64(data.data.value);\n            }\n            else if (data.data instanceof EBMLSignedInt) {\n                const size = data.size ?? measureSignedInt(data.data.value);\n                this.writeVarInt(size);\n                this.writeSignedInt(data.data.value, size);\n            }\n            else if (data.data instanceof EBMLUnicodeString) {\n                const bytes = textEncoder.encode(data.data.value);\n                this.writeVarInt(bytes.length);\n                this.writer.write(bytes);\n            }\n            else {\n                assertNever(data.data);\n            }\n        }\n    }\n}\nexport const MAX_VAR_INT_SIZE = 8;\nexport const MIN_HEADER_SIZE = 2; // 1-byte ID and 1-byte size\nexport const MAX_HEADER_SIZE = 2 * MAX_VAR_INT_SIZE; // 8-byte ID and 8-byte size\nexport const readVarIntSize = (slice) => {\n    const firstByte = readU8(slice);\n    slice.skip(-1);\n    if (firstByte === 0) {\n        return null; // Invalid VINT\n    }\n    let width = 1;\n    let mask = 0x80;\n    while ((firstByte & mask) === 0) {\n        width++;\n        mask >>= 1;\n    }\n    return width;\n};\nexport const readVarInt = (slice) => {\n    // Read the first byte to determine the width of the variable-length integer\n    const firstByte = readU8(slice);\n    if (firstByte === 0) {\n        return null; // Invalid VINT\n    }\n    // Find the position of VINT_MARKER, which determines the width\n    let width = 1;\n    let mask = 1 << 7;\n    while ((firstByte & mask) === 0) {\n        width++;\n        mask >>= 1;\n    }\n    // First byte's value needs the marker bit cleared\n    let value = firstByte & (mask - 1);\n    // Read remaining bytes\n    for (let i = 1; i < width; i++) {\n        value *= 1 << 8;\n        value += readU8(slice);\n    }\n    return value;\n};\nexport const readUnsignedInt = (slice, width) => {\n    if (width < 1 || width > 8) {\n        throw new Error('Bad unsigned int size ' + width);\n    }\n    let value = 0;\n    // Read bytes from most significant to least significant\n    for (let i = 0; i < width; i++) {\n        value *= 1 << 8;\n        value += readU8(slice);\n    }\n    return value;\n};\nexport const readUnsignedBigInt = (slice, width) => {\n    if (width < 1) {\n        throw new Error('Bad unsigned int size ' + width);\n    }\n    let value = 0n;\n    for (let i = 0; i < width; i++) {\n        value <<= 8n;\n        value += BigInt(readU8(slice));\n    }\n    return value;\n};\nexport const readSignedInt = (slice, width) => {\n    let value = readUnsignedInt(slice, width);\n    // If the highest bit is set, convert from two's complement\n    if (value & (1 << (width * 8 - 1))) {\n        value -= 2 ** (width * 8);\n    }\n    return value;\n};\nexport const readElementId = (slice) => {\n    const size = readVarIntSize(slice);\n    if (size === null) {\n        return null;\n    }\n    const id = readUnsignedInt(slice, size);\n    return id;\n};\nexport const readElementSize = (slice) => {\n    let size = readU8(slice);\n    if (size === 0xff) {\n        size = null;\n    }\n    else {\n        slice.skip(-1);\n        size = readVarInt(slice);\n        // In some (livestreamed) files, this is the value of the size field. While this technically is just a very\n        // large number, it is intended to behave like the reserved size 0xFF, meaning the size is undefined. We\n        // catch the number here. Note that it cannot be perfectly represented as a double, but the comparison works\n        // nonetheless.\n        // eslint-disable-next-line no-loss-of-precision\n        if (size === 0x00ffffffffffffff) {\n            size = null;\n        }\n    }\n    return size;\n};\nexport const readElementHeader = (slice) => {\n    const id = readElementId(slice);\n    if (id === null) {\n        return null;\n    }\n    const size = readElementSize(slice);\n    return { id, size };\n};\nexport const readAsciiString = (slice, length) => {\n    const bytes = readBytes(slice, length);\n    // Actual string length might be shorter due to null terminators\n    let strLength = 0;\n    while (strLength < length && bytes[strLength] !== 0) {\n        strLength += 1;\n    }\n    return String.fromCharCode(...bytes.subarray(0, strLength));\n};\nexport const readUnicodeString = (slice, length) => {\n    const bytes = readBytes(slice, length);\n    // Actual string length might be shorter due to null terminators\n    let strLength = 0;\n    while (strLength < length && bytes[strLength] !== 0) {\n        strLength += 1;\n    }\n    return textDecoder.decode(bytes.subarray(0, strLength));\n};\nexport const readFloat = (slice, width) => {\n    if (width === 0) {\n        return 0;\n    }\n    if (width !== 4 && width !== 8) {\n        throw new Error('Bad float size ' + width);\n    }\n    return width === 4 ? readF32Be(slice) : readF64Be(slice);\n};\n/** Returns the byte offset in the file of the next element with a matching ID. */\nexport const searchForNextElementId = async (reader, startPos, ids, until) => {\n    const idsSet = new Set(ids);\n    let currentPos = startPos;\n    while (until === null || currentPos < until) {\n        let slice = reader.requestSliceRange(currentPos, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            break;\n        const elementHeader = readElementHeader(slice);\n        if (!elementHeader) {\n            break;\n        }\n        if (idsSet.has(elementHeader.id)) {\n            return { pos: currentPos, found: true };\n        }\n        assertDefinedSize(elementHeader.size);\n        currentPos = slice.filePos + elementHeader.size;\n    }\n    return { pos: (until !== null && until > currentPos) ? until : currentPos, found: false };\n};\n/** Searches for the next occurrence of an element ID using a naive byte-wise search. */\nexport const resync = async (reader, startPos, ids, until) => {\n    const CHUNK_SIZE = 2 ** 16; // So we don't need to grab thousands of slices\n    const idsSet = new Set(ids);\n    let currentPos = startPos;\n    while (currentPos < until) {\n        let slice = reader.requestSliceRange(currentPos, 0, Math.min(CHUNK_SIZE, until - currentPos));\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            break;\n        if (slice.length < MAX_VAR_INT_SIZE)\n            break;\n        for (let i = 0; i < slice.length - MAX_VAR_INT_SIZE; i++) {\n            slice.filePos = currentPos;\n            const elementId = readElementId(slice);\n            if (elementId !== null && idsSet.has(elementId)) {\n                return currentPos;\n            }\n            currentPos++;\n        }\n    }\n    return null;\n};\nexport const CODEC_STRING_MAP = {\n    'avc': 'V_MPEG4/ISO/AVC',\n    'hevc': 'V_MPEGH/ISO/HEVC',\n    'vp8': 'V_VP8',\n    'vp9': 'V_VP9',\n    'av1': 'V_AV1',\n    'aac': 'A_AAC',\n    'mp3': 'A_MPEG/L3',\n    'opus': 'A_OPUS',\n    'vorbis': 'A_VORBIS',\n    'flac': 'A_FLAC',\n    'pcm-u8': 'A_PCM/INT/LIT',\n    'pcm-s16': 'A_PCM/INT/LIT',\n    'pcm-s16be': 'A_PCM/INT/BIG',\n    'pcm-s24': 'A_PCM/INT/LIT',\n    'pcm-s24be': 'A_PCM/INT/BIG',\n    'pcm-s32': 'A_PCM/INT/LIT',\n    'pcm-s32be': 'A_PCM/INT/BIG',\n    'pcm-f32': 'A_PCM/FLOAT/IEEE',\n    'pcm-f64': 'A_PCM/FLOAT/IEEE',\n    'webvtt': 'S_TEXT/WEBVTT',\n};\nexport function assertDefinedSize(size) {\n    if (size === null) {\n        throw new Error('Undefined element size is used in a place where it is not supported.');\n    }\n}\n;\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport const buildMatroskaMimeType = (info) => {\n    const base = info.hasVideo\n        ? 'video/'\n        : info.hasAudio\n            ? 'audio/'\n            : 'application/';\n    let string = base + (info.isWebM ? 'webm' : 'x-matroska');\n    if (info.codecStrings.length > 0) {\n        const uniqueCodecMimeTypes = [...new Set(info.codecStrings.filter(Boolean))];\n        string += `; codecs=\"${uniqueCodecMimeTypes.join(', ')}\"`;\n    }\n    return string;\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { extractAv1CodecInfoFromPacket, extractAvcDecoderConfigurationRecord, extractHevcDecoderConfigurationRecord, extractVp9CodecInfoFromPacket, } from '../codec-data.js';\nimport { extractAudioCodecString, extractVideoCodecString, OPUS_SAMPLE_RATE, } from '../codec.js';\nimport { Demuxer } from '../demuxer.js';\nimport { InputAudioTrack, InputVideoTrack, } from '../input-track.js';\nimport { AttachedFile, DEFAULT_TRACK_DISPOSITION } from '../metadata.js';\nimport { assert, binarySearchLessOrEqual, COLOR_PRIMARIES_MAP_INVERSE, findLastIndex, isIso639Dash2LanguageCode, last, MATRIX_COEFFICIENTS_MAP_INVERSE, normalizeRotation, roundIfAlmostInteger, TRANSFER_CHARACTERISTICS_MAP_INVERSE, UNDETERMINED_LANGUAGE, } from '../misc.js';\nimport { EncodedPacket, PLACEHOLDER_DATA } from '../packet.js';\nimport { assertDefinedSize, CODEC_STRING_MAP, EBMLId, LEVEL_0_AND_1_EBML_IDS, LEVEL_1_EBML_IDS, MAX_HEADER_SIZE, MIN_HEADER_SIZE, readAsciiString, readUnicodeString, readElementHeader, readElementId, readFloat, readUnsignedInt, readVarInt, resync, searchForNextElementId, readUnsignedBigInt, } from './ebml.js';\nimport { buildMatroskaMimeType } from './matroska-misc.js';\nimport { FileSlice, readBytes, readI16Be, readU8 } from '../reader.js';\nvar BlockLacing;\n(function (BlockLacing) {\n    BlockLacing[BlockLacing[\"None\"] = 0] = \"None\";\n    BlockLacing[BlockLacing[\"Xiph\"] = 1] = \"Xiph\";\n    BlockLacing[BlockLacing[\"FixedSize\"] = 2] = \"FixedSize\";\n    BlockLacing[BlockLacing[\"Ebml\"] = 3] = \"Ebml\";\n})(BlockLacing || (BlockLacing = {}));\nvar ContentEncodingScope;\n(function (ContentEncodingScope) {\n    ContentEncodingScope[ContentEncodingScope[\"Block\"] = 1] = \"Block\";\n    ContentEncodingScope[ContentEncodingScope[\"Private\"] = 2] = \"Private\";\n    ContentEncodingScope[ContentEncodingScope[\"Next\"] = 4] = \"Next\";\n})(ContentEncodingScope || (ContentEncodingScope = {}));\nvar ContentCompAlgo;\n(function (ContentCompAlgo) {\n    ContentCompAlgo[ContentCompAlgo[\"Zlib\"] = 0] = \"Zlib\";\n    ContentCompAlgo[ContentCompAlgo[\"Bzlib\"] = 1] = \"Bzlib\";\n    ContentCompAlgo[ContentCompAlgo[\"lzo1x\"] = 2] = \"lzo1x\";\n    ContentCompAlgo[ContentCompAlgo[\"HeaderStripping\"] = 3] = \"HeaderStripping\";\n})(ContentCompAlgo || (ContentCompAlgo = {}));\nconst METADATA_ELEMENTS = [\n    { id: EBMLId.SeekHead, flag: 'seekHeadSeen' },\n    { id: EBMLId.Info, flag: 'infoSeen' },\n    { id: EBMLId.Tracks, flag: 'tracksSeen' },\n    { id: EBMLId.Cues, flag: 'cuesSeen' },\n];\nconst MAX_RESYNC_LENGTH = 10 * 2 ** 20; // 10 MiB\nexport class MatroskaDemuxer extends Demuxer {\n    constructor(input) {\n        super(input);\n        this.readMetadataPromise = null;\n        this.segments = [];\n        this.currentSegment = null;\n        this.currentTrack = null;\n        this.currentCluster = null;\n        this.currentBlock = null;\n        this.currentBlockAdditional = null;\n        this.currentCueTime = null;\n        this.currentDecodingInstruction = null;\n        this.currentTagTargetIsMovie = true;\n        this.currentSimpleTagName = null;\n        this.currentAttachedFile = null;\n        this.isWebM = false;\n        this.reader = input._reader;\n    }\n    async computeDuration() {\n        const tracks = await this.getTracks();\n        const trackDurations = await Promise.all(tracks.map(x => x.computeDuration()));\n        return Math.max(0, ...trackDurations);\n    }\n    async getTracks() {\n        await this.readMetadata();\n        return this.segments.flatMap(segment => segment.tracks.map(track => track.inputTrack));\n    }\n    async getMimeType() {\n        await this.readMetadata();\n        const tracks = await this.getTracks();\n        const codecStrings = await Promise.all(tracks.map(x => x.getCodecParameterString()));\n        return buildMatroskaMimeType({\n            isWebM: this.isWebM,\n            hasVideo: this.segments.some(segment => segment.tracks.some(x => x.info?.type === 'video')),\n            hasAudio: this.segments.some(segment => segment.tracks.some(x => x.info?.type === 'audio')),\n            codecStrings: codecStrings.filter(Boolean),\n        });\n    }\n    async getMetadataTags() {\n        await this.readMetadata();\n        // Load metadata tags from each segment lazily (only once)\n        for (const segment of this.segments) {\n            if (!segment.metadataTagsCollected) {\n                if (this.reader.fileSize !== null) {\n                    await this.loadSegmentMetadata(segment);\n                }\n                else {\n                    // The seeking would be too crazy, let's not\n                }\n                segment.metadataTagsCollected = true;\n            }\n        }\n        // This is kinda handwavy, and how we handle multiple segments isn't suuuuper well-defined anyway; so we just\n        // shallow-merge metadata tags from all (usually just one) segments.\n        let metadataTags = {};\n        for (const segment of this.segments) {\n            metadataTags = { ...metadataTags, ...segment.metadataTags };\n        }\n        return metadataTags;\n    }\n    readMetadata() {\n        return this.readMetadataPromise ??= (async () => {\n            let currentPos = 0;\n            // Loop over all top-level elements in the file\n            while (true) {\n                let slice = this.reader.requestSliceRange(currentPos, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (!slice)\n                    break;\n                const header = readElementHeader(slice);\n                if (!header) {\n                    break; // Zero padding at the end of the file triggers this, for example\n                }\n                const id = header.id;\n                let size = header.size;\n                const dataStartPos = slice.filePos;\n                if (id === EBMLId.EBML) {\n                    assertDefinedSize(size);\n                    let slice = this.reader.requestSlice(dataStartPos, size);\n                    if (slice instanceof Promise)\n                        slice = await slice;\n                    if (!slice)\n                        break;\n                    this.readContiguousElements(slice);\n                }\n                else if (id === EBMLId.Segment) { // Segment found!\n                    await this.readSegment(dataStartPos, size);\n                    if (size === null) {\n                        // Segment sizes can be undefined (common in livestreamed files), so assume this is the last\n                        // and only segment\n                        break;\n                    }\n                    if (this.reader.fileSize === null) {\n                        break; // Stop at the first segment\n                    }\n                }\n                else if (id === EBMLId.Cluster) {\n                    if (this.reader.fileSize === null) {\n                        break; // Shouldn't be reached anyway, since we stop at the first segment\n                    }\n                    // Clusters are not a top-level element in Matroska, but some files contain a Segment whose size\n                    // doesn't contain any of the clusters that follow it. In the case, we apply the following logic: if\n                    // we find a top-level cluster, attribute it to the previous segment.\n                    if (size === null) {\n                        // Just in case this is one of those weird sizeless clusters, let's do our best and still try to\n                        // determine its size.\n                        const nextElementPos = await searchForNextElementId(this.reader, dataStartPos, LEVEL_0_AND_1_EBML_IDS, this.reader.fileSize);\n                        size = nextElementPos.pos - dataStartPos;\n                    }\n                    const lastSegment = last(this.segments);\n                    if (lastSegment) {\n                        // Extend the previous segment's size\n                        lastSegment.elementEndPos = dataStartPos + size;\n                    }\n                }\n                assertDefinedSize(size);\n                currentPos = dataStartPos + size;\n            }\n        })();\n    }\n    async readSegment(segmentDataStart, dataSize) {\n        this.currentSegment = {\n            seekHeadSeen: false,\n            infoSeen: false,\n            tracksSeen: false,\n            cuesSeen: false,\n            tagsSeen: false,\n            attachmentsSeen: false,\n            timestampScale: -1,\n            timestampFactor: -1,\n            duration: -1,\n            seekEntries: [],\n            tracks: [],\n            cuePoints: [],\n            dataStartPos: segmentDataStart,\n            elementEndPos: dataSize === null\n                ? null // Assume it goes until the end of the file\n                : segmentDataStart + dataSize,\n            clusterSeekStartPos: segmentDataStart,\n            lastReadCluster: null,\n            metadataTags: {},\n            metadataTagsCollected: false,\n        };\n        this.segments.push(this.currentSegment);\n        let currentPos = segmentDataStart;\n        while (this.currentSegment.elementEndPos === null || currentPos < this.currentSegment.elementEndPos) {\n            let slice = this.reader.requestSliceRange(currentPos, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n            if (slice instanceof Promise)\n                slice = await slice;\n            if (!slice)\n                break;\n            const elementStartPos = currentPos;\n            const header = readElementHeader(slice);\n            if (!header || (!LEVEL_1_EBML_IDS.includes(header.id) && header.id !== EBMLId.Void)) {\n                // Potential junk. Let's try to resync\n                const nextPos = await resync(this.reader, elementStartPos, LEVEL_1_EBML_IDS, Math.min(this.currentSegment.elementEndPos ?? Infinity, elementStartPos + MAX_RESYNC_LENGTH));\n                if (nextPos) {\n                    currentPos = nextPos;\n                    continue;\n                }\n                else {\n                    break; // Resync failed\n                }\n            }\n            const { id, size } = header;\n            const dataStartPos = slice.filePos;\n            const metadataElementIndex = METADATA_ELEMENTS.findIndex(x => x.id === id);\n            if (metadataElementIndex !== -1) {\n                const field = METADATA_ELEMENTS[metadataElementIndex].flag;\n                this.currentSegment[field] = true;\n                assertDefinedSize(size);\n                let slice = this.reader.requestSlice(dataStartPos, size);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (slice) {\n                    this.readContiguousElements(slice);\n                }\n            }\n            else if (id === EBMLId.Tags || id === EBMLId.Attachments) {\n                // Metadata found at the beginning of the segment, great, let's parse it\n                if (id === EBMLId.Tags) {\n                    this.currentSegment.tagsSeen = true;\n                }\n                else {\n                    this.currentSegment.attachmentsSeen = true;\n                }\n                assertDefinedSize(size);\n                let slice = this.reader.requestSlice(dataStartPos, size);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (slice) {\n                    this.readContiguousElements(slice);\n                }\n            }\n            else if (id === EBMLId.Cluster) {\n                this.currentSegment.clusterSeekStartPos = elementStartPos;\n                break; // Stop at the first cluster\n            }\n            if (size === null) {\n                break;\n            }\n            else {\n                currentPos = dataStartPos + size;\n            }\n        }\n        // Sort the seek entries by file position so reading them exhibits a sequential pattern\n        this.currentSegment.seekEntries.sort((a, b) => a.segmentPosition - b.segmentPosition);\n        if (this.reader.fileSize !== null) {\n            // Use the seek head to read missing metadata elements\n            for (const seekEntry of this.currentSegment.seekEntries) {\n                const target = METADATA_ELEMENTS.find(x => x.id === seekEntry.id);\n                if (!target) {\n                    continue;\n                }\n                if (this.currentSegment[target.flag])\n                    continue;\n                let slice = this.reader.requestSliceRange(segmentDataStart + seekEntry.segmentPosition, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (!slice)\n                    continue;\n                const header = readElementHeader(slice);\n                if (!header)\n                    continue;\n                const { id, size } = header;\n                if (id !== target.id)\n                    continue;\n                assertDefinedSize(size);\n                this.currentSegment[target.flag] = true;\n                let dataSlice = this.reader.requestSlice(slice.filePos, size);\n                if (dataSlice instanceof Promise)\n                    dataSlice = await dataSlice;\n                if (!dataSlice)\n                    continue;\n                this.readContiguousElements(dataSlice);\n            }\n        }\n        if (this.currentSegment.timestampScale === -1) {\n            // TimestampScale element is missing. Technically an invalid file, but let's default to the typical value,\n            // which is 1e6.\n            this.currentSegment.timestampScale = 1e6;\n            this.currentSegment.timestampFactor = 1e9 / 1e6;\n        }\n        // Put default tracks first\n        this.currentSegment.tracks.sort((a, b) => Number(b.disposition.default) - Number(a.disposition.default));\n        // Now, let's distribute the cue points to the tracks\n        const idToTrack = new Map(this.currentSegment.tracks.map(x => [x.id, x]));\n        // Assign cue points to their respective tracks\n        for (const cuePoint of this.currentSegment.cuePoints) {\n            const track = idToTrack.get(cuePoint.trackId);\n            if (track) {\n                track.cuePoints.push(cuePoint);\n            }\n        }\n        for (const track of this.currentSegment.tracks) {\n            // Sort cue points by time\n            track.cuePoints.sort((a, b) => a.time - b.time);\n            // Remove multiple cue points for the same time\n            for (let i = 0; i < track.cuePoints.length - 1; i++) {\n                const cuePoint1 = track.cuePoints[i];\n                const cuePoint2 = track.cuePoints[i + 1];\n                if (cuePoint1.time === cuePoint2.time) {\n                    track.cuePoints.splice(i + 1, 1);\n                    i--;\n                }\n            }\n        }\n        let trackWithMostCuePoints = null;\n        let maxCuePointCount = -Infinity;\n        for (const track of this.currentSegment.tracks) {\n            if (track.cuePoints.length > maxCuePointCount) {\n                maxCuePointCount = track.cuePoints.length;\n                trackWithMostCuePoints = track;\n            }\n        }\n        // For every track that has received 0 cue points (can happen, often only the video track receives cue points),\n        // we still want to have better seeking. Therefore, let's give it the cue points of the track with the most cue\n        // points, which should provide us with the most fine-grained seeking.\n        for (const track of this.currentSegment.tracks) {\n            if (track.cuePoints.length === 0) {\n                track.cuePoints = trackWithMostCuePoints.cuePoints;\n            }\n        }\n        this.currentSegment = null;\n    }\n    async readCluster(startPos, segment) {\n        if (segment.lastReadCluster?.elementStartPos === startPos) {\n            return segment.lastReadCluster;\n        }\n        let headerSlice = this.reader.requestSliceRange(startPos, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n        if (headerSlice instanceof Promise)\n            headerSlice = await headerSlice;\n        assert(headerSlice);\n        const elementStartPos = startPos;\n        const elementHeader = readElementHeader(headerSlice);\n        assert(elementHeader);\n        const id = elementHeader.id;\n        assert(id === EBMLId.Cluster);\n        let size = elementHeader.size;\n        const dataStartPos = headerSlice.filePos;\n        if (size === null) {\n            // The cluster's size is undefined (can happen in livestreamed files). We'd still like to know the size of\n            // it, so we have no other choice but to iterate over the EBML structure until we find an element at level\n            // 0 or 1, indicating the end of the cluster (all elements inside the cluster are at level 2).\n            const nextElementPos = await searchForNextElementId(this.reader, dataStartPos, LEVEL_0_AND_1_EBML_IDS, segment.elementEndPos);\n            size = nextElementPos.pos - dataStartPos;\n        }\n        // Load the entire cluster\n        let dataSlice = this.reader.requestSlice(dataStartPos, size);\n        if (dataSlice instanceof Promise)\n            dataSlice = await dataSlice;\n        const cluster = {\n            segment,\n            elementStartPos,\n            elementEndPos: dataStartPos + size,\n            dataStartPos,\n            timestamp: -1,\n            trackData: new Map(),\n        };\n        this.currentCluster = cluster;\n        if (dataSlice) {\n            // Read the children of the cluster, stopping early at level 0 or 1 EBML elements. We do this because some\n            // clusters have incorrect sizes that are too large\n            const endPos = this.readContiguousElements(dataSlice, LEVEL_0_AND_1_EBML_IDS);\n            cluster.elementEndPos = endPos;\n        }\n        for (const [, trackData] of cluster.trackData) {\n            const track = trackData.track;\n            // This must hold, as track datas only get created if a block for that track is encountered\n            assert(trackData.blocks.length > 0);\n            let hasLacedBlocks = false;\n            for (let i = 0; i < trackData.blocks.length; i++) {\n                const block = trackData.blocks[i];\n                block.timestamp += cluster.timestamp;\n                hasLacedBlocks ||= block.lacing !== BlockLacing.None;\n            }\n            trackData.presentationTimestamps = trackData.blocks\n                .map((block, i) => ({ timestamp: block.timestamp, blockIndex: i }))\n                .sort((a, b) => a.timestamp - b.timestamp);\n            for (let i = 0; i < trackData.presentationTimestamps.length; i++) {\n                const currentEntry = trackData.presentationTimestamps[i];\n                const currentBlock = trackData.blocks[currentEntry.blockIndex];\n                if (trackData.firstKeyFrameTimestamp === null && currentBlock.isKeyFrame) {\n                    trackData.firstKeyFrameTimestamp = currentBlock.timestamp;\n                }\n                if (i < trackData.presentationTimestamps.length - 1) {\n                    // Update block durations based on presentation order\n                    const nextEntry = trackData.presentationTimestamps[i + 1];\n                    currentBlock.duration = nextEntry.timestamp - currentBlock.timestamp;\n                }\n                else if (currentBlock.duration === 0) {\n                    if (track.defaultDuration != null) {\n                        if (currentBlock.lacing === BlockLacing.None) {\n                            currentBlock.duration = track.defaultDuration;\n                        }\n                        else {\n                            // Handled by the lace resolution code\n                        }\n                    }\n                }\n            }\n            if (hasLacedBlocks) {\n                // Perform lace resolution. Here, we expand each laced block into multiple blocks where each contains\n                // one frame of the lace. We do this after determining block timestamps so we can properly distribute\n                // the block's duration across the laced frames.\n                this.expandLacedBlocks(trackData.blocks, track);\n                // Recompute since blocks have changed\n                trackData.presentationTimestamps = trackData.blocks\n                    .map((block, i) => ({ timestamp: block.timestamp, blockIndex: i }))\n                    .sort((a, b) => a.timestamp - b.timestamp);\n            }\n            const firstBlock = trackData.blocks[trackData.presentationTimestamps[0].blockIndex];\n            const lastBlock = trackData.blocks[last(trackData.presentationTimestamps).blockIndex];\n            trackData.startTimestamp = firstBlock.timestamp;\n            trackData.endTimestamp = lastBlock.timestamp + lastBlock.duration;\n            // Let's remember that a cluster with a given timestamp is here, speeding up future lookups if no cues exist\n            const insertionIndex = binarySearchLessOrEqual(track.clusterPositionCache, trackData.startTimestamp, x => x.startTimestamp);\n            if (insertionIndex === -1\n                || track.clusterPositionCache[insertionIndex].elementStartPos !== elementStartPos) {\n                track.clusterPositionCache.splice(insertionIndex + 1, 0, {\n                    elementStartPos: cluster.elementStartPos,\n                    startTimestamp: trackData.startTimestamp,\n                });\n            }\n        }\n        segment.lastReadCluster = cluster;\n        return cluster;\n    }\n    getTrackDataInCluster(cluster, trackNumber) {\n        let trackData = cluster.trackData.get(trackNumber);\n        if (!trackData) {\n            const track = cluster.segment.tracks.find(x => x.id === trackNumber);\n            if (!track) {\n                return null;\n            }\n            trackData = {\n                track,\n                startTimestamp: 0,\n                endTimestamp: 0,\n                firstKeyFrameTimestamp: null,\n                blocks: [],\n                presentationTimestamps: [],\n            };\n            cluster.trackData.set(trackNumber, trackData);\n        }\n        return trackData;\n    }\n    expandLacedBlocks(blocks, track) {\n        // https://www.matroska.org/technical/notes.html#block-lacing\n        for (let blockIndex = 0; blockIndex < blocks.length; blockIndex++) {\n            const originalBlock = blocks[blockIndex];\n            if (originalBlock.lacing === BlockLacing.None) {\n                continue;\n            }\n            // Decode the block data if it hasn't been decoded yet (needed for lacing expansion)\n            if (!originalBlock.decoded) {\n                originalBlock.data = this.decodeBlockData(track, originalBlock.data);\n                originalBlock.decoded = true;\n            }\n            const slice = FileSlice.tempFromBytes(originalBlock.data);\n            const frameSizes = [];\n            const frameCount = readU8(slice) + 1;\n            switch (originalBlock.lacing) {\n                case BlockLacing.Xiph:\n                    {\n                        let totalUsedSize = 0;\n                        // Xiph lacing, just like in Ogg\n                        for (let i = 0; i < frameCount - 1; i++) {\n                            let frameSize = 0;\n                            while (slice.bufferPos < slice.length) {\n                                const value = readU8(slice);\n                                frameSize += value;\n                                if (value < 255) {\n                                    frameSizes.push(frameSize);\n                                    totalUsedSize += frameSize;\n                                    break;\n                                }\n                            }\n                        }\n                        // Compute the last frame's size from whatever's left\n                        frameSizes.push(slice.length - (slice.bufferPos + totalUsedSize));\n                    }\n                    ;\n                    break;\n                case BlockLacing.FixedSize:\n                    {\n                        // Fixed size lacing: all frames have same size\n                        const totalDataSize = slice.length - 1; // Minus the frame count byte\n                        const frameSize = Math.floor(totalDataSize / frameCount);\n                        for (let i = 0; i < frameCount; i++) {\n                            frameSizes.push(frameSize);\n                        }\n                    }\n                    ;\n                    break;\n                case BlockLacing.Ebml:\n                    {\n                        // EBML lacing: first size absolute, subsequent ones are coded as signed differences from the last\n                        const firstResult = readVarInt(slice);\n                        assert(firstResult !== null); // Assume it's not an invalid VINT\n                        let currentSize = firstResult;\n                        frameSizes.push(currentSize);\n                        let totalUsedSize = currentSize;\n                        for (let i = 1; i < frameCount - 1; i++) {\n                            const startPos = slice.bufferPos;\n                            const diffResult = readVarInt(slice);\n                            assert(diffResult !== null);\n                            const unsignedDiff = diffResult;\n                            const width = slice.bufferPos - startPos;\n                            const bias = (1 << (width * 7 - 1)) - 1; // Typo-corrected version of 2^((7*n)-1)^-1\n                            const diff = unsignedDiff - bias;\n                            currentSize += diff;\n                            frameSizes.push(currentSize);\n                            totalUsedSize += currentSize;\n                        }\n                        // Compute the last frame's size from whatever's left\n                        frameSizes.push(slice.length - (slice.bufferPos + totalUsedSize));\n                    }\n                    ;\n                    break;\n                default: assert(false);\n            }\n            assert(frameSizes.length === frameCount);\n            blocks.splice(blockIndex, 1); // Remove the original block\n            const blockDuration = originalBlock.duration || frameCount * (track.defaultDuration ?? 0);\n            // Now, let's insert each frame as its own block\n            for (let i = 0; i < frameCount; i++) {\n                const frameSize = frameSizes[i];\n                const frameData = readBytes(slice, frameSize);\n                // Distribute timestamps evenly across the block duration\n                const frameTimestamp = originalBlock.timestamp + (blockDuration * i / frameCount);\n                const frameDuration = blockDuration / frameCount;\n                blocks.splice(blockIndex + i, 0, {\n                    timestamp: frameTimestamp,\n                    duration: frameDuration,\n                    isKeyFrame: originalBlock.isKeyFrame,\n                    data: frameData,\n                    lacing: BlockLacing.None,\n                    decoded: true,\n                    mainAdditional: originalBlock.mainAdditional,\n                });\n            }\n            blockIndex += frameCount; // Skip the blocks we just added\n            blockIndex--;\n        }\n    }\n    async loadSegmentMetadata(segment) {\n        for (const seekEntry of segment.seekEntries) {\n            if (seekEntry.id === EBMLId.Tags && !segment.tagsSeen) {\n                // We need to load the tags\n            }\n            else if (seekEntry.id === EBMLId.Attachments && !segment.attachmentsSeen) {\n                // We need to load the attachments\n            }\n            else {\n                continue;\n            }\n            let slice = this.reader.requestSliceRange(segment.dataStartPos + seekEntry.segmentPosition, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n            if (slice instanceof Promise)\n                slice = await slice;\n            if (!slice)\n                continue;\n            const header = readElementHeader(slice);\n            if (!header || header.id !== seekEntry.id)\n                continue;\n            const { size } = header;\n            assertDefinedSize(size);\n            assert(!this.currentSegment);\n            this.currentSegment = segment;\n            let dataSlice = this.reader.requestSlice(slice.filePos, size);\n            if (dataSlice instanceof Promise)\n                dataSlice = await dataSlice;\n            if (dataSlice) {\n                this.readContiguousElements(dataSlice);\n            }\n            this.currentSegment = null;\n            // Mark as seen\n            if (seekEntry.id === EBMLId.Tags) {\n                segment.tagsSeen = true;\n            }\n            else if (seekEntry.id === EBMLId.Attachments) {\n                segment.attachmentsSeen = true;\n            }\n        }\n    }\n    readContiguousElements(slice, stopIds) {\n        const startIndex = slice.filePos;\n        while (slice.filePos - startIndex <= slice.length - MIN_HEADER_SIZE) {\n            const startPos = slice.filePos;\n            const foundElement = this.traverseElement(slice, stopIds);\n            if (!foundElement) {\n                return startPos;\n            }\n        }\n        return slice.filePos;\n    }\n    traverseElement(slice, stopIds) {\n        const header = readElementHeader(slice);\n        if (!header) {\n            return false;\n        }\n        if (stopIds && stopIds.includes(header.id)) {\n            return false;\n        }\n        const { id, size } = header;\n        const dataStartPos = slice.filePos;\n        assertDefinedSize(size);\n        switch (id) {\n            case EBMLId.DocType:\n                {\n                    this.isWebM = readAsciiString(slice, size) === 'webm';\n                }\n                ;\n                break;\n            case EBMLId.Seek:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    const seekEntry = { id: -1, segmentPosition: -1 };\n                    this.currentSegment.seekEntries.push(seekEntry);\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    if (seekEntry.id === -1 || seekEntry.segmentPosition === -1) {\n                        this.currentSegment.seekEntries.pop();\n                    }\n                }\n                ;\n                break;\n            case EBMLId.SeekID:\n                {\n                    const lastSeekEntry = this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length - 1];\n                    if (!lastSeekEntry)\n                        break;\n                    lastSeekEntry.id = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.SeekPosition:\n                {\n                    const lastSeekEntry = this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length - 1];\n                    if (!lastSeekEntry)\n                        break;\n                    lastSeekEntry.segmentPosition = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.TimestampScale:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    this.currentSegment.timestampScale = readUnsignedInt(slice, size);\n                    this.currentSegment.timestampFactor = 1e9 / this.currentSegment.timestampScale;\n                }\n                ;\n                break;\n            case EBMLId.Duration:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    this.currentSegment.duration = readFloat(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.TrackEntry:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    this.currentTrack = {\n                        id: -1,\n                        segment: this.currentSegment,\n                        demuxer: this,\n                        clusterPositionCache: [],\n                        cuePoints: [],\n                        disposition: {\n                            ...DEFAULT_TRACK_DISPOSITION,\n                        },\n                        inputTrack: null,\n                        codecId: null,\n                        codecPrivate: null,\n                        defaultDuration: null,\n                        name: null,\n                        languageCode: UNDETERMINED_LANGUAGE,\n                        decodingInstructions: [],\n                        info: null,\n                    };\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    if (this.currentTrack.decodingInstructions.some((instruction) => {\n                        return instruction.data?.type !== 'decompress'\n                            || instruction.scope !== ContentEncodingScope.Block\n                            || instruction.data.algorithm !== ContentCompAlgo.HeaderStripping;\n                    })) {\n                        console.warn(`Track #${this.currentTrack.id} has an unsupported content encoding; dropping.`);\n                        this.currentTrack = null;\n                    }\n                    if (this.currentTrack\n                        && this.currentTrack.id !== -1\n                        && this.currentTrack.codecId\n                        && this.currentTrack.info) {\n                        const slashIndex = this.currentTrack.codecId.indexOf('/');\n                        const codecIdWithoutSuffix = slashIndex === -1\n                            ? this.currentTrack.codecId\n                            : this.currentTrack.codecId.slice(0, slashIndex);\n                        if (this.currentTrack.info.type === 'video'\n                            && this.currentTrack.info.width !== -1\n                            && this.currentTrack.info.height !== -1) {\n                            if (this.currentTrack.codecId === CODEC_STRING_MAP.avc) {\n                                this.currentTrack.info.codec = 'avc';\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (this.currentTrack.codecId === CODEC_STRING_MAP.hevc) {\n                                this.currentTrack.info.codec = 'hevc';\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.vp8) {\n                                this.currentTrack.info.codec = 'vp8';\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.vp9) {\n                                this.currentTrack.info.codec = 'vp9';\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.av1) {\n                                this.currentTrack.info.codec = 'av1';\n                            }\n                            const videoTrack = this.currentTrack;\n                            const inputTrack = new InputVideoTrack(this.input, new MatroskaVideoTrackBacking(videoTrack));\n                            this.currentTrack.inputTrack = inputTrack;\n                            this.currentSegment.tracks.push(this.currentTrack);\n                        }\n                        else if (this.currentTrack.info.type === 'audio'\n                            && this.currentTrack.info.numberOfChannels !== -1\n                            && this.currentTrack.info.sampleRate !== -1) {\n                            if (codecIdWithoutSuffix === CODEC_STRING_MAP.aac) {\n                                this.currentTrack.info.codec = 'aac';\n                                this.currentTrack.info.aacCodecInfo = {\n                                    isMpeg2: this.currentTrack.codecId.includes('MPEG2'),\n                                };\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (this.currentTrack.codecId === CODEC_STRING_MAP.mp3) {\n                                this.currentTrack.info.codec = 'mp3';\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.opus) {\n                                this.currentTrack.info.codec = 'opus';\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                                this.currentTrack.info.sampleRate = OPUS_SAMPLE_RATE; // Always the same\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.vorbis) {\n                                this.currentTrack.info.codec = 'vorbis';\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (codecIdWithoutSuffix === CODEC_STRING_MAP.flac) {\n                                this.currentTrack.info.codec = 'flac';\n                                this.currentTrack.info.codecDescription = this.currentTrack.codecPrivate;\n                            }\n                            else if (this.currentTrack.codecId === 'A_PCM/INT/LIT') {\n                                if (this.currentTrack.info.bitDepth === 8) {\n                                    this.currentTrack.info.codec = 'pcm-u8';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 16) {\n                                    this.currentTrack.info.codec = 'pcm-s16';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 24) {\n                                    this.currentTrack.info.codec = 'pcm-s24';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 32) {\n                                    this.currentTrack.info.codec = 'pcm-s32';\n                                }\n                            }\n                            else if (this.currentTrack.codecId === 'A_PCM/INT/BIG') {\n                                if (this.currentTrack.info.bitDepth === 8) {\n                                    this.currentTrack.info.codec = 'pcm-u8';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 16) {\n                                    this.currentTrack.info.codec = 'pcm-s16be';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 24) {\n                                    this.currentTrack.info.codec = 'pcm-s24be';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 32) {\n                                    this.currentTrack.info.codec = 'pcm-s32be';\n                                }\n                            }\n                            else if (this.currentTrack.codecId === 'A_PCM/FLOAT/IEEE') {\n                                if (this.currentTrack.info.bitDepth === 32) {\n                                    this.currentTrack.info.codec = 'pcm-f32';\n                                }\n                                else if (this.currentTrack.info.bitDepth === 64) {\n                                    this.currentTrack.info.codec = 'pcm-f64';\n                                }\n                            }\n                            const audioTrack = this.currentTrack;\n                            const inputTrack = new InputAudioTrack(this.input, new MatroskaAudioTrackBacking(audioTrack));\n                            this.currentTrack.inputTrack = inputTrack;\n                            this.currentSegment.tracks.push(this.currentTrack);\n                        }\n                    }\n                    this.currentTrack = null;\n                }\n                ;\n                break;\n            case EBMLId.TrackNumber:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.id = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.TrackType:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    const type = readUnsignedInt(slice, size);\n                    if (type === 1) {\n                        this.currentTrack.info = {\n                            type: 'video',\n                            width: -1,\n                            height: -1,\n                            rotation: 0,\n                            codec: null,\n                            codecDescription: null,\n                            colorSpace: null,\n                            alphaMode: false,\n                        };\n                    }\n                    else if (type === 2) {\n                        this.currentTrack.info = {\n                            type: 'audio',\n                            numberOfChannels: -1,\n                            sampleRate: -1,\n                            bitDepth: -1,\n                            codec: null,\n                            codecDescription: null,\n                            aacCodecInfo: null,\n                        };\n                    }\n                }\n                ;\n                break;\n            case EBMLId.FlagEnabled:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    const enabled = readUnsignedInt(slice, size);\n                    if (!enabled) {\n                        this.currentSegment.tracks.pop();\n                        this.currentTrack = null;\n                    }\n                }\n                ;\n                break;\n            case EBMLId.FlagDefault:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.disposition.default = !!readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FlagForced:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.disposition.forced = !!readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FlagOriginal:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.disposition.original = !!readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FlagHearingImpaired:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.disposition.hearingImpaired = !!readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FlagVisualImpaired:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.disposition.visuallyImpaired = !!readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FlagCommentary:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.disposition.commentary = !!readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.CodecID:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.codecId = readAsciiString(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.CodecPrivate:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.codecPrivate = readBytes(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.DefaultDuration:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.defaultDuration\n                        = this.currentTrack.segment.timestampFactor * readUnsignedInt(slice, size) / 1e9;\n                }\n                ;\n                break;\n            case EBMLId.Name:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.currentTrack.name = readUnicodeString(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.Language:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    if (this.currentTrack.languageCode !== UNDETERMINED_LANGUAGE) {\n                        // LanguageBCP47 was present, which takes precedence\n                        break;\n                    }\n                    this.currentTrack.languageCode = readAsciiString(slice, size);\n                    if (!isIso639Dash2LanguageCode(this.currentTrack.languageCode)) {\n                        this.currentTrack.languageCode = UNDETERMINED_LANGUAGE;\n                    }\n                }\n                ;\n                break;\n            case EBMLId.LanguageBCP47:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    const bcp47 = readAsciiString(slice, size);\n                    const languageSubtag = bcp47.split('-')[0];\n                    if (languageSubtag) {\n                        // Technically invalid, for now: The language subtag might be a language code from ISO 639-1,\n                        // ISO 639-2, ISO 639-3, ISO 639-5 or some other thing (source: Wikipedia). But, `languageCode` is\n                        // documented as ISO 639-2. Changing the definition would be a breaking change. This will get\n                        // cleaned up in the future by defining languageCode to be BCP 47 instead.\n                        this.currentTrack.languageCode = languageSubtag;\n                    }\n                    else {\n                        this.currentTrack.languageCode = UNDETERMINED_LANGUAGE;\n                    }\n                }\n                ;\n                break;\n            case EBMLId.Video:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.PixelWidth:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.currentTrack.info.width = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.PixelHeight:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.currentTrack.info.height = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.AlphaMode:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.currentTrack.info.alphaMode = readUnsignedInt(slice, size) === 1;\n                }\n                ;\n                break;\n            case EBMLId.Colour:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.currentTrack.info.colorSpace = {};\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.MatrixCoefficients:\n                {\n                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace)\n                        break;\n                    const matrixCoefficients = readUnsignedInt(slice, size);\n                    const mapped = MATRIX_COEFFICIENTS_MAP_INVERSE[matrixCoefficients] ?? null;\n                    this.currentTrack.info.colorSpace.matrix = mapped;\n                }\n                ;\n                break;\n            case EBMLId.Range:\n                {\n                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace)\n                        break;\n                    this.currentTrack.info.colorSpace.fullRange = readUnsignedInt(slice, size) === 2;\n                }\n                ;\n                break;\n            case EBMLId.TransferCharacteristics:\n                {\n                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace)\n                        break;\n                    const transferCharacteristics = readUnsignedInt(slice, size);\n                    const mapped = TRANSFER_CHARACTERISTICS_MAP_INVERSE[transferCharacteristics] ?? null;\n                    this.currentTrack.info.colorSpace.transfer = mapped;\n                }\n                ;\n                break;\n            case EBMLId.Primaries:\n                {\n                    if (this.currentTrack?.info?.type !== 'video' || !this.currentTrack.info.colorSpace)\n                        break;\n                    const primaries = readUnsignedInt(slice, size);\n                    const mapped = COLOR_PRIMARIES_MAP_INVERSE[primaries] ?? null;\n                    this.currentTrack.info.colorSpace.primaries = mapped;\n                }\n                ;\n                break;\n            case EBMLId.Projection:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.ProjectionPoseRoll:\n                {\n                    if (this.currentTrack?.info?.type !== 'video')\n                        break;\n                    const rotation = readFloat(slice, size);\n                    const flippedRotation = -rotation; // Convert counter-clockwise to clockwise\n                    try {\n                        this.currentTrack.info.rotation = normalizeRotation(flippedRotation);\n                    }\n                    catch {\n                        // It wasn't a valid rotation\n                    }\n                }\n                ;\n                break;\n            case EBMLId.Audio:\n                {\n                    if (this.currentTrack?.info?.type !== 'audio')\n                        break;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.SamplingFrequency:\n                {\n                    if (this.currentTrack?.info?.type !== 'audio')\n                        break;\n                    this.currentTrack.info.sampleRate = readFloat(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.Channels:\n                {\n                    if (this.currentTrack?.info?.type !== 'audio')\n                        break;\n                    this.currentTrack.info.numberOfChannels = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.BitDepth:\n                {\n                    if (this.currentTrack?.info?.type !== 'audio')\n                        break;\n                    this.currentTrack.info.bitDepth = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.CuePoint:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    this.currentCueTime = null;\n                }\n                ;\n                break;\n            case EBMLId.CueTime:\n                {\n                    this.currentCueTime = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.CueTrackPositions:\n                {\n                    if (this.currentCueTime === null)\n                        break;\n                    assert(this.currentSegment);\n                    const cuePoint = { time: this.currentCueTime, trackId: -1, clusterPosition: -1 };\n                    this.currentSegment.cuePoints.push(cuePoint);\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    if (cuePoint.trackId === -1 || cuePoint.clusterPosition === -1) {\n                        this.currentSegment.cuePoints.pop();\n                    }\n                }\n                ;\n                break;\n            case EBMLId.CueTrack:\n                {\n                    const lastCuePoint = this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length - 1];\n                    if (!lastCuePoint)\n                        break;\n                    lastCuePoint.trackId = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.CueClusterPosition:\n                {\n                    const lastCuePoint = this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length - 1];\n                    if (!lastCuePoint)\n                        break;\n                    assert(this.currentSegment);\n                    lastCuePoint.clusterPosition = this.currentSegment.dataStartPos + readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.Timestamp:\n                {\n                    if (!this.currentCluster)\n                        break;\n                    this.currentCluster.timestamp = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.SimpleBlock:\n                {\n                    if (!this.currentCluster)\n                        break;\n                    const trackNumber = readVarInt(slice);\n                    if (trackNumber === null)\n                        break;\n                    const trackData = this.getTrackDataInCluster(this.currentCluster, trackNumber);\n                    if (!trackData)\n                        break; // Not a track we care about\n                    const relativeTimestamp = readI16Be(slice);\n                    const flags = readU8(slice);\n                    const lacing = (flags >> 1) & 0x3; // If the block is laced, we'll expand it later\n                    let isKeyFrame = !!(flags & 0x80);\n                    if (trackData.track.info?.type === 'audio' && trackData.track.info.codec) {\n                        // Some files don't mark their audio packets as key packets (I'm looking at you, Firefox). But, we\n                        // can fix this in most cases: if we recognize the codec of the track, then we know every packet is\n                        // necessarily a key packet, no matter what the container says.\n                        // https://github.com/Vanilagy/mediabunny/issues/192\n                        isKeyFrame = true;\n                    }\n                    const blockData = readBytes(slice, size - (slice.filePos - dataStartPos));\n                    const hasDecodingInstructions = trackData.track.decodingInstructions.length > 0;\n                    trackData.blocks.push({\n                        timestamp: relativeTimestamp, // We'll add the cluster's timestamp to this later\n                        duration: 0, // Will set later\n                        isKeyFrame,\n                        data: blockData,\n                        lacing,\n                        decoded: !hasDecodingInstructions,\n                        mainAdditional: null,\n                    });\n                }\n                ;\n                break;\n            case EBMLId.BlockGroup:\n                {\n                    if (!this.currentCluster)\n                        break;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    this.currentBlock = null;\n                }\n                ;\n                break;\n            case EBMLId.Block:\n                {\n                    if (!this.currentCluster)\n                        break;\n                    const trackNumber = readVarInt(slice);\n                    if (trackNumber === null)\n                        break;\n                    const trackData = this.getTrackDataInCluster(this.currentCluster, trackNumber);\n                    if (!trackData)\n                        break;\n                    const relativeTimestamp = readI16Be(slice);\n                    const flags = readU8(slice);\n                    const lacing = (flags >> 1) & 0x3; // If the block is laced, we'll expand it later\n                    const blockData = readBytes(slice, size - (slice.filePos - dataStartPos));\n                    const hasDecodingInstructions = trackData.track.decodingInstructions.length > 0;\n                    this.currentBlock = {\n                        timestamp: relativeTimestamp, // We'll add the cluster's timestamp to this later\n                        duration: 0, // Will set later\n                        isKeyFrame: true,\n                        data: blockData,\n                        lacing,\n                        decoded: !hasDecodingInstructions,\n                        mainAdditional: null,\n                    };\n                    trackData.blocks.push(this.currentBlock);\n                }\n                ;\n                break;\n            case EBMLId.BlockAdditions:\n                {\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.BlockMore:\n                {\n                    if (!this.currentBlock)\n                        break;\n                    this.currentBlockAdditional = {\n                        addId: 1,\n                        data: null,\n                    };\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    if (this.currentBlockAdditional.data && this.currentBlockAdditional.addId === 1) {\n                        this.currentBlock.mainAdditional = this.currentBlockAdditional.data;\n                    }\n                    this.currentBlockAdditional = null;\n                }\n                ;\n                break;\n            case EBMLId.BlockAdditional:\n                {\n                    if (!this.currentBlockAdditional)\n                        break;\n                    this.currentBlockAdditional.data = readBytes(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.BlockAddID:\n                {\n                    if (!this.currentBlockAdditional)\n                        break;\n                    this.currentBlockAdditional.addId = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.BlockDuration:\n                {\n                    if (!this.currentBlock)\n                        break;\n                    this.currentBlock.duration = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.ReferenceBlock:\n                {\n                    if (!this.currentBlock)\n                        break;\n                    this.currentBlock.isKeyFrame = false;\n                    // We ignore the actual value here, we just use the reference as an indicator for \"not a key frame\".\n                    // This is in line with FFmpeg's behavior.\n                }\n                ;\n                break;\n            case EBMLId.Tag:\n                {\n                    this.currentTagTargetIsMovie = true;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.Targets:\n                {\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.TargetTypeValue:\n                {\n                    const targetTypeValue = readUnsignedInt(slice, size);\n                    if (targetTypeValue !== 50) {\n                        this.currentTagTargetIsMovie = false;\n                    }\n                }\n                ;\n                break;\n            case EBMLId.TagTrackUID:\n            case EBMLId.TagEditionUID:\n            case EBMLId.TagChapterUID:\n            case EBMLId.TagAttachmentUID:\n                {\n                    this.currentTagTargetIsMovie = false;\n                }\n                ;\n                break;\n            case EBMLId.SimpleTag:\n                {\n                    if (!this.currentTagTargetIsMovie)\n                        break;\n                    this.currentSimpleTagName = null;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.TagName:\n                {\n                    this.currentSimpleTagName = readUnicodeString(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.TagString:\n                {\n                    if (!this.currentSimpleTagName)\n                        break;\n                    const value = readUnicodeString(slice, size);\n                    this.processTagValue(this.currentSimpleTagName, value);\n                }\n                ;\n                break;\n            case EBMLId.TagBinary:\n                {\n                    if (!this.currentSimpleTagName)\n                        break;\n                    const value = readBytes(slice, size);\n                    this.processTagValue(this.currentSimpleTagName, value);\n                }\n                ;\n                break;\n            case EBMLId.AttachedFile:\n                {\n                    if (!this.currentSegment)\n                        break;\n                    this.currentAttachedFile = {\n                        fileUid: null,\n                        fileName: null,\n                        fileMediaType: null,\n                        fileData: null,\n                        fileDescription: null,\n                    };\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    const tags = this.currentSegment.metadataTags;\n                    if (this.currentAttachedFile.fileUid && this.currentAttachedFile.fileData) {\n                        // All attached files get surfaced in the `raw` metadata tags\n                        tags.raw ??= {};\n                        tags.raw[this.currentAttachedFile.fileUid.toString()] = new AttachedFile(this.currentAttachedFile.fileData, this.currentAttachedFile.fileMediaType ?? undefined, this.currentAttachedFile.fileName ?? undefined, this.currentAttachedFile.fileDescription ?? undefined);\n                    }\n                    // Only process image attachments\n                    if (this.currentAttachedFile.fileMediaType?.startsWith('image/') && this.currentAttachedFile.fileData) {\n                        const fileName = this.currentAttachedFile.fileName;\n                        let kind = 'unknown';\n                        if (fileName) {\n                            const lowerName = fileName.toLowerCase();\n                            if (lowerName.startsWith('cover.')) {\n                                kind = 'coverFront';\n                            }\n                            else if (lowerName.startsWith('back.')) {\n                                kind = 'coverBack';\n                            }\n                        }\n                        tags.images ??= [];\n                        tags.images.push({\n                            data: this.currentAttachedFile.fileData,\n                            mimeType: this.currentAttachedFile.fileMediaType,\n                            kind,\n                            name: this.currentAttachedFile.fileName ?? undefined,\n                            description: this.currentAttachedFile.fileDescription ?? undefined,\n                        });\n                    }\n                    this.currentAttachedFile = null;\n                }\n                ;\n                break;\n            case EBMLId.FileUID:\n                {\n                    if (!this.currentAttachedFile)\n                        break;\n                    this.currentAttachedFile.fileUid = readUnsignedBigInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FileName:\n                {\n                    if (!this.currentAttachedFile)\n                        break;\n                    this.currentAttachedFile.fileName = readUnicodeString(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FileMediaType:\n                {\n                    if (!this.currentAttachedFile)\n                        break;\n                    this.currentAttachedFile.fileMediaType = readAsciiString(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FileData:\n                {\n                    if (!this.currentAttachedFile)\n                        break;\n                    this.currentAttachedFile.fileData = readBytes(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.FileDescription:\n                {\n                    if (!this.currentAttachedFile)\n                        break;\n                    this.currentAttachedFile.fileDescription = readUnicodeString(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.ContentEncodings:\n                {\n                    if (!this.currentTrack)\n                        break;\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    // \"**MUST** start with the `ContentEncoding` with the highest `ContentEncodingOrder`\"\n                    this.currentTrack.decodingInstructions.sort((a, b) => b.order - a.order);\n                }\n                ;\n                break;\n            case EBMLId.ContentEncoding:\n                {\n                    this.currentDecodingInstruction = {\n                        order: 0,\n                        scope: ContentEncodingScope.Block,\n                        data: null,\n                    };\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                    if (this.currentDecodingInstruction.data) {\n                        this.currentTrack.decodingInstructions.push(this.currentDecodingInstruction);\n                    }\n                    this.currentDecodingInstruction = null;\n                }\n                ;\n                break;\n            case EBMLId.ContentEncodingOrder:\n                {\n                    if (!this.currentDecodingInstruction)\n                        break;\n                    this.currentDecodingInstruction.order = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.ContentEncodingScope:\n                {\n                    if (!this.currentDecodingInstruction)\n                        break;\n                    this.currentDecodingInstruction.scope = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.ContentCompression:\n                {\n                    if (!this.currentDecodingInstruction)\n                        break;\n                    this.currentDecodingInstruction.data = {\n                        type: 'decompress',\n                        algorithm: ContentCompAlgo.Zlib,\n                        settings: null,\n                    };\n                    this.readContiguousElements(slice.slice(dataStartPos, size));\n                }\n                ;\n                break;\n            case EBMLId.ContentCompAlgo:\n                {\n                    if (this.currentDecodingInstruction?.data?.type !== 'decompress')\n                        break;\n                    this.currentDecodingInstruction.data.algorithm = readUnsignedInt(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.ContentCompSettings:\n                {\n                    if (this.currentDecodingInstruction?.data?.type !== 'decompress')\n                        break;\n                    this.currentDecodingInstruction.data.settings = readBytes(slice, size);\n                }\n                ;\n                break;\n            case EBMLId.ContentEncryption:\n                {\n                    if (!this.currentDecodingInstruction)\n                        break;\n                    this.currentDecodingInstruction.data = {\n                        type: 'decrypt',\n                    };\n                }\n                ;\n                break;\n        }\n        slice.filePos = dataStartPos + size;\n        return true;\n    }\n    decodeBlockData(track, rawData) {\n        assert(track.decodingInstructions.length > 0); // This method shouldn't be called otherwise\n        let currentData = rawData;\n        for (const instruction of track.decodingInstructions) {\n            assert(instruction.data);\n            switch (instruction.data.type) {\n                case 'decompress':\n                    {\n                        switch (instruction.data.algorithm) {\n                            case ContentCompAlgo.HeaderStripping:\n                                {\n                                    if (instruction.data.settings && instruction.data.settings.length > 0) {\n                                        const prefix = instruction.data.settings;\n                                        const newData = new Uint8Array(prefix.length + currentData.length);\n                                        newData.set(prefix, 0);\n                                        newData.set(currentData, prefix.length);\n                                        currentData = newData;\n                                    }\n                                }\n                                ;\n                                break;\n                            default:\n                                {\n                                    // Unhandled\n                                }\n                                ;\n                        }\n                    }\n                    ;\n                    break;\n                default:\n                    {\n                        // Unhandled\n                    }\n                    ;\n            }\n        }\n        return currentData;\n    }\n    processTagValue(name, value) {\n        if (!this.currentSegment?.metadataTags)\n            return;\n        const metadataTags = this.currentSegment.metadataTags;\n        metadataTags.raw ??= {};\n        metadataTags.raw[name] ??= value;\n        if (typeof value === 'string') {\n            switch (name.toLowerCase()) {\n                case 'title':\n                    {\n                        metadataTags.title ??= value;\n                    }\n                    ;\n                    break;\n                case 'description':\n                    {\n                        metadataTags.description ??= value;\n                    }\n                    ;\n                    break;\n                case 'artist':\n                    {\n                        metadataTags.artist ??= value;\n                    }\n                    ;\n                    break;\n                case 'album':\n                    {\n                        metadataTags.album ??= value;\n                    }\n                    ;\n                    break;\n                case 'album_artist':\n                    {\n                        metadataTags.albumArtist ??= value;\n                    }\n                    ;\n                    break;\n                case 'genre':\n                    {\n                        metadataTags.genre ??= value;\n                    }\n                    ;\n                    break;\n                case 'comment':\n                    {\n                        metadataTags.comment ??= value;\n                    }\n                    ;\n                    break;\n                case 'lyrics':\n                    {\n                        metadataTags.lyrics ??= value;\n                    }\n                    ;\n                    break;\n                case 'date':\n                    {\n                        const date = new Date(value);\n                        if (!Number.isNaN(date.getTime())) {\n                            metadataTags.date ??= date;\n                        }\n                    }\n                    ;\n                    break;\n                case 'track_number':\n                case 'part_number':\n                    {\n                        const parts = value.split('/');\n                        const trackNum = Number.parseInt(parts[0], 10);\n                        const tracksTotal = parts[1] && Number.parseInt(parts[1], 10);\n                        if (Number.isInteger(trackNum) && trackNum > 0) {\n                            metadataTags.trackNumber ??= trackNum;\n                        }\n                        if (tracksTotal && Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                            metadataTags.tracksTotal ??= tracksTotal;\n                        }\n                    }\n                    ;\n                    break;\n                case 'disc_number':\n                case 'disc':\n                    {\n                        const discParts = value.split('/');\n                        const discNum = Number.parseInt(discParts[0], 10);\n                        const discsTotal = discParts[1] && Number.parseInt(discParts[1], 10);\n                        if (Number.isInteger(discNum) && discNum > 0) {\n                            metadataTags.discNumber ??= discNum;\n                        }\n                        if (discsTotal && Number.isInteger(discsTotal) && discsTotal > 0) {\n                            metadataTags.discsTotal ??= discsTotal;\n                        }\n                    }\n                    ;\n                    break;\n            }\n        }\n    }\n}\nclass MatroskaTrackBacking {\n    constructor(internalTrack) {\n        this.internalTrack = internalTrack;\n        this.packetToClusterLocation = new WeakMap();\n    }\n    getId() {\n        return this.internalTrack.id;\n    }\n    getCodec() {\n        throw new Error('Not implemented on base class.');\n    }\n    getInternalCodecId() {\n        return this.internalTrack.codecId;\n    }\n    async computeDuration() {\n        const lastPacket = await this.getPacket(Infinity, { metadataOnly: true });\n        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);\n    }\n    getName() {\n        return this.internalTrack.name;\n    }\n    getLanguageCode() {\n        return this.internalTrack.languageCode;\n    }\n    async getFirstTimestamp() {\n        const firstPacket = await this.getFirstPacket({ metadataOnly: true });\n        return firstPacket?.timestamp ?? 0;\n    }\n    getTimeResolution() {\n        return this.internalTrack.segment.timestampFactor;\n    }\n    getDisposition() {\n        return this.internalTrack.disposition;\n    }\n    async getFirstPacket(options) {\n        return this.performClusterLookup(null, (cluster) => {\n            const trackData = cluster.trackData.get(this.internalTrack.id);\n            if (trackData) {\n                return {\n                    blockIndex: 0,\n                    correctBlockFound: true,\n                };\n            }\n            return {\n                blockIndex: -1,\n                correctBlockFound: false,\n            };\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the cues\n        Infinity, options);\n    }\n    intoTimescale(timestamp) {\n        // Do a little rounding to catch cases where the result is very close to an integer. If it is, it's likely\n        // that the number was originally an integer divided by the timescale. For stability, it's best\n        // to return the integer in this case.\n        return roundIfAlmostInteger(timestamp * this.internalTrack.segment.timestampFactor);\n    }\n    async getPacket(timestamp, options) {\n        const timestampInTimescale = this.intoTimescale(timestamp);\n        return this.performClusterLookup(null, (cluster) => {\n            const trackData = cluster.trackData.get(this.internalTrack.id);\n            if (!trackData) {\n                return { blockIndex: -1, correctBlockFound: false };\n            }\n            const index = binarySearchLessOrEqual(trackData.presentationTimestamps, timestampInTimescale, x => x.timestamp);\n            const blockIndex = index !== -1 ? trackData.presentationTimestamps[index].blockIndex : -1;\n            const correctBlockFound = index !== -1 && timestampInTimescale < trackData.endTimestamp;\n            return { blockIndex, correctBlockFound };\n        }, timestampInTimescale, timestampInTimescale, options);\n    }\n    async getNextPacket(packet, options) {\n        const locationInCluster = this.packetToClusterLocation.get(packet);\n        if (locationInCluster === undefined) {\n            throw new Error('Packet was not created from this track.');\n        }\n        return this.performClusterLookup(locationInCluster.cluster, (cluster) => {\n            if (cluster === locationInCluster.cluster) {\n                const trackData = cluster.trackData.get(this.internalTrack.id);\n                if (locationInCluster.blockIndex + 1 < trackData.blocks.length) {\n                    // We can simply take the next block in the cluster\n                    return {\n                        blockIndex: locationInCluster.blockIndex + 1,\n                        correctBlockFound: true,\n                    };\n                }\n            }\n            else {\n                const trackData = cluster.trackData.get(this.internalTrack.id);\n                if (trackData) {\n                    return {\n                        blockIndex: 0,\n                        correctBlockFound: true,\n                    };\n                }\n            }\n            return {\n                blockIndex: -1,\n                correctBlockFound: false,\n            };\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the cues\n        Infinity, options);\n    }\n    async getKeyPacket(timestamp, options) {\n        const timestampInTimescale = this.intoTimescale(timestamp);\n        return this.performClusterLookup(null, (cluster) => {\n            const trackData = cluster.trackData.get(this.internalTrack.id);\n            if (!trackData) {\n                return { blockIndex: -1, correctBlockFound: false };\n            }\n            const index = findLastIndex(trackData.presentationTimestamps, (x) => {\n                const block = trackData.blocks[x.blockIndex];\n                return block.isKeyFrame && x.timestamp <= timestampInTimescale;\n            });\n            const blockIndex = index !== -1 ? trackData.presentationTimestamps[index].blockIndex : -1;\n            const correctBlockFound = index !== -1 && timestampInTimescale < trackData.endTimestamp;\n            return { blockIndex, correctBlockFound };\n        }, timestampInTimescale, timestampInTimescale, options);\n    }\n    async getNextKeyPacket(packet, options) {\n        const locationInCluster = this.packetToClusterLocation.get(packet);\n        if (locationInCluster === undefined) {\n            throw new Error('Packet was not created from this track.');\n        }\n        return this.performClusterLookup(locationInCluster.cluster, (cluster) => {\n            if (cluster === locationInCluster.cluster) {\n                const trackData = cluster.trackData.get(this.internalTrack.id);\n                const nextKeyFrameIndex = trackData.blocks.findIndex((x, i) => x.isKeyFrame && i > locationInCluster.blockIndex);\n                if (nextKeyFrameIndex !== -1) {\n                    // We can simply take the next key frame in the cluster\n                    return {\n                        blockIndex: nextKeyFrameIndex,\n                        correctBlockFound: true,\n                    };\n                }\n            }\n            else {\n                const trackData = cluster.trackData.get(this.internalTrack.id);\n                if (trackData && trackData.firstKeyFrameTimestamp !== null) {\n                    const keyFrameIndex = trackData.blocks.findIndex(x => x.isKeyFrame);\n                    assert(keyFrameIndex !== -1); // There must be one\n                    return {\n                        blockIndex: keyFrameIndex,\n                        correctBlockFound: true,\n                    };\n                }\n            }\n            return {\n                blockIndex: -1,\n                correctBlockFound: false,\n            };\n        }, -Infinity, // Use -Infinity as a search timestamp to avoid using the cues\n        Infinity, options);\n    }\n    async fetchPacketInCluster(cluster, blockIndex, options) {\n        if (blockIndex === -1) {\n            return null;\n        }\n        const trackData = cluster.trackData.get(this.internalTrack.id);\n        const block = trackData.blocks[blockIndex];\n        assert(block);\n        // Perform lazy decoding if needed\n        if (!block.decoded) {\n            block.data = this.internalTrack.demuxer.decodeBlockData(this.internalTrack, block.data);\n            block.decoded = true;\n        }\n        const data = options.metadataOnly ? PLACEHOLDER_DATA : block.data;\n        const timestamp = block.timestamp / this.internalTrack.segment.timestampFactor;\n        const duration = block.duration / this.internalTrack.segment.timestampFactor;\n        const sideData = {};\n        if (block.mainAdditional && this.internalTrack.info?.type === 'video' && this.internalTrack.info.alphaMode) {\n            sideData.alpha = options.metadataOnly ? PLACEHOLDER_DATA : block.mainAdditional;\n            sideData.alphaByteLength = block.mainAdditional.byteLength;\n        }\n        const packet = new EncodedPacket(data, block.isKeyFrame ? 'key' : 'delta', timestamp, duration, cluster.dataStartPos + blockIndex, block.data.byteLength, sideData);\n        this.packetToClusterLocation.set(packet, { cluster, blockIndex });\n        return packet;\n    }\n    /** Looks for a packet in the clusters while trying to load as few clusters as possible to retrieve it. */\n    async performClusterLookup(\n    // The cluster where we start looking\n    startCluster, \n    // This function returns the best-matching block in a given cluster\n    getMatchInCluster, \n    // The timestamp with which we can search the lookup table\n    searchTimestamp, \n    // The timestamp for which we know the correct block will not come after it\n    latestTimestamp, options) {\n        const { demuxer, segment } = this.internalTrack;\n        let currentCluster = null;\n        let bestCluster = null;\n        let bestBlockIndex = -1;\n        if (startCluster) {\n            const { blockIndex, correctBlockFound } = getMatchInCluster(startCluster);\n            if (correctBlockFound) {\n                return this.fetchPacketInCluster(startCluster, blockIndex, options);\n            }\n            if (blockIndex !== -1) {\n                bestCluster = startCluster;\n                bestBlockIndex = blockIndex;\n            }\n        }\n        // Search for a cue point; this way, we won't need to start searching from the start of the file\n        // but can jump right into the correct cluster (or at least nearby).\n        const cuePointIndex = binarySearchLessOrEqual(this.internalTrack.cuePoints, searchTimestamp, x => x.time);\n        const cuePoint = cuePointIndex !== -1\n            ? this.internalTrack.cuePoints[cuePointIndex]\n            : null;\n        // Also check the position cache\n        const positionCacheIndex = binarySearchLessOrEqual(this.internalTrack.clusterPositionCache, searchTimestamp, x => x.startTimestamp);\n        const positionCacheEntry = positionCacheIndex !== -1\n            ? this.internalTrack.clusterPositionCache[positionCacheIndex]\n            : null;\n        const lookupEntryPosition = Math.max(cuePoint?.clusterPosition ?? 0, positionCacheEntry?.elementStartPos ?? 0) || null;\n        let currentPos;\n        if (!startCluster) {\n            currentPos = lookupEntryPosition ?? segment.clusterSeekStartPos;\n        }\n        else {\n            if (lookupEntryPosition === null || startCluster.elementStartPos >= lookupEntryPosition) {\n                currentPos = startCluster.elementEndPos;\n                currentCluster = startCluster;\n            }\n            else {\n                // Use the lookup entry\n                currentPos = lookupEntryPosition;\n            }\n        }\n        while (segment.elementEndPos === null || currentPos <= segment.elementEndPos - MIN_HEADER_SIZE) {\n            if (currentCluster) {\n                const trackData = currentCluster.trackData.get(this.internalTrack.id);\n                if (trackData && trackData.startTimestamp > latestTimestamp) {\n                    // We're already past the upper bound, no need to keep searching\n                    break;\n                }\n            }\n            // Load the header\n            let slice = demuxer.reader.requestSliceRange(currentPos, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n            if (slice instanceof Promise)\n                slice = await slice;\n            if (!slice)\n                break;\n            const elementStartPos = currentPos;\n            const elementHeader = readElementHeader(slice);\n            if (!elementHeader\n                || (!LEVEL_1_EBML_IDS.includes(elementHeader.id) && elementHeader.id !== EBMLId.Void)) {\n                // There's an element here that shouldn't be here. Might be garbage. In this case, let's\n                // try and resync to the next valid element.\n                const nextPos = await resync(demuxer.reader, elementStartPos, LEVEL_1_EBML_IDS, Math.min(segment.elementEndPos ?? Infinity, elementStartPos + MAX_RESYNC_LENGTH));\n                if (nextPos) {\n                    currentPos = nextPos;\n                    continue;\n                }\n                else {\n                    break; // Resync failed\n                }\n            }\n            const id = elementHeader.id;\n            let size = elementHeader.size;\n            const dataStartPos = slice.filePos;\n            if (id === EBMLId.Cluster) {\n                currentCluster = await demuxer.readCluster(elementStartPos, segment);\n                // readCluster computes the proper size even if it's undefined in the header, so let's use that instead\n                size = currentCluster.elementEndPos - dataStartPos;\n                const { blockIndex, correctBlockFound } = getMatchInCluster(currentCluster);\n                if (correctBlockFound) {\n                    return this.fetchPacketInCluster(currentCluster, blockIndex, options);\n                }\n                if (blockIndex !== -1) {\n                    bestCluster = currentCluster;\n                    bestBlockIndex = blockIndex;\n                }\n            }\n            if (size === null) {\n                // Undefined element size (can happen in livestreamed files). In this case, we need to do some\n                // searching to determine the actual size of the element.\n                assert(id !== EBMLId.Cluster); // Undefined cluster sizes are fixed further up\n                // Search for the next element at level 0 or 1\n                const nextElementPos = await searchForNextElementId(demuxer.reader, dataStartPos, LEVEL_0_AND_1_EBML_IDS, segment.elementEndPos);\n                size = nextElementPos.pos - dataStartPos;\n            }\n            const endPos = dataStartPos + size;\n            if (segment.elementEndPos === null) {\n                // Check the next element. If it's a new segment, we know this segment ends here. The new\n                // segment is just ignored, since we're likely in a livestreamed file and thus only care about\n                // the first segment.\n                let slice = demuxer.reader.requestSliceRange(endPos, MIN_HEADER_SIZE, MAX_HEADER_SIZE);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (!slice)\n                    break;\n                const elementId = readElementId(slice);\n                if (elementId === EBMLId.Segment) {\n                    segment.elementEndPos = endPos; // We now know the segment's size\n                    break;\n                }\n            }\n            currentPos = endPos;\n        }\n        // Catch faulty cue points\n        if (cuePoint && (!bestCluster || bestCluster.elementStartPos < cuePoint.clusterPosition)) {\n            // The cue point lied to us! We found a cue point but no cluster there that satisfied the match. In this\n            // case, let's search again but using the cue point before that.\n            const previousCuePoint = this.internalTrack.cuePoints[cuePointIndex - 1];\n            assert(!previousCuePoint || previousCuePoint.time < cuePoint.time);\n            const newSearchTimestamp = previousCuePoint?.time ?? -Infinity;\n            return this.performClusterLookup(null, getMatchInCluster, newSearchTimestamp, latestTimestamp, options);\n        }\n        if (bestCluster) {\n            // If we finished looping but didn't find a perfect match, still return the best match we found\n            return this.fetchPacketInCluster(bestCluster, bestBlockIndex, options);\n        }\n        return null;\n    }\n}\nclass MatroskaVideoTrackBacking extends MatroskaTrackBacking {\n    constructor(internalTrack) {\n        super(internalTrack);\n        this.decoderConfigPromise = null;\n        this.internalTrack = internalTrack;\n    }\n    getCodec() {\n        return this.internalTrack.info.codec;\n    }\n    getCodedWidth() {\n        return this.internalTrack.info.width;\n    }\n    getCodedHeight() {\n        return this.internalTrack.info.height;\n    }\n    getRotation() {\n        return this.internalTrack.info.rotation;\n    }\n    async getColorSpace() {\n        return {\n            primaries: this.internalTrack.info.colorSpace?.primaries,\n            transfer: this.internalTrack.info.colorSpace?.transfer,\n            matrix: this.internalTrack.info.colorSpace?.matrix,\n            fullRange: this.internalTrack.info.colorSpace?.fullRange,\n        };\n    }\n    async canBeTransparent() {\n        return this.internalTrack.info.alphaMode;\n    }\n    async getDecoderConfig() {\n        if (!this.internalTrack.info.codec) {\n            return null;\n        }\n        return this.decoderConfigPromise ??= (async () => {\n            let firstPacket = null;\n            const needsPacketForAdditionalInfo = this.internalTrack.info.codec === 'vp9'\n                || this.internalTrack.info.codec === 'av1'\n                // Packets are in Annex B format:\n                || (this.internalTrack.info.codec === 'avc' && !this.internalTrack.info.codecDescription)\n                // Packets are in Annex B format:\n                || (this.internalTrack.info.codec === 'hevc' && !this.internalTrack.info.codecDescription);\n            if (needsPacketForAdditionalInfo) {\n                firstPacket = await this.getFirstPacket({});\n            }\n            return {\n                codec: extractVideoCodecString({\n                    width: this.internalTrack.info.width,\n                    height: this.internalTrack.info.height,\n                    codec: this.internalTrack.info.codec,\n                    codecDescription: this.internalTrack.info.codecDescription,\n                    colorSpace: this.internalTrack.info.colorSpace,\n                    avcType: 1, // We don't know better (or do we?) so just assume 'avc1'\n                    avcCodecInfo: this.internalTrack.info.codec === 'avc' && firstPacket\n                        ? extractAvcDecoderConfigurationRecord(firstPacket.data)\n                        : null,\n                    hevcCodecInfo: this.internalTrack.info.codec === 'hevc' && firstPacket\n                        ? extractHevcDecoderConfigurationRecord(firstPacket.data)\n                        : null,\n                    vp9CodecInfo: this.internalTrack.info.codec === 'vp9' && firstPacket\n                        ? extractVp9CodecInfoFromPacket(firstPacket.data)\n                        : null,\n                    av1CodecInfo: this.internalTrack.info.codec === 'av1' && firstPacket\n                        ? extractAv1CodecInfoFromPacket(firstPacket.data)\n                        : null,\n                }),\n                codedWidth: this.internalTrack.info.width,\n                codedHeight: this.internalTrack.info.height,\n                description: this.internalTrack.info.codecDescription ?? undefined,\n                colorSpace: this.internalTrack.info.colorSpace ?? undefined,\n            };\n        })();\n    }\n}\nclass MatroskaAudioTrackBacking extends MatroskaTrackBacking {\n    constructor(internalTrack) {\n        super(internalTrack);\n        this.decoderConfig = null;\n        this.internalTrack = internalTrack;\n    }\n    getCodec() {\n        return this.internalTrack.info.codec;\n    }\n    getNumberOfChannels() {\n        return this.internalTrack.info.numberOfChannels;\n    }\n    getSampleRate() {\n        return this.internalTrack.info.sampleRate;\n    }\n    async getDecoderConfig() {\n        if (!this.internalTrack.info.codec) {\n            return null;\n        }\n        return this.decoderConfig ??= {\n            codec: extractAudioCodecString({\n                codec: this.internalTrack.info.codec,\n                codecDescription: this.internalTrack.info.codecDescription,\n                aacCodecInfo: this.internalTrack.info.aacCodecInfo,\n            }),\n            numberOfChannels: this.internalTrack.info.numberOfChannels,\n            sampleRate: this.internalTrack.info.sampleRate,\n            description: this.internalTrack.info.codecDescription ?? undefined,\n        };\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport const FRAME_HEADER_SIZE = 4;\nexport const SAMPLING_RATES = [44100, 48000, 32000];\nexport const KILOBIT_RATES = [\n    // lowSamplingFrequency === 0\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // layer = 0\n    -1, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1, // layer 1\n    -1, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1, // layer = 2\n    -1, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1, // layer = 3\n    // lowSamplingFrequency === 1\n    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // layer = 0\n    -1, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1, // layer = 1\n    -1, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1, // layer = 2\n    -1, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, -1, // layer = 3\n];\n/** 'Xing' */\nexport const XING = 0x58696e67;\n/** 'Info' */\nexport const INFO = 0x496e666f;\nexport const computeMp3FrameSize = (lowSamplingFrequency, layer, bitrate, sampleRate, padding) => {\n    if (layer === 0) {\n        return 0; // Not expected that this is hit\n    }\n    else if (layer === 1) {\n        return Math.floor(144 * bitrate / (sampleRate << lowSamplingFrequency)) + padding;\n    }\n    else if (layer === 2) {\n        return Math.floor(144 * bitrate / sampleRate) + padding;\n    }\n    else { // layer === 3\n        return (Math.floor(12 * bitrate / sampleRate) + padding) * 4;\n    }\n};\nexport const getXingOffset = (mpegVersionId, channel) => {\n    return mpegVersionId === 3\n        ? (channel === 3 ? 21 : 36)\n        : (channel === 3 ? 13 : 21);\n};\nexport const readFrameHeader = (word, remainingBytes) => {\n    const firstByte = word >>> 24;\n    const secondByte = (word >>> 16) & 0xff;\n    const thirdByte = (word >>> 8) & 0xff;\n    const fourthByte = word & 0xff;\n    if (firstByte !== 0xff && secondByte !== 0xff && thirdByte !== 0xff && fourthByte !== 0xff) {\n        return {\n            header: null,\n            bytesAdvanced: 4,\n        };\n    }\n    if (firstByte !== 0xff) {\n        return { header: null, bytesAdvanced: 1 };\n    }\n    if ((secondByte & 0xe0) !== 0xe0) {\n        return { header: null, bytesAdvanced: 1 };\n    }\n    let lowSamplingFrequency = 0;\n    let mpeg25 = 0;\n    if (secondByte & (1 << 4)) {\n        lowSamplingFrequency = (secondByte & (1 << 3)) ? 0 : 1;\n    }\n    else {\n        lowSamplingFrequency = 1;\n        mpeg25 = 1;\n    }\n    const mpegVersionId = (secondByte >> 3) & 0x3;\n    const layer = (secondByte >> 1) & 0x3;\n    const bitrateIndex = (thirdByte >> 4) & 0xf;\n    const frequencyIndex = ((thirdByte >> 2) & 0x3) % 3;\n    const padding = (thirdByte >> 1) & 0x1;\n    const channel = (fourthByte >> 6) & 0x3;\n    const modeExtension = (fourthByte >> 4) & 0x3;\n    const copyright = (fourthByte >> 3) & 0x1;\n    const original = (fourthByte >> 2) & 0x1;\n    const emphasis = fourthByte & 0x3;\n    const kilobitRate = KILOBIT_RATES[lowSamplingFrequency * 16 * 4 + layer * 16 + bitrateIndex];\n    if (kilobitRate === -1) {\n        return { header: null, bytesAdvanced: 1 };\n    }\n    const bitrate = kilobitRate * 1000;\n    const sampleRate = SAMPLING_RATES[frequencyIndex] >> (lowSamplingFrequency + mpeg25);\n    const frameLength = computeMp3FrameSize(lowSamplingFrequency, layer, bitrate, sampleRate, padding);\n    if (remainingBytes !== null && remainingBytes < frameLength) {\n        // The frame doesn't fit into the rest of the file\n        return { header: null, bytesAdvanced: 1 };\n    }\n    let audioSamplesInFrame;\n    if (mpegVersionId === 3) {\n        audioSamplesInFrame = layer === 3 ? 384 : 1152;\n    }\n    else {\n        if (layer === 3) {\n            audioSamplesInFrame = 384;\n        }\n        else if (layer === 2) {\n            audioSamplesInFrame = 1152;\n        }\n        else {\n            audioSamplesInFrame = 576;\n        }\n    }\n    return {\n        header: {\n            totalSize: frameLength,\n            mpegVersionId,\n            layer,\n            bitrate,\n            frequencyIndex,\n            sampleRate,\n            channel,\n            modeExtension,\n            copyright,\n            original,\n            emphasis,\n            audioSamplesInFrame,\n        },\n        bytesAdvanced: 1,\n    };\n};\nexport const encodeSynchsafe = (unsynchsafed) => {\n    let mask = 0x7f;\n    let synchsafed = 0;\n    let unsynchsafedRest = unsynchsafed;\n    while ((mask ^ 0x7fffffff) !== 0) {\n        synchsafed = unsynchsafedRest & ~mask;\n        synchsafed <<= 1;\n        synchsafed |= unsynchsafedRest & mask;\n        mask = ((mask + 1) << 8) - 1;\n        unsynchsafedRest = synchsafed;\n    }\n    return synchsafed;\n};\nexport const decodeSynchsafe = (synchsafed) => {\n    let mask = 0x7f000000;\n    let unsynchsafed = 0;\n    while (mask !== 0) {\n        unsynchsafed >>= 1;\n        unsynchsafed |= synchsafed & mask;\n        mask >>= 8;\n    }\n    return unsynchsafed;\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { decodeSynchsafe, encodeSynchsafe } from '../shared/mp3-misc.js';\nimport { coalesceIndex, textDecoder, textEncoder, isIso88591Compatible, assertNever, keyValueIterator, toDataView, } from './misc.js';\nimport { readAscii, readBytes, readU32Be, readU8 } from './reader.js';\nexport var Id3V2HeaderFlags;\n(function (Id3V2HeaderFlags) {\n    Id3V2HeaderFlags[Id3V2HeaderFlags[\"Unsynchronisation\"] = 128] = \"Unsynchronisation\";\n    Id3V2HeaderFlags[Id3V2HeaderFlags[\"ExtendedHeader\"] = 64] = \"ExtendedHeader\";\n    Id3V2HeaderFlags[Id3V2HeaderFlags[\"ExperimentalIndicator\"] = 32] = \"ExperimentalIndicator\";\n    Id3V2HeaderFlags[Id3V2HeaderFlags[\"Footer\"] = 16] = \"Footer\";\n})(Id3V2HeaderFlags || (Id3V2HeaderFlags = {}));\nexport var Id3V2TextEncoding;\n(function (Id3V2TextEncoding) {\n    Id3V2TextEncoding[Id3V2TextEncoding[\"ISO_8859_1\"] = 0] = \"ISO_8859_1\";\n    Id3V2TextEncoding[Id3V2TextEncoding[\"UTF_16_WITH_BOM\"] = 1] = \"UTF_16_WITH_BOM\";\n    Id3V2TextEncoding[Id3V2TextEncoding[\"UTF_16_BE_NO_BOM\"] = 2] = \"UTF_16_BE_NO_BOM\";\n    Id3V2TextEncoding[Id3V2TextEncoding[\"UTF_8\"] = 3] = \"UTF_8\";\n})(Id3V2TextEncoding || (Id3V2TextEncoding = {}));\nexport const ID3_V1_TAG_SIZE = 128;\nexport const ID3_V2_HEADER_SIZE = 10;\nexport const ID3_V1_GENRES = [\n    'Blues', 'Classic rock', 'Country', 'Dance', 'Disco', 'Funk', 'Grunge', 'Hip-hop', 'Jazz',\n    'Metal', 'New age', 'Oldies', 'Other', 'Pop', 'Rhythm and blues', 'Rap', 'Reggae', 'Rock',\n    'Techno', 'Industrial', 'Alternative', 'Ska', 'Death metal', 'Pranks', 'Soundtrack',\n    'Euro-techno', 'Ambient', 'Trip-hop', 'Vocal', 'Jazz & funk', 'Fusion', 'Trance', 'Classical',\n    'Instrumental', 'Acid', 'House', 'Game', 'Sound clip', 'Gospel', 'Noise', 'Alternative rock',\n    'Bass', 'Soul', 'Punk', 'Space', 'Meditative', 'Instrumental pop', 'Instrumental rock',\n    'Ethnic', 'Gothic', 'Darkwave', 'Techno-industrial', 'Electronic', 'Pop-folk', 'Eurodance',\n    'Dream', 'Southern rock', 'Comedy', 'Cult', 'Gangsta', 'Top 40', 'Christian rap', 'Pop/funk',\n    'Jungle music', 'Native US', 'Cabaret', 'New wave', 'Psychedelic', 'Rave', 'Showtunes',\n    'Trailer', 'Lo-fi', 'Tribal', 'Acid punk', 'Acid jazz', 'Polka', 'Retro', 'Musical',\n    'Rock \\'n\\' roll', 'Hard rock', 'Folk', 'Folk rock', 'National folk', 'Swing', 'Fast fusion',\n    'Bebop', 'Latin', 'Revival', 'Celtic', 'Bluegrass', 'Avantgarde', 'Gothic rock',\n    'Progressive rock', 'Psychedelic rock', 'Symphonic rock', 'Slow rock', 'Big band', 'Chorus',\n    'Easy listening', 'Acoustic', 'Humour', 'Speech', 'Chanson', 'Opera', 'Chamber music',\n    'Sonata', 'Symphony', 'Booty bass', 'Primus', 'Porn groove', 'Satire', 'Slow jam', 'Club',\n    'Tango', 'Samba', 'Folklore', 'Ballad', 'Power ballad', 'Rhythmic Soul', 'Freestyle', 'Duet',\n    'Punk rock', 'Drum solo', 'A cappella', 'Euro-house', 'Dance hall', 'Goa music', 'Drum & bass',\n    'Club-house', 'Hardcore techno', 'Terror', 'Indie', 'Britpop', 'Negerpunk', 'Polsk punk',\n    'Beat', 'Christian gangsta rap', 'Heavy metal', 'Black metal', 'Crossover',\n    'Contemporary Christian', 'Christian rock', 'Merengue', 'Salsa', 'Thrash metal', 'Anime',\n    'Jpop', 'Synthpop', 'Christmas', 'Art rock', 'Baroque', 'Bhangra', 'Big beat', 'Breakbeat',\n    'Chillout', 'Downtempo', 'Dub', 'EBM', 'Eclectic', 'Electro', 'Electroclash', 'Emo',\n    'Experimental', 'Garage', 'Global', 'IDM', 'Illbient', 'Industro-Goth', 'Jam Band',\n    'Krautrock', 'Leftfield', 'Lounge', 'Math rock', 'New romantic', 'Nu-breakz', 'Post-punk',\n    'Post-rock', 'Psytrance', 'Shoegaze', 'Space rock', 'Trop rock', 'World music', 'Neoclassical',\n    'Audiobook', 'Audio theatre', 'Neue Deutsche Welle', 'Podcast', 'Indie rock', 'G-Funk',\n    'Dubstep', 'Garage rock', 'Psybient',\n];\nexport const parseId3V1Tag = (slice, tags) => {\n    const startPos = slice.filePos;\n    tags.raw ??= {};\n    tags.raw['TAG'] ??= readBytes(slice, ID3_V1_TAG_SIZE - 3); // Dump the whole tag into the raw metadata\n    slice.filePos = startPos;\n    const title = readId3V1String(slice, 30);\n    if (title)\n        tags.title ??= title;\n    const artist = readId3V1String(slice, 30);\n    if (artist)\n        tags.artist ??= artist;\n    const album = readId3V1String(slice, 30);\n    if (album)\n        tags.album ??= album;\n    const yearText = readId3V1String(slice, 4);\n    const year = Number.parseInt(yearText, 10);\n    if (Number.isInteger(year) && year > 0) {\n        tags.date ??= new Date(year, 0, 1);\n    }\n    const commentBytes = readBytes(slice, 30);\n    let comment;\n    // Check for the ID3v1.1 track number format:\n    // The 29th byte (index 28) is a null terminator, and the 30th byte is the track number.\n    if (commentBytes[28] === 0 && commentBytes[29] !== 0) {\n        const trackNum = commentBytes[29];\n        if (trackNum > 0) {\n            tags.trackNumber ??= trackNum;\n        }\n        slice.skip(-30);\n        comment = readId3V1String(slice, 28);\n        slice.skip(2);\n    }\n    else {\n        slice.skip(-30);\n        comment = readId3V1String(slice, 30);\n    }\n    if (comment)\n        tags.comment ??= comment;\n    const genreIndex = readU8(slice);\n    if (genreIndex < ID3_V1_GENRES.length) {\n        tags.genre ??= ID3_V1_GENRES[genreIndex];\n    }\n};\nexport const readId3V1String = (slice, length) => {\n    const bytes = readBytes(slice, length);\n    const endIndex = coalesceIndex(bytes.indexOf(0), bytes.length);\n    const relevantBytes = bytes.subarray(0, endIndex);\n    // Decode as ISO-8859-1\n    let str = '';\n    for (let i = 0; i < relevantBytes.length; i++) {\n        str += String.fromCharCode(relevantBytes[i]);\n    }\n    return str.trimEnd(); // String also may be padded with spaces\n};\nexport const readId3V2Header = (slice) => {\n    const startPos = slice.filePos;\n    const tag = readAscii(slice, 3);\n    const majorVersion = readU8(slice);\n    const revision = readU8(slice);\n    const flags = readU8(slice);\n    const sizeRaw = readU32Be(slice);\n    if (tag !== 'ID3' || majorVersion === 0xff || revision === 0xff || (sizeRaw & 0x80808080) !== 0) {\n        slice.filePos = startPos;\n        return null;\n    }\n    const size = decodeSynchsafe(sizeRaw);\n    return { majorVersion, revision, flags, size };\n};\nexport const parseId3V2Tag = (slice, header, tags) => {\n    // https://id3.org/id3v2.3.0\n    if (![2, 3, 4].includes(header.majorVersion)) {\n        console.warn(`Unsupported ID3v2 major version: ${header.majorVersion}`);\n        return;\n    }\n    const bytes = readBytes(slice, header.size);\n    const reader = new Id3V2Reader(header, bytes);\n    if (header.flags & Id3V2HeaderFlags.Footer) {\n        reader.removeFooter();\n    }\n    if ((header.flags & Id3V2HeaderFlags.Unsynchronisation) && header.majorVersion === 3) {\n        reader.ununsynchronizeAll();\n    }\n    if (header.flags & Id3V2HeaderFlags.ExtendedHeader) {\n        const extendedHeaderSize = reader.readU32();\n        if (header.majorVersion === 3) {\n            reader.pos += extendedHeaderSize; // The extended header size excludes itself\n        }\n        else {\n            reader.pos += extendedHeaderSize - 4; // The extended header size includes itself\n        }\n    }\n    while (reader.pos <= reader.bytes.length - reader.frameHeaderSize()) {\n        const frame = reader.readId3V2Frame();\n        if (!frame) {\n            break;\n        }\n        const frameStartPos = reader.pos;\n        const frameEndPos = reader.pos + frame.size;\n        let frameEncrypted = false;\n        let frameCompressed = false;\n        let frameUnsynchronized = false;\n        if (header.majorVersion === 3) {\n            frameEncrypted = !!(frame.flags & (1 << 6));\n            frameCompressed = !!(frame.flags & (1 << 7));\n        }\n        else if (header.majorVersion === 4) {\n            frameEncrypted = !!(frame.flags & (1 << 2));\n            frameCompressed = !!(frame.flags & (1 << 3));\n            frameUnsynchronized = !!(frame.flags & (1 << 1))\n                || !!(header.flags & Id3V2HeaderFlags.Unsynchronisation);\n        }\n        if (frameEncrypted) {\n            console.warn(`Skipping encrypted ID3v2 frame ${frame.id}`);\n            reader.pos = frameEndPos;\n            continue;\n        }\n        if (frameCompressed) {\n            console.warn(`Skipping compressed ID3v2 frame ${frame.id}`); // Maybe someday? Idk\n            reader.pos = frameEndPos;\n            continue;\n        }\n        if (frameUnsynchronized) {\n            reader.ununsynchronizeRegion(reader.pos, frameEndPos);\n        }\n        tags.raw ??= {};\n        if (frame.id[0] === 'T') {\n            // It's a text frame, let's decode as text\n            tags.raw[frame.id] ??= reader.readId3V2EncodingAndText(frameEndPos);\n        }\n        else {\n            // For the others, let's just get the bytes\n            tags.raw[frame.id] ??= reader.readBytes(frame.size);\n        }\n        reader.pos = frameStartPos;\n        switch (frame.id) {\n            case 'TIT2':\n            case 'TT2':\n                {\n                    tags.title ??= reader.readId3V2EncodingAndText(frameEndPos);\n                }\n                ;\n                break;\n            case 'TIT3':\n            case 'TT3':\n                {\n                    tags.description ??= reader.readId3V2EncodingAndText(frameEndPos);\n                }\n                ;\n                break;\n            case 'TPE1':\n            case 'TP1':\n                {\n                    tags.artist ??= reader.readId3V2EncodingAndText(frameEndPos);\n                }\n                ;\n                break;\n            case 'TALB':\n            case 'TAL':\n                {\n                    tags.album ??= reader.readId3V2EncodingAndText(frameEndPos);\n                }\n                ;\n                break;\n            case 'TPE2':\n            case 'TP2':\n                {\n                    tags.albumArtist ??= reader.readId3V2EncodingAndText(frameEndPos);\n                }\n                ;\n                break;\n            case 'TRCK':\n            case 'TRK':\n                {\n                    const trackText = reader.readId3V2EncodingAndText(frameEndPos);\n                    const parts = trackText.split('/');\n                    const trackNum = Number.parseInt(parts[0], 10);\n                    const tracksTotal = parts[1] && Number.parseInt(parts[1], 10);\n                    if (Number.isInteger(trackNum) && trackNum > 0) {\n                        tags.trackNumber ??= trackNum;\n                    }\n                    if (tracksTotal && Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                        tags.tracksTotal ??= tracksTotal;\n                    }\n                }\n                ;\n                break;\n            case 'TPOS':\n            case 'TPA':\n                {\n                    const discText = reader.readId3V2EncodingAndText(frameEndPos);\n                    const parts = discText.split('/');\n                    const discNum = Number.parseInt(parts[0], 10);\n                    const discsTotal = parts[1] && Number.parseInt(parts[1], 10);\n                    if (Number.isInteger(discNum) && discNum > 0) {\n                        tags.discNumber ??= discNum;\n                    }\n                    if (discsTotal && Number.isInteger(discsTotal) && discsTotal > 0) {\n                        tags.discsTotal ??= discsTotal;\n                    }\n                }\n                ;\n                break;\n            case 'TCON':\n            case 'TCO':\n                {\n                    const genreText = reader.readId3V2EncodingAndText(frameEndPos);\n                    let match = /^\\((\\d+)\\)/.exec(genreText);\n                    if (match) {\n                        const genreNumber = Number.parseInt(match[1]);\n                        if (ID3_V1_GENRES[genreNumber] !== undefined) {\n                            tags.genre ??= ID3_V1_GENRES[genreNumber];\n                            break;\n                        }\n                    }\n                    match = /^\\d+$/.exec(genreText);\n                    if (match) {\n                        const genreNumber = Number.parseInt(match[0]);\n                        if (ID3_V1_GENRES[genreNumber] !== undefined) {\n                            tags.genre ??= ID3_V1_GENRES[genreNumber];\n                            break;\n                        }\n                    }\n                    tags.genre ??= genreText;\n                }\n                ;\n                break;\n            case 'TDRC':\n            case 'TDAT':\n                {\n                    const dateText = reader.readId3V2EncodingAndText(frameEndPos);\n                    const date = new Date(dateText);\n                    if (!Number.isNaN(date.getTime())) {\n                        tags.date ??= date;\n                    }\n                }\n                ;\n                break;\n            case 'TYER':\n            case 'TYE':\n                {\n                    const yearText = reader.readId3V2EncodingAndText(frameEndPos);\n                    const year = Number.parseInt(yearText, 10);\n                    if (Number.isInteger(year)) {\n                        tags.date ??= new Date(year, 0, 1);\n                    }\n                }\n                ;\n                break;\n            case 'USLT':\n            case 'ULT':\n                {\n                    const encoding = reader.readU8();\n                    reader.pos += 3; // Skip language\n                    reader.readId3V2Text(encoding, frameEndPos); // Short content description\n                    tags.lyrics ??= reader.readId3V2Text(encoding, frameEndPos);\n                }\n                ;\n                break;\n            case 'COMM':\n            case 'COM':\n                {\n                    const encoding = reader.readU8();\n                    reader.pos += 3; // Skip language\n                    reader.readId3V2Text(encoding, frameEndPos); // Short content description\n                    tags.comment ??= reader.readId3V2Text(encoding, frameEndPos);\n                }\n                ;\n                break;\n            case 'APIC':\n            case 'PIC':\n                {\n                    const encoding = reader.readId3V2TextEncoding();\n                    let mimeType;\n                    if (header.majorVersion === 2) {\n                        const imageFormat = reader.readAscii(3);\n                        mimeType = imageFormat === 'PNG'\n                            ? 'image/png'\n                            : imageFormat === 'JPG'\n                                ? 'image/jpeg'\n                                : 'image/*';\n                    }\n                    else {\n                        mimeType = reader.readId3V2Text(encoding, frameEndPos);\n                    }\n                    const pictureType = reader.readU8();\n                    const description = reader.readId3V2Text(encoding, frameEndPos).trimEnd(); // Trim ending spaces\n                    const imageDataSize = frameEndPos - reader.pos;\n                    if (imageDataSize >= 0) {\n                        const imageData = reader.readBytes(imageDataSize);\n                        if (!tags.images)\n                            tags.images = [];\n                        tags.images.push({\n                            data: imageData,\n                            mimeType,\n                            kind: pictureType === 3\n                                ? 'coverFront'\n                                : pictureType === 4\n                                    ? 'coverBack'\n                                    : 'unknown',\n                            description,\n                        });\n                    }\n                }\n                ;\n                break;\n            default:\n                {\n                    reader.pos += frame.size;\n                }\n                ;\n                break;\n        }\n        reader.pos = frameEndPos;\n    }\n};\n// https://id3.org/id3v2.3.0\nexport class Id3V2Reader {\n    constructor(header, bytes) {\n        this.header = header;\n        this.bytes = bytes;\n        this.pos = 0;\n        this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    }\n    frameHeaderSize() {\n        return this.header.majorVersion === 2 ? 6 : 10;\n    }\n    ununsynchronizeAll() {\n        const newBytes = [];\n        for (let i = 0; i < this.bytes.length; i++) {\n            const value1 = this.bytes[i];\n            newBytes.push(value1);\n            if (value1 === 0xff && i !== this.bytes.length - 1) {\n                const value2 = this.bytes[i];\n                if (value2 === 0x00) {\n                    i++;\n                }\n            }\n        }\n        this.bytes = new Uint8Array(newBytes);\n        this.view = new DataView(this.bytes.buffer);\n    }\n    ununsynchronizeRegion(start, end) {\n        const newBytes = [];\n        for (let i = start; i < end; i++) {\n            const value1 = this.bytes[i];\n            newBytes.push(value1);\n            if (value1 === 0xff && i !== end - 1) {\n                const value2 = this.bytes[i + 1];\n                if (value2 === 0x00) {\n                    i++;\n                }\n            }\n        }\n        const before = this.bytes.subarray(0, start);\n        const after = this.bytes.subarray(end);\n        this.bytes = new Uint8Array(before.length + newBytes.length + after.length);\n        this.bytes.set(before, 0);\n        this.bytes.set(newBytes, before.length);\n        this.bytes.set(after, before.length + newBytes.length);\n        this.view = new DataView(this.bytes.buffer);\n    }\n    removeFooter() {\n        this.bytes = this.bytes.subarray(0, this.bytes.length - ID3_V2_HEADER_SIZE);\n        this.view = new DataView(this.bytes.buffer);\n    }\n    readBytes(length) {\n        const slice = this.bytes.subarray(this.pos, this.pos + length);\n        this.pos += length;\n        return slice;\n    }\n    readU8() {\n        const value = this.view.getUint8(this.pos);\n        this.pos += 1;\n        return value;\n    }\n    readU16() {\n        const value = this.view.getUint16(this.pos, false);\n        this.pos += 2;\n        return value;\n    }\n    readU24() {\n        const high = this.view.getUint16(this.pos, false);\n        const low = this.view.getUint8(this.pos + 1);\n        this.pos += 3;\n        return high * 0x100 + low;\n    }\n    readU32() {\n        const value = this.view.getUint32(this.pos, false);\n        this.pos += 4;\n        return value;\n    }\n    readAscii(length) {\n        let str = '';\n        for (let i = 0; i < length; i++) {\n            str += String.fromCharCode(this.view.getUint8(this.pos + i));\n        }\n        this.pos += length;\n        return str;\n    }\n    readId3V2Frame() {\n        if (this.header.majorVersion === 2) {\n            const id = this.readAscii(3);\n            if (id === '\\x00\\x00\\x00') {\n                return null;\n            }\n            const size = this.readU24();\n            return { id, size, flags: 0 };\n        }\n        else {\n            const id = this.readAscii(4);\n            if (id === '\\x00\\x00\\x00\\x00') {\n                // We've landed in the padding section\n                return null;\n            }\n            const sizeRaw = this.readU32();\n            let size = this.header.majorVersion === 4\n                ? decodeSynchsafe(sizeRaw)\n                : sizeRaw;\n            const flags = this.readU16();\n            const headerEndPos = this.pos;\n            // Some files may have incorrectly synchsafed/unsynchsafed sizes. To validate which interpretation is valid,\n            // we validate a size by skipping ahead and seeing if we land at a valid frame header (or at the end of the\n            // tag.\n            const isSizeValid = (size) => {\n                const nextPos = this.pos + size;\n                if (nextPos > this.bytes.length) {\n                    return false;\n                }\n                if (nextPos <= this.bytes.length - this.frameHeaderSize()) {\n                    this.pos += size;\n                    const nextId = this.readAscii(4);\n                    if (nextId !== '\\x00\\x00\\x00\\x00' && !/[0-9A-Z]{4}/.test(nextId)) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            if (!isSizeValid(size)) {\n                // Flip the synchsafing, and try if this one makes more sense\n                const otherSize = this.header.majorVersion === 4\n                    ? sizeRaw\n                    : decodeSynchsafe(sizeRaw);\n                if (isSizeValid(otherSize)) {\n                    size = otherSize;\n                }\n            }\n            this.pos = headerEndPos;\n            return { id, size, flags };\n        }\n    }\n    readId3V2TextEncoding() {\n        const number = this.readU8();\n        if (number > 3) {\n            throw new Error(`Unsupported text encoding: ${number}`);\n        }\n        return number;\n    }\n    readId3V2Text(encoding, until) {\n        const startPos = this.pos;\n        const data = this.readBytes(until - this.pos);\n        switch (encoding) {\n            case Id3V2TextEncoding.ISO_8859_1: {\n                let str = '';\n                for (let i = 0; i < data.length; i++) {\n                    const value = data[i];\n                    if (value === 0) {\n                        this.pos = startPos + i + 1;\n                        break;\n                    }\n                    str += String.fromCharCode(value);\n                }\n                return str;\n            }\n            case Id3V2TextEncoding.UTF_16_WITH_BOM: {\n                if (data[0] === 0xff && data[1] === 0xfe) {\n                    const decoder = new TextDecoder('utf-16le');\n                    const endIndex = coalesceIndex(data.findIndex((x, i) => x === 0 && data[i + 1] === 0 && i % 2 === 0), data.length);\n                    this.pos = startPos + Math.min(endIndex + 2, data.length);\n                    return decoder.decode(data.subarray(2, endIndex));\n                }\n                else if (data[0] === 0xfe && data[1] === 0xff) {\n                    const decoder = new TextDecoder('utf-16be');\n                    const endIndex = coalesceIndex(data.findIndex((x, i) => x === 0 && data[i + 1] === 0 && i % 2 === 0), data.length);\n                    this.pos = startPos + Math.min(endIndex + 2, data.length);\n                    return decoder.decode(data.subarray(2, endIndex));\n                }\n                else {\n                    // Treat it like UTF-8, some files do this\n                    const endIndex = coalesceIndex(data.findIndex(x => x === 0), data.length);\n                    this.pos = startPos + Math.min(endIndex + 1, data.length);\n                    return textDecoder.decode(data.subarray(0, endIndex));\n                }\n            }\n            case Id3V2TextEncoding.UTF_16_BE_NO_BOM: {\n                const decoder = new TextDecoder('utf-16be');\n                const endIndex = coalesceIndex(data.findIndex((x, i) => x === 0 && data[i + 1] === 0 && i % 2 === 0), data.length);\n                this.pos = startPos + Math.min(endIndex + 2, data.length);\n                return decoder.decode(data.subarray(0, endIndex));\n            }\n            case Id3V2TextEncoding.UTF_8: {\n                const endIndex = coalesceIndex(data.findIndex(x => x === 0), data.length);\n                this.pos = startPos + Math.min(endIndex + 1, data.length);\n                return textDecoder.decode(data.subarray(0, endIndex));\n            }\n        }\n    }\n    readId3V2EncodingAndText(until) {\n        if (this.pos >= until) {\n            return '';\n        }\n        const encoding = this.readId3V2TextEncoding();\n        return this.readId3V2Text(encoding, until);\n    }\n}\nexport class Id3V2Writer {\n    constructor(writer) {\n        this.helper = new Uint8Array(8);\n        this.helperView = toDataView(this.helper);\n        this.writer = writer;\n    }\n    writeId3V2Tag(metadata) {\n        const tagStartPos = this.writer.getPos();\n        // Write ID3v2.4 header\n        this.writeAscii('ID3');\n        this.writeU8(0x04); // Version 2.4\n        this.writeU8(0x00); // Revision 0\n        this.writeU8(0x00); // Flags\n        this.writeSynchsafeU32(0); // Size placeholder\n        const framesStartPos = this.writer.getPos();\n        const writtenTags = new Set();\n        // Write all metadata frames\n        for (const { key, value } of keyValueIterator(metadata)) {\n            switch (key) {\n                case 'title':\n                    {\n                        this.writeId3V2TextFrame('TIT2', value);\n                        writtenTags.add('TIT2');\n                    }\n                    ;\n                    break;\n                case 'description':\n                    {\n                        this.writeId3V2TextFrame('TIT3', value);\n                        writtenTags.add('TIT3');\n                    }\n                    ;\n                    break;\n                case 'artist':\n                    {\n                        this.writeId3V2TextFrame('TPE1', value);\n                        writtenTags.add('TPE1');\n                    }\n                    ;\n                    break;\n                case 'album':\n                    {\n                        this.writeId3V2TextFrame('TALB', value);\n                        writtenTags.add('TALB');\n                    }\n                    ;\n                    break;\n                case 'albumArtist':\n                    {\n                        this.writeId3V2TextFrame('TPE2', value);\n                        writtenTags.add('TPE2');\n                    }\n                    ;\n                    break;\n                case 'trackNumber':\n                    {\n                        const string = metadata.tracksTotal !== undefined\n                            ? `${value}/${metadata.tracksTotal}`\n                            : value.toString();\n                        this.writeId3V2TextFrame('TRCK', string);\n                        writtenTags.add('TRCK');\n                    }\n                    ;\n                    break;\n                case 'discNumber':\n                    {\n                        const string = metadata.discsTotal !== undefined\n                            ? `${value}/${metadata.discsTotal}`\n                            : value.toString();\n                        this.writeId3V2TextFrame('TPOS', string);\n                        writtenTags.add('TPOS');\n                    }\n                    ;\n                    break;\n                case 'genre':\n                    {\n                        this.writeId3V2TextFrame('TCON', value);\n                        writtenTags.add('TCON');\n                    }\n                    ;\n                    break;\n                case 'date':\n                    {\n                        this.writeId3V2TextFrame('TDRC', value.toISOString().slice(0, 10));\n                        writtenTags.add('TDRC');\n                    }\n                    ;\n                    break;\n                case 'lyrics':\n                    {\n                        this.writeId3V2LyricsFrame(value);\n                        writtenTags.add('USLT');\n                    }\n                    ;\n                    break;\n                case 'comment':\n                    {\n                        this.writeId3V2CommentFrame(value);\n                        writtenTags.add('COMM');\n                    }\n                    ;\n                    break;\n                case 'images':\n                    {\n                        const pictureTypeMap = { coverFront: 0x03, coverBack: 0x04, unknown: 0x00 };\n                        for (const image of value) {\n                            const pictureType = pictureTypeMap[image.kind] ?? 0x00;\n                            const description = image.description ?? '';\n                            this.writeId3V2ApicFrame(image.mimeType, pictureType, description, image.data);\n                        }\n                    }\n                    ;\n                    break;\n                case 'tracksTotal':\n                case 'discsTotal':\n                    {\n                        // Handled with trackNumber and discNumber respectively\n                    }\n                    ;\n                    break;\n                case 'raw':\n                    {\n                        // Handled later\n                    }\n                    ;\n                    break;\n                default: {\n                    assertNever(key);\n                }\n            }\n        }\n        if (metadata.raw) {\n            for (const key in metadata.raw) {\n                const value = metadata.raw[key];\n                if (value == null || key.length !== 4 || writtenTags.has(key)) {\n                    continue;\n                }\n                let bytes;\n                if (typeof value === 'string') {\n                    const encoded = textEncoder.encode(value);\n                    bytes = new Uint8Array(encoded.byteLength + 2);\n                    bytes[0] = Id3V2TextEncoding.UTF_8;\n                    bytes.set(encoded, 1);\n                    // Last byte is the null terminator\n                }\n                else if (value instanceof Uint8Array) {\n                    bytes = value;\n                }\n                else {\n                    continue;\n                }\n                this.writeAscii(key);\n                this.writeSynchsafeU32(bytes.byteLength);\n                this.writeU16(0x0000);\n                this.writer.write(bytes);\n            }\n        }\n        const framesEndPos = this.writer.getPos();\n        const framesSize = framesEndPos - framesStartPos;\n        // Update the size field in the header (synchsafe)\n        this.writer.seek(tagStartPos + 6); // Skip 'ID3' + version + revision + flags\n        this.writeSynchsafeU32(framesSize);\n        this.writer.seek(framesEndPos);\n        return framesSize + 10; // +10 for the header size\n    }\n    writeU8(value) {\n        this.helper[0] = value;\n        this.writer.write(this.helper.subarray(0, 1));\n    }\n    writeU16(value) {\n        this.helperView.setUint16(0, value, false);\n        this.writer.write(this.helper.subarray(0, 2));\n    }\n    writeU32(value) {\n        this.helperView.setUint32(0, value, false);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeAscii(text) {\n        for (let i = 0; i < text.length; i++) {\n            this.helper[i] = text.charCodeAt(i);\n        }\n        this.writer.write(this.helper.subarray(0, text.length));\n    }\n    writeSynchsafeU32(value) {\n        this.writeU32(encodeSynchsafe(value));\n    }\n    writeIsoString(text) {\n        const bytes = new Uint8Array(text.length + 1);\n        for (let i = 0; i < text.length; i++) {\n            bytes[i] = text.charCodeAt(i);\n        }\n        bytes[text.length] = 0x00;\n        this.writer.write(bytes);\n    }\n    writeUtf8String(text) {\n        const utf8Data = textEncoder.encode(text);\n        this.writer.write(utf8Data);\n        this.writeU8(0x00);\n    }\n    writeId3V2TextFrame(frameId, text) {\n        const useIso88591 = isIso88591Compatible(text);\n        const textDataLength = useIso88591 ? text.length : textEncoder.encode(text).byteLength;\n        const frameSize = 1 + textDataLength + 1;\n        this.writeAscii(frameId);\n        this.writeSynchsafeU32(frameSize);\n        this.writeU16(0x0000);\n        this.writeU8(useIso88591 ? Id3V2TextEncoding.ISO_8859_1 : Id3V2TextEncoding.UTF_8);\n        if (useIso88591) {\n            this.writeIsoString(text);\n        }\n        else {\n            this.writeUtf8String(text);\n        }\n    }\n    writeId3V2LyricsFrame(lyrics) {\n        const useIso88591 = isIso88591Compatible(lyrics);\n        const shortDescription = '';\n        const frameSize = 1 + 3 + shortDescription.length + 1 + lyrics.length + 1;\n        this.writeAscii('USLT');\n        this.writeSynchsafeU32(frameSize);\n        this.writeU16(0x0000);\n        this.writeU8(useIso88591 ? Id3V2TextEncoding.ISO_8859_1 : Id3V2TextEncoding.UTF_8);\n        this.writeAscii('und');\n        if (useIso88591) {\n            this.writeIsoString(shortDescription);\n            this.writeIsoString(lyrics);\n        }\n        else {\n            this.writeUtf8String(shortDescription);\n            this.writeUtf8String(lyrics);\n        }\n    }\n    writeId3V2CommentFrame(comment) {\n        const useIso88591 = isIso88591Compatible(comment);\n        const textDataLength = useIso88591 ? comment.length : textEncoder.encode(comment).byteLength;\n        const shortDescription = '';\n        const frameSize = 1 + 3 + shortDescription.length + 1 + textDataLength + 1;\n        this.writeAscii('COMM');\n        this.writeSynchsafeU32(frameSize);\n        this.writeU16(0x0000);\n        this.writeU8(useIso88591 ? Id3V2TextEncoding.ISO_8859_1 : Id3V2TextEncoding.UTF_8);\n        this.writeU8(0x75); // 'u'\n        this.writeU8(0x6E); // 'n'\n        this.writeU8(0x64); // 'd'\n        if (useIso88591) {\n            this.writeIsoString(shortDescription);\n            this.writeIsoString(comment);\n        }\n        else {\n            this.writeUtf8String(shortDescription);\n            this.writeUtf8String(comment);\n        }\n    }\n    writeId3V2ApicFrame(mimeType, pictureType, description, imageData) {\n        const useIso88591 = isIso88591Compatible(mimeType) && isIso88591Compatible(description);\n        const descriptionDataLength = useIso88591\n            ? description.length\n            : textEncoder.encode(description).byteLength;\n        const frameSize = 1 + mimeType.length + 1 + 1 + descriptionDataLength + 1 + imageData.byteLength;\n        this.writeAscii('APIC');\n        this.writeSynchsafeU32(frameSize);\n        this.writeU16(0x0000);\n        this.writeU8(useIso88591 ? Id3V2TextEncoding.ISO_8859_1 : Id3V2TextEncoding.UTF_8);\n        if (useIso88591) {\n            this.writeIsoString(mimeType);\n        }\n        else {\n            this.writeUtf8String(mimeType);\n        }\n        this.writeU8(pictureType);\n        if (useIso88591) {\n            this.writeIsoString(description);\n        }\n        else {\n            this.writeUtf8String(description);\n        }\n        this.writer.write(imageData);\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { FRAME_HEADER_SIZE, readFrameHeader } from '../../shared/mp3-misc.js';\nimport { readU32Be } from '../reader.js';\nexport const readNextFrameHeader = async (reader, startPos, until) => {\n    let currentPos = startPos;\n    while (until === null || currentPos < until) {\n        let slice = reader.requestSlice(currentPos, FRAME_HEADER_SIZE);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            break;\n        const word = readU32Be(slice);\n        const result = readFrameHeader(word, reader.fileSize !== null ? reader.fileSize - currentPos : null);\n        if (result.header) {\n            return { header: result.header, startPos: currentPos };\n        }\n        currentPos += result.bytesAdvanced;\n    }\n    return null;\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Demuxer } from '../demuxer.js';\nimport { InputAudioTrack } from '../input-track.js';\nimport { DEFAULT_TRACK_DISPOSITION } from '../metadata.js';\nimport { assert, AsyncMutex, binarySearchExact, binarySearchLessOrEqual, UNDETERMINED_LANGUAGE } from '../misc.js';\nimport { EncodedPacket, PLACEHOLDER_DATA } from '../packet.js';\nimport { getXingOffset, INFO, XING } from '../../shared/mp3-misc.js';\nimport { ID3_V1_TAG_SIZE, ID3_V2_HEADER_SIZE, parseId3V1Tag, parseId3V2Tag, readId3V2Header, } from '../id3.js';\nimport { readNextFrameHeader } from './mp3-reader.js';\nimport { readAscii, readBytes, readU32Be } from '../reader.js';\nexport class Mp3Demuxer extends Demuxer {\n    constructor(input) {\n        super(input);\n        this.metadataPromise = null;\n        this.firstFrameHeader = null;\n        this.loadedSamples = []; // All samples from the start of the file to lastLoadedPos\n        this.metadataTags = null;\n        this.tracks = [];\n        this.readingMutex = new AsyncMutex();\n        this.lastSampleLoaded = false;\n        this.lastLoadedPos = 0;\n        this.nextTimestampInSamples = 0;\n        this.reader = input._reader;\n    }\n    async readMetadata() {\n        return this.metadataPromise ??= (async () => {\n            // Keep loading until we find the first frame header\n            while (!this.firstFrameHeader && !this.lastSampleLoaded) {\n                await this.advanceReader();\n            }\n            if (!this.firstFrameHeader) {\n                throw new Error('No valid MP3 frame found.');\n            }\n            this.tracks = [new InputAudioTrack(this.input, new Mp3AudioTrackBacking(this))];\n        })();\n    }\n    async advanceReader() {\n        if (this.lastLoadedPos === 0) {\n            // Let's skip all ID3v2 tags at the start of the file\n            while (true) {\n                let slice = this.reader.requestSlice(this.lastLoadedPos, ID3_V2_HEADER_SIZE);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (!slice) {\n                    this.lastSampleLoaded = true;\n                    return;\n                }\n                const id3V2Header = readId3V2Header(slice);\n                if (!id3V2Header) {\n                    break;\n                }\n                this.lastLoadedPos = slice.filePos + id3V2Header.size;\n            }\n        }\n        const result = await readNextFrameHeader(this.reader, this.lastLoadedPos, this.reader.fileSize);\n        if (!result) {\n            this.lastSampleLoaded = true;\n            return;\n        }\n        const header = result.header;\n        this.lastLoadedPos = result.startPos + header.totalSize - 1; // -1 in case the frame is 1 byte too short\n        const xingOffset = getXingOffset(header.mpegVersionId, header.channel);\n        let slice = this.reader.requestSlice(result.startPos + xingOffset, 4);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (slice) {\n            const word = readU32Be(slice);\n            const isXing = word === XING || word === INFO;\n            if (isXing) {\n                // There's no actual audio data in this frame, so let's skip it\n                return;\n            }\n        }\n        if (!this.firstFrameHeader) {\n            this.firstFrameHeader = header;\n        }\n        if (header.sampleRate !== this.firstFrameHeader.sampleRate) {\n            console.warn(`MP3 changed sample rate mid-file: ${this.firstFrameHeader.sampleRate} Hz to ${header.sampleRate} Hz.`\n                + ` Might be a bug, so please report this file.`);\n        }\n        const sampleDuration = header.audioSamplesInFrame / this.firstFrameHeader.sampleRate;\n        const sample = {\n            timestamp: this.nextTimestampInSamples / this.firstFrameHeader.sampleRate,\n            duration: sampleDuration,\n            dataStart: result.startPos,\n            dataSize: header.totalSize,\n        };\n        this.loadedSamples.push(sample);\n        this.nextTimestampInSamples += header.audioSamplesInFrame;\n        return;\n    }\n    async getMimeType() {\n        return 'audio/mpeg';\n    }\n    async getTracks() {\n        await this.readMetadata();\n        return this.tracks;\n    }\n    async computeDuration() {\n        await this.readMetadata();\n        const track = this.tracks[0];\n        assert(track);\n        return track.computeDuration();\n    }\n    async getMetadataTags() {\n        const release = await this.readingMutex.acquire();\n        try {\n            await this.readMetadata();\n            if (this.metadataTags) {\n                return this.metadataTags;\n            }\n            this.metadataTags = {};\n            let currentPos = 0;\n            let id3V2HeaderFound = false;\n            while (true) {\n                let headerSlice = this.reader.requestSlice(currentPos, ID3_V2_HEADER_SIZE);\n                if (headerSlice instanceof Promise)\n                    headerSlice = await headerSlice;\n                if (!headerSlice)\n                    break;\n                const id3V2Header = readId3V2Header(headerSlice);\n                if (!id3V2Header) {\n                    break;\n                }\n                id3V2HeaderFound = true;\n                let contentSlice = this.reader.requestSlice(headerSlice.filePos, id3V2Header.size);\n                if (contentSlice instanceof Promise)\n                    contentSlice = await contentSlice;\n                if (!contentSlice)\n                    break;\n                parseId3V2Tag(contentSlice, id3V2Header, this.metadataTags);\n                currentPos = headerSlice.filePos + id3V2Header.size;\n            }\n            if (!id3V2HeaderFound && this.reader.fileSize !== null && this.reader.fileSize >= ID3_V1_TAG_SIZE) {\n                // Try reading an ID3v1 tag at the end of the file\n                let slice = this.reader.requestSlice(this.reader.fileSize - ID3_V1_TAG_SIZE, ID3_V1_TAG_SIZE);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                assert(slice);\n                const tag = readAscii(slice, 3);\n                if (tag === 'TAG') {\n                    parseId3V1Tag(slice, this.metadataTags);\n                }\n            }\n            return this.metadataTags;\n        }\n        finally {\n            release();\n        }\n    }\n}\nclass Mp3AudioTrackBacking {\n    constructor(demuxer) {\n        this.demuxer = demuxer;\n    }\n    getId() {\n        return 1;\n    }\n    async getFirstTimestamp() {\n        return 0;\n    }\n    getTimeResolution() {\n        assert(this.demuxer.firstFrameHeader);\n        return this.demuxer.firstFrameHeader.sampleRate / this.demuxer.firstFrameHeader.audioSamplesInFrame;\n    }\n    async computeDuration() {\n        const lastPacket = await this.getPacket(Infinity, { metadataOnly: true });\n        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);\n    }\n    getName() {\n        return null;\n    }\n    getLanguageCode() {\n        return UNDETERMINED_LANGUAGE;\n    }\n    getCodec() {\n        return 'mp3';\n    }\n    getInternalCodecId() {\n        return null;\n    }\n    getNumberOfChannels() {\n        assert(this.demuxer.firstFrameHeader);\n        return this.demuxer.firstFrameHeader.channel === 3 ? 1 : 2;\n    }\n    getSampleRate() {\n        assert(this.demuxer.firstFrameHeader);\n        return this.demuxer.firstFrameHeader.sampleRate;\n    }\n    getDisposition() {\n        return {\n            ...DEFAULT_TRACK_DISPOSITION,\n        };\n    }\n    async getDecoderConfig() {\n        assert(this.demuxer.firstFrameHeader);\n        return {\n            codec: 'mp3',\n            numberOfChannels: this.demuxer.firstFrameHeader.channel === 3 ? 1 : 2,\n            sampleRate: this.demuxer.firstFrameHeader.sampleRate,\n        };\n    }\n    async getPacketAtIndex(sampleIndex, options) {\n        if (sampleIndex === -1) {\n            return null;\n        }\n        const rawSample = this.demuxer.loadedSamples[sampleIndex];\n        if (!rawSample) {\n            return null;\n        }\n        let data;\n        if (options.metadataOnly) {\n            data = PLACEHOLDER_DATA;\n        }\n        else {\n            let slice = this.demuxer.reader.requestSlice(rawSample.dataStart, rawSample.dataSize);\n            if (slice instanceof Promise)\n                slice = await slice;\n            if (!slice) {\n                return null; // Data didn't fit into the rest of the file\n            }\n            data = readBytes(slice, rawSample.dataSize);\n        }\n        return new EncodedPacket(data, 'key', rawSample.timestamp, rawSample.duration, sampleIndex, rawSample.dataSize);\n    }\n    getFirstPacket(options) {\n        return this.getPacketAtIndex(0, options);\n    }\n    async getNextPacket(packet, options) {\n        const release = await this.demuxer.readingMutex.acquire();\n        try {\n            const sampleIndex = binarySearchExact(this.demuxer.loadedSamples, packet.timestamp, x => x.timestamp);\n            if (sampleIndex === -1) {\n                throw new Error('Packet was not created from this track.');\n            }\n            const nextIndex = sampleIndex + 1;\n            // Ensure the next sample exists\n            while (nextIndex >= this.demuxer.loadedSamples.length\n                && !this.demuxer.lastSampleLoaded) {\n                await this.demuxer.advanceReader();\n            }\n            return this.getPacketAtIndex(nextIndex, options);\n        }\n        finally {\n            release();\n        }\n    }\n    async getPacket(timestamp, options) {\n        const release = await this.demuxer.readingMutex.acquire();\n        try {\n            while (true) {\n                const index = binarySearchLessOrEqual(this.demuxer.loadedSamples, timestamp, x => x.timestamp);\n                if (index === -1 && this.demuxer.loadedSamples.length > 0) {\n                    // We're before the first sample\n                    return null;\n                }\n                if (this.demuxer.lastSampleLoaded) {\n                    // All data is loaded, return what we found\n                    return this.getPacketAtIndex(index, options);\n                }\n                if (index >= 0 && index + 1 < this.demuxer.loadedSamples.length) {\n                    // The next packet also exists, we're done\n                    return this.getPacketAtIndex(index, options);\n                }\n                // Otherwise, keep loading data\n                await this.demuxer.advanceReader();\n            }\n        }\n        finally {\n            release();\n        }\n    }\n    getKeyPacket(timestamp, options) {\n        return this.getPacket(timestamp, options);\n    }\n    getNextKeyPacket(packet, options) {\n        return this.getNextPacket(packet, options);\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { parseOpusTocByte } from '../codec-data.js';\nimport { assert, ilog, toDataView } from '../misc.js';\nexport const OGGS = 0x5367674f; // 'OggS'\nconst OGG_CRC_POLYNOMIAL = 0x04c11db7;\nconst OGG_CRC_TABLE = new Uint32Array(256);\nfor (let n = 0; n < 256; n++) {\n    let crc = n << 24;\n    for (let k = 0; k < 8; k++) {\n        crc = (crc & 0x80000000)\n            ? ((crc << 1) ^ OGG_CRC_POLYNOMIAL)\n            : (crc << 1);\n    }\n    OGG_CRC_TABLE[n] = (crc >>> 0) & 0xffffffff;\n}\nexport const computeOggPageCrc = (bytes) => {\n    const view = toDataView(bytes);\n    const originalChecksum = view.getUint32(22, true);\n    view.setUint32(22, 0, true); // Zero out checksum field\n    let crc = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const byte = bytes[i];\n        crc = ((crc << 8) ^ OGG_CRC_TABLE[(crc >>> 24) ^ byte]) >>> 0;\n    }\n    view.setUint32(22, originalChecksum, true); // Restore checksum field\n    return crc;\n};\nexport const extractSampleMetadata = (data, codecInfo, vorbisLastBlocksize) => {\n    let durationInSamples = 0;\n    let currentBlocksize = null;\n    if (data.length > 0) {\n        // To know sample duration, we'll need to peak inside the packet\n        if (codecInfo.codec === 'vorbis') {\n            assert(codecInfo.vorbisInfo);\n            const vorbisModeCount = codecInfo.vorbisInfo.modeBlockflags.length;\n            const bitCount = ilog(vorbisModeCount - 1);\n            const modeMask = ((1 << bitCount) - 1) << 1;\n            const modeNumber = (data[0] & modeMask) >> 1;\n            if (modeNumber >= codecInfo.vorbisInfo.modeBlockflags.length) {\n                throw new Error('Invalid mode number.');\n            }\n            // In Vorbis, packet duration also depends on the blocksize of the previous packet\n            let prevBlocksize = vorbisLastBlocksize;\n            const blockflag = codecInfo.vorbisInfo.modeBlockflags[modeNumber];\n            currentBlocksize = codecInfo.vorbisInfo.blocksizes[blockflag];\n            if (blockflag === 1) {\n                const prevMask = (modeMask | 0x1) + 1;\n                const flag = data[0] & prevMask ? 1 : 0;\n                prevBlocksize = codecInfo.vorbisInfo.blocksizes[flag];\n            }\n            durationInSamples = prevBlocksize !== null\n                ? (prevBlocksize + currentBlocksize) >> 2\n                : 0; // The first sample outputs no audio data and therefore has a duration of 0\n        }\n        else if (codecInfo.codec === 'opus') {\n            const toc = parseOpusTocByte(data);\n            durationInSamples = toc.durationInSamples;\n        }\n    }\n    return {\n        durationInSamples,\n        vorbisBlockSize: currentBlocksize,\n    };\n};\nexport const buildOggMimeType = (info) => {\n    let string = 'audio/ogg';\n    if (info.codecStrings) {\n        const uniqueCodecMimeTypes = [...new Set(info.codecStrings)];\n        string += `; codecs=\"${uniqueCodecMimeTypes.join(', ')}\"`;\n    }\n    return string;\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { readI64Le, readU32Le, readU8 } from '../reader.js';\nimport { OGGS } from './ogg-misc.js';\nexport const MIN_PAGE_HEADER_SIZE = 27;\nexport const MAX_PAGE_HEADER_SIZE = 27 + 255;\nexport const MAX_PAGE_SIZE = MAX_PAGE_HEADER_SIZE + 255 * 255;\nexport const readPageHeader = (slice) => {\n    const startPos = slice.filePos;\n    const capturePattern = readU32Le(slice);\n    if (capturePattern !== OGGS) {\n        return null;\n    }\n    slice.skip(1); // Version\n    const headerType = readU8(slice);\n    const granulePosition = readI64Le(slice);\n    const serialNumber = readU32Le(slice);\n    const sequenceNumber = readU32Le(slice);\n    const checksum = readU32Le(slice);\n    const numberPageSegments = readU8(slice);\n    const lacingValues = new Uint8Array(numberPageSegments);\n    for (let i = 0; i < numberPageSegments; i++) {\n        lacingValues[i] = readU8(slice);\n    }\n    const headerSize = 27 + numberPageSegments;\n    const dataSize = lacingValues.reduce((a, b) => a + b, 0);\n    const totalSize = headerSize + dataSize;\n    return {\n        headerStartPos: startPos,\n        totalSize,\n        dataStartPos: startPos + headerSize,\n        dataSize,\n        headerType,\n        granulePosition,\n        serialNumber,\n        sequenceNumber,\n        checksum,\n        lacingValues,\n    };\n};\nexport const findNextPageHeader = (slice, until) => {\n    while (slice.filePos < until - (4 - 1)) { // Size of word minus 1\n        const word = readU32Le(slice);\n        const firstByte = word & 0xff;\n        const secondByte = (word >>> 8) & 0xff;\n        const thirdByte = (word >>> 16) & 0xff;\n        const fourthByte = (word >>> 24) & 0xff;\n        const O = 0x4f; // 'O'\n        if (firstByte !== O && secondByte !== O && thirdByte !== O && fourthByte !== O) {\n            continue;\n        }\n        slice.skip(-4);\n        if (word === OGGS) {\n            // We have found the capture pattern\n            return true;\n        }\n        slice.skip(1);\n    }\n    return false;\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { OPUS_SAMPLE_RATE } from '../codec.js';\nimport { parseModesFromVorbisSetupPacket, parseOpusIdentificationHeader, readVorbisComments } from '../codec-data.js';\nimport { Demuxer } from '../demuxer.js';\nimport { InputAudioTrack } from '../input-track.js';\nimport { DEFAULT_TRACK_DISPOSITION } from '../metadata.js';\nimport { assert, AsyncMutex, binarySearchLessOrEqual, findLast, last, roundIfAlmostInteger, toDataView, UNDETERMINED_LANGUAGE, } from '../misc.js';\nimport { EncodedPacket, PLACEHOLDER_DATA } from '../packet.js';\nimport { readBytes } from '../reader.js';\nimport { buildOggMimeType, computeOggPageCrc, extractSampleMetadata } from './ogg-misc.js';\nimport { findNextPageHeader, MAX_PAGE_HEADER_SIZE, MAX_PAGE_SIZE, MIN_PAGE_HEADER_SIZE, readPageHeader, } from './ogg-reader.js';\nexport class OggDemuxer extends Demuxer {\n    constructor(input) {\n        super(input);\n        this.metadataPromise = null;\n        this.bitstreams = [];\n        this.tracks = [];\n        this.metadataTags = {};\n        this.reader = input._reader;\n    }\n    async readMetadata() {\n        return this.metadataPromise ??= (async () => {\n            let currentPos = 0;\n            while (true) {\n                let slice = this.reader.requestSliceRange(currentPos, MIN_PAGE_HEADER_SIZE, MAX_PAGE_HEADER_SIZE);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (!slice)\n                    break;\n                const page = readPageHeader(slice);\n                if (!page) {\n                    break;\n                }\n                const isBos = !!(page.headerType & 0x02);\n                if (!isBos) {\n                    // All bos pages for all bitstreams are required to be at the start, so if the page is not bos then\n                    // we know we've seen all bitstreams (minus chaining)\n                    break;\n                }\n                this.bitstreams.push({\n                    serialNumber: page.serialNumber,\n                    bosPage: page,\n                    description: null,\n                    numberOfChannels: -1,\n                    sampleRate: -1,\n                    codecInfo: {\n                        codec: null,\n                        vorbisInfo: null,\n                        opusInfo: null,\n                    },\n                    lastMetadataPacket: null,\n                });\n                currentPos = page.headerStartPos + page.totalSize;\n            }\n            for (const bitstream of this.bitstreams) {\n                const firstPacket = await this.readPacket(bitstream.bosPage, 0);\n                if (!firstPacket) {\n                    continue;\n                }\n                if (\n                // Check for Vorbis\n                firstPacket.data.byteLength >= 7\n                    && firstPacket.data[0] === 0x01 // Packet type 1 = identification header\n                    && firstPacket.data[1] === 0x76 // 'v'\n                    && firstPacket.data[2] === 0x6f // 'o'\n                    && firstPacket.data[3] === 0x72 // 'r'\n                    && firstPacket.data[4] === 0x62 // 'b'\n                    && firstPacket.data[5] === 0x69 // 'i'\n                    && firstPacket.data[6] === 0x73 // 's'\n                ) {\n                    await this.readVorbisMetadata(firstPacket, bitstream);\n                }\n                else if (\n                // Check for Opus\n                firstPacket.data.byteLength >= 8\n                    && firstPacket.data[0] === 0x4f // 'O'\n                    && firstPacket.data[1] === 0x70 // 'p'\n                    && firstPacket.data[2] === 0x75 // 'u'\n                    && firstPacket.data[3] === 0x73 // 's'\n                    && firstPacket.data[4] === 0x48 // 'H'\n                    && firstPacket.data[5] === 0x65 // 'e'\n                    && firstPacket.data[6] === 0x61 // 'a'\n                    && firstPacket.data[7] === 0x64 // 'd'\n                ) {\n                    await this.readOpusMetadata(firstPacket, bitstream);\n                }\n                if (bitstream.codecInfo.codec !== null) {\n                    this.tracks.push(new InputAudioTrack(this.input, new OggAudioTrackBacking(bitstream, this)));\n                }\n            }\n        })();\n    }\n    async readVorbisMetadata(firstPacket, bitstream) {\n        let nextPacketPosition = await this.findNextPacketStart(firstPacket);\n        if (!nextPacketPosition) {\n            return;\n        }\n        const secondPacket = await this.readPacket(nextPacketPosition.startPage, nextPacketPosition.startSegmentIndex);\n        if (!secondPacket) {\n            return;\n        }\n        nextPacketPosition = await this.findNextPacketStart(secondPacket);\n        if (!nextPacketPosition) {\n            return;\n        }\n        const thirdPacket = await this.readPacket(nextPacketPosition.startPage, nextPacketPosition.startSegmentIndex);\n        if (!thirdPacket) {\n            return;\n        }\n        if (secondPacket.data[0] !== 0x03 || thirdPacket.data[0] !== 0x05) {\n            return;\n        }\n        const lacingValues = [];\n        const addBytesToSegmentTable = (bytes) => {\n            while (true) {\n                lacingValues.push(Math.min(255, bytes));\n                if (bytes < 255) {\n                    break;\n                }\n                bytes -= 255;\n            }\n        };\n        addBytesToSegmentTable(firstPacket.data.length);\n        addBytesToSegmentTable(secondPacket.data.length);\n        // We don't add the last packet to the segment table, as it is assumed to be whatever bytes remain\n        const description = new Uint8Array(1 + lacingValues.length\n            + firstPacket.data.length + secondPacket.data.length + thirdPacket.data.length);\n        description[0] = 2; // Num entries in the segment table\n        description.set(lacingValues, 1);\n        description.set(firstPacket.data, 1 + lacingValues.length);\n        description.set(secondPacket.data, 1 + lacingValues.length + firstPacket.data.length);\n        description.set(thirdPacket.data, 1 + lacingValues.length + firstPacket.data.length + secondPacket.data.length);\n        bitstream.codecInfo.codec = 'vorbis';\n        bitstream.description = description;\n        bitstream.lastMetadataPacket = thirdPacket;\n        const view = toDataView(firstPacket.data);\n        bitstream.numberOfChannels = view.getUint8(11);\n        bitstream.sampleRate = view.getUint32(12, true);\n        const blockSizeByte = view.getUint8(28);\n        bitstream.codecInfo.vorbisInfo = {\n            blocksizes: [\n                1 << (blockSizeByte & 0xf),\n                1 << (blockSizeByte >> 4),\n            ],\n            modeBlockflags: parseModesFromVorbisSetupPacket(thirdPacket.data).modeBlockflags,\n        };\n        readVorbisComments(secondPacket.data.subarray(7), this.metadataTags); // Skip header type and 'vorbis'\n    }\n    async readOpusMetadata(firstPacket, bitstream) {\n        // From https://datatracker.ietf.org/doc/html/rfc7845#section-5:\n        // \"An Ogg Opus logical stream contains exactly two mandatory header packets: an identification header and a\n        // comment header.\"\n        const nextPacketPosition = await this.findNextPacketStart(firstPacket);\n        if (!nextPacketPosition) {\n            return;\n        }\n        const secondPacket = await this.readPacket(nextPacketPosition.startPage, nextPacketPosition.startSegmentIndex);\n        if (!secondPacket) {\n            return;\n        }\n        bitstream.codecInfo.codec = 'opus';\n        bitstream.description = firstPacket.data;\n        bitstream.lastMetadataPacket = secondPacket;\n        const header = parseOpusIdentificationHeader(firstPacket.data);\n        bitstream.numberOfChannels = header.outputChannelCount;\n        bitstream.sampleRate = OPUS_SAMPLE_RATE; // Always the same\n        bitstream.codecInfo.opusInfo = {\n            preSkip: header.preSkip,\n        };\n        readVorbisComments(secondPacket.data.subarray(8), this.metadataTags); // Skip 'OpusTags'\n    }\n    async readPacket(startPage, startSegmentIndex) {\n        assert(startSegmentIndex < startPage.lacingValues.length);\n        let startDataOffset = 0;\n        for (let i = 0; i < startSegmentIndex; i++) {\n            startDataOffset += startPage.lacingValues[i];\n        }\n        let currentPage = startPage;\n        let currentDataOffset = startDataOffset;\n        let currentSegmentIndex = startSegmentIndex;\n        const chunks = [];\n        outer: while (true) {\n            // Load the entire page data\n            let pageSlice = this.reader.requestSlice(currentPage.dataStartPos, currentPage.dataSize);\n            if (pageSlice instanceof Promise)\n                pageSlice = await pageSlice;\n            assert(pageSlice);\n            const pageData = readBytes(pageSlice, currentPage.dataSize);\n            while (true) {\n                if (currentSegmentIndex === currentPage.lacingValues.length) {\n                    chunks.push(pageData.subarray(startDataOffset, currentDataOffset));\n                    break;\n                }\n                const lacingValue = currentPage.lacingValues[currentSegmentIndex];\n                currentDataOffset += lacingValue;\n                if (lacingValue < 255) {\n                    chunks.push(pageData.subarray(startDataOffset, currentDataOffset));\n                    break outer;\n                }\n                currentSegmentIndex++;\n            }\n            // The packet extends to the next page; let's find it\n            let currentPos = currentPage.headerStartPos + currentPage.totalSize;\n            while (true) {\n                let headerSlice = this.reader.requestSliceRange(currentPos, MIN_PAGE_HEADER_SIZE, MAX_PAGE_HEADER_SIZE);\n                if (headerSlice instanceof Promise)\n                    headerSlice = await headerSlice;\n                if (!headerSlice) {\n                    return null;\n                }\n                const nextPage = readPageHeader(headerSlice);\n                if (!nextPage) {\n                    return null;\n                }\n                currentPage = nextPage;\n                if (currentPage.serialNumber === startPage.serialNumber) {\n                    break;\n                }\n                currentPos = currentPage.headerStartPos + currentPage.totalSize;\n            }\n            startDataOffset = 0;\n            currentDataOffset = 0;\n            currentSegmentIndex = 0;\n        }\n        const totalPacketSize = chunks.reduce((sum, chunk) => sum + chunk.length, 0);\n        const packetData = new Uint8Array(totalPacketSize);\n        let offset = 0;\n        for (let i = 0; i < chunks.length; i++) {\n            const chunk = chunks[i];\n            packetData.set(chunk, offset);\n            offset += chunk.length;\n        }\n        return {\n            data: packetData,\n            endPage: currentPage,\n            endSegmentIndex: currentSegmentIndex,\n        };\n    }\n    async findNextPacketStart(lastPacket) {\n        // If there's another segment in the same page, return it\n        if (lastPacket.endSegmentIndex < lastPacket.endPage.lacingValues.length - 1) {\n            return { startPage: lastPacket.endPage, startSegmentIndex: lastPacket.endSegmentIndex + 1 };\n        }\n        const isEos = !!(lastPacket.endPage.headerType & 0x04);\n        if (isEos) {\n            // The page is marked as the last page of the logical bitstream, so we won't find anything beyond it\n            return null;\n        }\n        // Otherwise, search for the next page belonging to the same bitstream\n        let currentPos = lastPacket.endPage.headerStartPos + lastPacket.endPage.totalSize;\n        while (true) {\n            let slice = this.reader.requestSliceRange(currentPos, MIN_PAGE_HEADER_SIZE, MAX_PAGE_HEADER_SIZE);\n            if (slice instanceof Promise)\n                slice = await slice;\n            if (!slice) {\n                return null;\n            }\n            const nextPage = readPageHeader(slice);\n            if (!nextPage) {\n                return null;\n            }\n            if (nextPage.serialNumber === lastPacket.endPage.serialNumber) {\n                return { startPage: nextPage, startSegmentIndex: 0 };\n            }\n            currentPos = nextPage.headerStartPos + nextPage.totalSize;\n        }\n    }\n    async getMimeType() {\n        await this.readMetadata();\n        const codecStrings = await Promise.all(this.tracks.map(x => x.getCodecParameterString()));\n        return buildOggMimeType({\n            codecStrings: codecStrings.filter(Boolean),\n        });\n    }\n    async getTracks() {\n        await this.readMetadata();\n        return this.tracks;\n    }\n    async computeDuration() {\n        const tracks = await this.getTracks();\n        const trackDurations = await Promise.all(tracks.map(x => x.computeDuration()));\n        return Math.max(0, ...trackDurations);\n    }\n    async getMetadataTags() {\n        await this.readMetadata();\n        return this.metadataTags;\n    }\n}\nclass OggAudioTrackBacking {\n    constructor(bitstream, demuxer) {\n        this.bitstream = bitstream;\n        this.demuxer = demuxer;\n        this.encodedPacketToMetadata = new WeakMap();\n        this.sequentialScanCache = [];\n        this.sequentialScanMutex = new AsyncMutex();\n        // Opus always uses a fixed sample rate for its internal calculations, even if the actual rate is different\n        this.internalSampleRate = bitstream.codecInfo.codec === 'opus'\n            ? OPUS_SAMPLE_RATE\n            : bitstream.sampleRate;\n    }\n    getId() {\n        return this.bitstream.serialNumber;\n    }\n    getNumberOfChannels() {\n        return this.bitstream.numberOfChannels;\n    }\n    getSampleRate() {\n        return this.bitstream.sampleRate;\n    }\n    getTimeResolution() {\n        return this.bitstream.sampleRate;\n    }\n    getCodec() {\n        return this.bitstream.codecInfo.codec;\n    }\n    getInternalCodecId() {\n        return null;\n    }\n    async getDecoderConfig() {\n        assert(this.bitstream.codecInfo.codec);\n        return {\n            codec: this.bitstream.codecInfo.codec,\n            numberOfChannels: this.bitstream.numberOfChannels,\n            sampleRate: this.bitstream.sampleRate,\n            description: this.bitstream.description ?? undefined,\n        };\n    }\n    getName() {\n        return null;\n    }\n    getLanguageCode() {\n        return UNDETERMINED_LANGUAGE;\n    }\n    getDisposition() {\n        return {\n            ...DEFAULT_TRACK_DISPOSITION,\n        };\n    }\n    async getFirstTimestamp() {\n        return 0;\n    }\n    async computeDuration() {\n        const lastPacket = await this.getPacket(Infinity, { metadataOnly: true });\n        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);\n    }\n    granulePositionToTimestampInSamples(granulePosition) {\n        if (this.bitstream.codecInfo.codec === 'opus') {\n            assert(this.bitstream.codecInfo.opusInfo);\n            return granulePosition - this.bitstream.codecInfo.opusInfo.preSkip;\n        }\n        return granulePosition;\n    }\n    createEncodedPacketFromOggPacket(packet, additional, options) {\n        if (!packet) {\n            return null;\n        }\n        const { durationInSamples, vorbisBlockSize } = extractSampleMetadata(packet.data, this.bitstream.codecInfo, additional.vorbisLastBlocksize);\n        const encodedPacket = new EncodedPacket(options.metadataOnly ? PLACEHOLDER_DATA : packet.data, 'key', Math.max(0, additional.timestampInSamples) / this.internalSampleRate, durationInSamples / this.internalSampleRate, packet.endPage.headerStartPos + packet.endSegmentIndex, packet.data.byteLength);\n        this.encodedPacketToMetadata.set(encodedPacket, {\n            packet,\n            timestampInSamples: additional.timestampInSamples,\n            durationInSamples,\n            vorbisLastBlockSize: additional.vorbisLastBlocksize,\n            vorbisBlockSize,\n        });\n        return encodedPacket;\n    }\n    async getFirstPacket(options) {\n        assert(this.bitstream.lastMetadataPacket);\n        const packetPosition = await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);\n        if (!packetPosition) {\n            return null;\n        }\n        let timestampInSamples = 0;\n        if (this.bitstream.codecInfo.codec === 'opus') {\n            assert(this.bitstream.codecInfo.opusInfo);\n            timestampInSamples -= this.bitstream.codecInfo.opusInfo.preSkip;\n        }\n        const packet = await this.demuxer.readPacket(packetPosition.startPage, packetPosition.startSegmentIndex);\n        return this.createEncodedPacketFromOggPacket(packet, {\n            timestampInSamples,\n            vorbisLastBlocksize: null,\n        }, options);\n    }\n    async getNextPacket(prevPacket, options) {\n        const prevMetadata = this.encodedPacketToMetadata.get(prevPacket);\n        if (!prevMetadata) {\n            throw new Error('Packet was not created from this track.');\n        }\n        const packetPosition = await this.demuxer.findNextPacketStart(prevMetadata.packet);\n        if (!packetPosition) {\n            return null;\n        }\n        const timestampInSamples = prevMetadata.timestampInSamples + prevMetadata.durationInSamples;\n        const packet = await this.demuxer.readPacket(packetPosition.startPage, packetPosition.startSegmentIndex);\n        return this.createEncodedPacketFromOggPacket(packet, {\n            timestampInSamples,\n            vorbisLastBlocksize: prevMetadata.vorbisBlockSize,\n        }, options);\n    }\n    async getPacket(timestamp, options) {\n        if (this.demuxer.reader.fileSize === null) {\n            // No file size known, can't do binary search, but fall back to sequential algo instead\n            return this.getPacketSequential(timestamp, options);\n        }\n        const timestampInSamples = roundIfAlmostInteger(timestamp * this.internalSampleRate);\n        if (timestampInSamples === 0) {\n            // Fast path for timestamp 0 - avoids binary search when playing back from the start\n            return this.getFirstPacket(options);\n        }\n        if (timestampInSamples < 0) {\n            // There's nothing here\n            return null;\n        }\n        assert(this.bitstream.lastMetadataPacket);\n        const startPosition = await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);\n        if (!startPosition) {\n            return null;\n        }\n        let lowPage = startPosition.startPage;\n        let high = this.demuxer.reader.fileSize;\n        const lowPages = [lowPage];\n        // First, let's perform a binary serach (bisection search) on the file to find the approximate page where\n        // we'll find the packet. We want to find a page whose end packet position is less than or equal to the\n        // packet position we're searching for.\n        // Outer loop: Does the binary serach\n        outer: while (lowPage.headerStartPos + lowPage.totalSize < high) {\n            const low = lowPage.headerStartPos;\n            const mid = Math.floor((low + high) / 2);\n            let searchStartPos = mid;\n            // Inner loop: Does a linear forward scan if the page cannot be found immediately\n            while (true) {\n                const until = Math.min(searchStartPos + MAX_PAGE_SIZE, high - MIN_PAGE_HEADER_SIZE);\n                let searchSlice = this.demuxer.reader.requestSlice(searchStartPos, until - searchStartPos);\n                if (searchSlice instanceof Promise)\n                    searchSlice = await searchSlice;\n                assert(searchSlice);\n                const found = findNextPageHeader(searchSlice, until);\n                if (!found) {\n                    high = mid + MIN_PAGE_HEADER_SIZE;\n                    continue outer;\n                }\n                let headerSlice = this.demuxer.reader.requestSliceRange(searchSlice.filePos, MIN_PAGE_HEADER_SIZE, MAX_PAGE_HEADER_SIZE);\n                if (headerSlice instanceof Promise)\n                    headerSlice = await headerSlice;\n                assert(headerSlice);\n                const page = readPageHeader(headerSlice);\n                assert(page);\n                let pageValid = false;\n                if (page.serialNumber === this.bitstream.serialNumber) {\n                    // Serial numbers are basically random numbers, and the chance of finding a fake page with\n                    // matching serial number is astronomically low, so we can be pretty sure this page is legit.\n                    pageValid = true;\n                }\n                else {\n                    let pageSlice = this.demuxer.reader.requestSlice(page.headerStartPos, page.totalSize);\n                    if (pageSlice instanceof Promise)\n                        pageSlice = await pageSlice;\n                    assert(pageSlice);\n                    // Validate the page by checking checksum\n                    const bytes = readBytes(pageSlice, page.totalSize);\n                    const crc = computeOggPageCrc(bytes);\n                    pageValid = crc === page.checksum;\n                }\n                if (!pageValid) {\n                    // Keep searching for a valid page\n                    searchStartPos = page.headerStartPos + 4; // 'OggS' is 4 bytes\n                    continue;\n                }\n                if (pageValid && page.serialNumber !== this.bitstream.serialNumber) {\n                    // Page is valid but from a different bitstream, so keep searching forward until we find one\n                    // belonging to the our bitstream\n                    searchStartPos = page.headerStartPos + page.totalSize;\n                    continue;\n                }\n                const isContinuationPage = page.granulePosition === -1;\n                if (isContinuationPage) {\n                    // No packet ends on this page - keep looking\n                    searchStartPos = page.headerStartPos + page.totalSize;\n                    continue;\n                }\n                // The page is valid and belongs to our bitstream; let's check its granule position to see where we\n                // need to take the bisection search.\n                if (this.granulePositionToTimestampInSamples(page.granulePosition) > timestampInSamples) {\n                    high = page.headerStartPos;\n                }\n                else {\n                    lowPage = page;\n                    lowPages.push(page);\n                }\n                continue outer;\n            }\n        }\n        // Now we have the last page with a packet position <= the packet position we're looking for, but there\n        // might be multiple pages with the packet position, in which case we actually need to find the first of\n        // such pages. We'll do this in two steps: First, let's find the latest page we know with an earlier packet\n        // position, and then linear scan ourselves forward until we find the correct page.\n        let lowerPage = startPosition.startPage;\n        for (const otherLowPage of lowPages) {\n            if (otherLowPage.granulePosition === lowPage.granulePosition) {\n                break;\n            }\n            if (!lowerPage || otherLowPage.headerStartPos > lowerPage.headerStartPos) {\n                lowerPage = otherLowPage;\n            }\n        }\n        let currentPage = lowerPage;\n        // Keep track of the pages we traversed, we need these later for backwards seeking\n        const previousPages = [currentPage];\n        while (true) {\n            // This loop must terminate as we'll eventually reach lowPage\n            if (currentPage.serialNumber === this.bitstream.serialNumber\n                && currentPage.granulePosition === lowPage.granulePosition) {\n                break;\n            }\n            const nextPos = currentPage.headerStartPos + currentPage.totalSize;\n            let slice = this.demuxer.reader.requestSliceRange(nextPos, MIN_PAGE_HEADER_SIZE, MAX_PAGE_HEADER_SIZE);\n            if (slice instanceof Promise)\n                slice = await slice;\n            assert(slice);\n            const nextPage = readPageHeader(slice);\n            assert(nextPage);\n            currentPage = nextPage;\n            if (currentPage.serialNumber === this.bitstream.serialNumber) {\n                previousPages.push(currentPage);\n            }\n        }\n        assert(currentPage.granulePosition !== -1);\n        let currentSegmentIndex = null;\n        let currentTimestampInSamples;\n        let currentTimestampIsCorrect;\n        // These indicate the end position of the packet that the granule position belongs to\n        let endPage = currentPage;\n        let endSegmentIndex = 0;\n        if (currentPage.headerStartPos === startPosition.startPage.headerStartPos) {\n            currentTimestampInSamples = this.granulePositionToTimestampInSamples(0);\n            currentTimestampIsCorrect = true;\n            currentSegmentIndex = 0;\n        }\n        else {\n            currentTimestampInSamples = 0; // Placeholder value! We'll refine it once we can\n            currentTimestampIsCorrect = false;\n            // Find the segment index of the next packet\n            for (let i = currentPage.lacingValues.length - 1; i >= 0; i--) {\n                const value = currentPage.lacingValues[i];\n                if (value < 255) {\n                    // We know the last packet ended at i, so the next one starts at i + 1\n                    currentSegmentIndex = i + 1;\n                    break;\n                }\n            }\n            // This must hold: Since this page has a granule position set, that means there must be a packet that\n            // ends in this page.\n            if (currentSegmentIndex === null) {\n                throw new Error('Invalid page with granule position: no packets end on this page.');\n            }\n            endSegmentIndex = currentSegmentIndex - 1;\n            const pseudopacket = {\n                data: PLACEHOLDER_DATA,\n                endPage,\n                endSegmentIndex,\n            };\n            const nextPosition = await this.demuxer.findNextPacketStart(pseudopacket);\n            if (nextPosition) {\n                // Let's rewind a single step (packet) - this previous packet ensures that we'll correctly compute\n                // the duration for the packet we're looking for.\n                const endPosition = findPreviousPacketEndPosition(previousPages, currentPage, currentSegmentIndex);\n                assert(endPosition);\n                const startPosition = findPacketStartPosition(previousPages, endPosition.page, endPosition.segmentIndex);\n                if (startPosition) {\n                    currentPage = startPosition.page;\n                    currentSegmentIndex = startPosition.segmentIndex;\n                }\n            }\n            else {\n                // There is no next position, which means we're looking for the last packet in the bitstream. The\n                // granule position on the last page tends to be fucky, so let's instead start the search on the\n                // page before that. So let's loop until we find a packet that ends in a previous page.\n                while (true) {\n                    const endPosition = findPreviousPacketEndPosition(previousPages, currentPage, currentSegmentIndex);\n                    if (!endPosition) {\n                        break;\n                    }\n                    const startPosition = findPacketStartPosition(previousPages, endPosition.page, endPosition.segmentIndex);\n                    if (!startPosition) {\n                        break;\n                    }\n                    currentPage = startPosition.page;\n                    currentSegmentIndex = startPosition.segmentIndex;\n                    if (endPosition.page.headerStartPos !== endPage.headerStartPos) {\n                        endPage = endPosition.page;\n                        endSegmentIndex = endPosition.segmentIndex;\n                        break;\n                    }\n                }\n            }\n        }\n        let lastEncodedPacket = null;\n        let lastEncodedPacketMetadata = null;\n        // Alright, now it's time for the final, granular seek: We keep iterating over packets until we've found the\n        // one with the correct timestamp - i.e., the last one with a timestamp <= the timestamp we're looking for.\n        while (currentPage !== null) {\n            assert(currentSegmentIndex !== null);\n            const packet = await this.demuxer.readPacket(currentPage, currentSegmentIndex);\n            if (!packet) {\n                break;\n            }\n            // We might need to skip the packet if it's a metadata one\n            const skipPacket = currentPage.headerStartPos === startPosition.startPage.headerStartPos\n                && currentSegmentIndex < startPosition.startSegmentIndex;\n            if (!skipPacket) {\n                let encodedPacket = this.createEncodedPacketFromOggPacket(packet, {\n                    timestampInSamples: currentTimestampInSamples,\n                    vorbisLastBlocksize: lastEncodedPacketMetadata?.vorbisBlockSize ?? null,\n                }, options);\n                assert(encodedPacket);\n                let encodedPacketMetadata = this.encodedPacketToMetadata.get(encodedPacket);\n                assert(encodedPacketMetadata);\n                if (!currentTimestampIsCorrect\n                    && packet.endPage.headerStartPos === endPage.headerStartPos\n                    && packet.endSegmentIndex === endSegmentIndex) {\n                    // We know this packet end timestamp can be derived from the page's granule position\n                    currentTimestampInSamples = this.granulePositionToTimestampInSamples(currentPage.granulePosition);\n                    currentTimestampIsCorrect = true;\n                    // Let's backpatch the packet we just created with the correct timestamp\n                    encodedPacket = this.createEncodedPacketFromOggPacket(packet, {\n                        timestampInSamples: currentTimestampInSamples - encodedPacketMetadata.durationInSamples,\n                        vorbisLastBlocksize: lastEncodedPacketMetadata?.vorbisBlockSize ?? null,\n                    }, options);\n                    assert(encodedPacket);\n                    encodedPacketMetadata = this.encodedPacketToMetadata.get(encodedPacket);\n                    assert(encodedPacketMetadata);\n                }\n                else {\n                    currentTimestampInSamples += encodedPacketMetadata.durationInSamples;\n                }\n                lastEncodedPacket = encodedPacket;\n                lastEncodedPacketMetadata = encodedPacketMetadata;\n                if (currentTimestampIsCorrect\n                    && (\n                    // Next timestamp will be too late\n                    Math.max(currentTimestampInSamples, 0) > timestampInSamples\n                        // This timestamp already matches\n                        || Math.max(encodedPacketMetadata.timestampInSamples, 0) === timestampInSamples)) {\n                    break;\n                }\n            }\n            const nextPosition = await this.demuxer.findNextPacketStart(packet);\n            if (!nextPosition) {\n                break;\n            }\n            currentPage = nextPosition.startPage;\n            currentSegmentIndex = nextPosition.startSegmentIndex;\n        }\n        return lastEncodedPacket;\n    }\n    // A slower but simpler and sequential algorithm for finding a packet in a file\n    async getPacketSequential(timestamp, options) {\n        const release = await this.sequentialScanMutex.acquire(); // Requires exclusivity because we write to a cache\n        try {\n            const timestampInSamples = roundIfAlmostInteger(timestamp * this.internalSampleRate);\n            timestamp = timestampInSamples / this.internalSampleRate;\n            const index = binarySearchLessOrEqual(this.sequentialScanCache, timestampInSamples, x => x.timestampInSamples);\n            let currentPacket;\n            if (index !== -1) {\n                // We don't need to start from the beginning, we can start at a previous scan point\n                const cacheEntry = this.sequentialScanCache[index];\n                currentPacket = this.createEncodedPacketFromOggPacket(cacheEntry.packet, {\n                    timestampInSamples: cacheEntry.timestampInSamples,\n                    vorbisLastBlocksize: cacheEntry.vorbisLastBlockSize,\n                }, options);\n            }\n            else {\n                currentPacket = await this.getFirstPacket(options);\n            }\n            let i = 0;\n            while (currentPacket && currentPacket.timestamp < timestamp) {\n                const nextPacket = await this.getNextPacket(currentPacket, options);\n                if (!nextPacket || nextPacket.timestamp > timestamp) {\n                    break;\n                }\n                currentPacket = nextPacket;\n                i++;\n                if (i === 100) {\n                    // Add \"checkpoints\" every once in a while to speed up subsequent random accesses\n                    i = 0;\n                    const metadata = this.encodedPacketToMetadata.get(currentPacket);\n                    assert(metadata);\n                    if (this.sequentialScanCache.length > 0) {\n                        // If we reach this case, we must be at the end of the cache\n                        assert(last(this.sequentialScanCache).timestampInSamples <= metadata.timestampInSamples);\n                    }\n                    this.sequentialScanCache.push(metadata);\n                }\n            }\n            return currentPacket;\n        }\n        finally {\n            release();\n        }\n    }\n    getKeyPacket(timestamp, options) {\n        return this.getPacket(timestamp, options);\n    }\n    getNextKeyPacket(packet, options) {\n        return this.getNextPacket(packet, options);\n    }\n}\n/** Finds the start position of a packet given its end position. */\nconst findPacketStartPosition = (pageList, endPage, endSegmentIndex) => {\n    let page = endPage;\n    let segmentIndex = endSegmentIndex;\n    outer: while (true) {\n        segmentIndex--;\n        for (segmentIndex; segmentIndex >= 0; segmentIndex--) {\n            const lacingValue = page.lacingValues[segmentIndex];\n            if (lacingValue < 255) {\n                segmentIndex++; // We know the last packet starts here\n                break outer;\n            }\n        }\n        assert(segmentIndex === -1);\n        const pageStartsWithFreshPacket = !(page.headerType & 0x01);\n        if (pageStartsWithFreshPacket) {\n            // Fast exit: We know we don't need to look in the previous page\n            segmentIndex = 0;\n            break;\n        }\n        const previousPage = findLast(pageList, x => x.headerStartPos < page.headerStartPos);\n        if (!previousPage) {\n            return null;\n        }\n        page = previousPage;\n        segmentIndex = page.lacingValues.length;\n    }\n    assert(segmentIndex !== -1);\n    if (segmentIndex === page.lacingValues.length) {\n        // Wrap back around to the first segment of the next page\n        const nextPage = pageList[pageList.indexOf(page) + 1];\n        assert(nextPage);\n        page = nextPage;\n        segmentIndex = 0;\n    }\n    return { page, segmentIndex };\n};\n/** Finds the end position of a packet given the start position of the following packet. */\nconst findPreviousPacketEndPosition = (pageList, startPage, startSegmentIndex) => {\n    if (startSegmentIndex > 0) {\n        // Easy\n        return { page: startPage, segmentIndex: startSegmentIndex - 1 };\n    }\n    const previousPage = findLast(pageList, x => x.headerStartPos < startPage.headerStartPos);\n    if (!previousPage) {\n        return null;\n    }\n    return { page: previousPage, segmentIndex: previousPage.lacingValues.length - 1 };\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Demuxer } from '../demuxer.js';\nimport { InputAudioTrack } from '../input-track.js';\nimport { DEFAULT_TRACK_DISPOSITION } from '../metadata.js';\nimport { assert, UNDETERMINED_LANGUAGE } from '../misc.js';\nimport { EncodedPacket, PLACEHOLDER_DATA } from '../packet.js';\nimport { readAscii, readBytes, readU16, readU32, readU64 } from '../reader.js';\nimport { parseId3V2Tag, readId3V2Header } from '../id3.js';\nexport var WaveFormat;\n(function (WaveFormat) {\n    WaveFormat[WaveFormat[\"PCM\"] = 1] = \"PCM\";\n    WaveFormat[WaveFormat[\"IEEE_FLOAT\"] = 3] = \"IEEE_FLOAT\";\n    WaveFormat[WaveFormat[\"ALAW\"] = 6] = \"ALAW\";\n    WaveFormat[WaveFormat[\"MULAW\"] = 7] = \"MULAW\";\n    WaveFormat[WaveFormat[\"EXTENSIBLE\"] = 65534] = \"EXTENSIBLE\";\n})(WaveFormat || (WaveFormat = {}));\nexport class WaveDemuxer extends Demuxer {\n    constructor(input) {\n        super(input);\n        this.metadataPromise = null;\n        this.dataStart = -1;\n        this.dataSize = -1;\n        this.audioInfo = null;\n        this.tracks = [];\n        this.lastKnownPacketIndex = 0;\n        this.metadataTags = {};\n        this.reader = input._reader;\n    }\n    async readMetadata() {\n        return this.metadataPromise ??= (async () => {\n            let slice = this.reader.requestSlice(0, 12);\n            if (slice instanceof Promise)\n                slice = await slice;\n            assert(slice);\n            const riffType = readAscii(slice, 4);\n            const littleEndian = riffType !== 'RIFX';\n            const isRf64 = riffType === 'RF64';\n            const outerChunkSize = readU32(slice, littleEndian);\n            let totalFileSize = isRf64\n                ? this.reader.fileSize\n                : Math.min(outerChunkSize + 8, this.reader.fileSize ?? Infinity);\n            const format = readAscii(slice, 4);\n            if (format !== 'WAVE') {\n                throw new Error('Invalid WAVE file - wrong format');\n            }\n            let chunksRead = 0;\n            let dataChunkSize = null;\n            let currentPos = slice.filePos;\n            while (totalFileSize === null || currentPos < totalFileSize) {\n                let slice = this.reader.requestSlice(currentPos, 8);\n                if (slice instanceof Promise)\n                    slice = await slice;\n                if (!slice)\n                    break;\n                const chunkId = readAscii(slice, 4);\n                const chunkSize = readU32(slice, littleEndian);\n                const startPos = slice.filePos;\n                if (isRf64 && chunksRead === 0 && chunkId !== 'ds64') {\n                    throw new Error('Invalid RF64 file: First chunk must be \"ds64\".');\n                }\n                if (chunkId === 'fmt ') {\n                    await this.parseFmtChunk(startPos, chunkSize, littleEndian);\n                }\n                else if (chunkId === 'data') {\n                    dataChunkSize ??= chunkSize;\n                    this.dataStart = slice.filePos;\n                    this.dataSize = Math.min(dataChunkSize, (totalFileSize ?? Infinity) - this.dataStart);\n                    if (this.reader.fileSize === null) {\n                        break; // Stop once we hit the data chunk\n                    }\n                }\n                else if (chunkId === 'ds64') {\n                    // File and data chunk sizes are defined in here instead\n                    let ds64Slice = this.reader.requestSlice(startPos, chunkSize);\n                    if (ds64Slice instanceof Promise)\n                        ds64Slice = await ds64Slice;\n                    if (!ds64Slice)\n                        break;\n                    const riffChunkSize = readU64(ds64Slice, littleEndian);\n                    dataChunkSize = readU64(ds64Slice, littleEndian);\n                    totalFileSize = Math.min(riffChunkSize + 8, this.reader.fileSize ?? Infinity);\n                }\n                else if (chunkId === 'LIST') {\n                    await this.parseListChunk(startPos, chunkSize, littleEndian);\n                }\n                else if (chunkId === 'ID3 ' || chunkId === 'id3 ') {\n                    await this.parseId3Chunk(startPos, chunkSize);\n                }\n                currentPos = startPos + chunkSize + (chunkSize & 1); // Handle padding\n                chunksRead++;\n            }\n            if (!this.audioInfo) {\n                throw new Error('Invalid WAVE file - missing \"fmt \" chunk');\n            }\n            if (this.dataStart === -1) {\n                throw new Error('Invalid WAVE file - missing \"data\" chunk');\n            }\n            const blockSize = this.audioInfo.blockSizeInBytes;\n            this.dataSize = Math.floor(this.dataSize / blockSize) * blockSize;\n            this.tracks.push(new InputAudioTrack(this.input, new WaveAudioTrackBacking(this)));\n        })();\n    }\n    async parseFmtChunk(startPos, size, littleEndian) {\n        let slice = this.reader.requestSlice(startPos, size);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            return; // File too short\n        let formatTag = readU16(slice, littleEndian);\n        const numChannels = readU16(slice, littleEndian);\n        const sampleRate = readU32(slice, littleEndian);\n        slice.skip(4); // Bytes per second\n        const blockAlign = readU16(slice, littleEndian);\n        let bitsPerSample;\n        if (size === 14) { // Plain WAVEFORMAT\n            bitsPerSample = 8;\n        }\n        else {\n            bitsPerSample = readU16(slice, littleEndian);\n        }\n        // Handle WAVEFORMATEXTENSIBLE\n        if (size >= 18 && formatTag !== 0x0165) {\n            const cbSize = readU16(slice, littleEndian);\n            const remainingSize = size - 18;\n            const extensionSize = Math.min(remainingSize, cbSize);\n            if (extensionSize >= 22 && formatTag === WaveFormat.EXTENSIBLE) {\n                // Parse WAVEFORMATEXTENSIBLE\n                slice.skip(2 + 4);\n                const subFormat = readBytes(slice, 16);\n                // Get actual format from subFormat GUID\n                formatTag = subFormat[0] | (subFormat[1] << 8);\n            }\n        }\n        if (formatTag === WaveFormat.MULAW || formatTag === WaveFormat.ALAW) {\n            bitsPerSample = 8;\n        }\n        this.audioInfo = {\n            format: formatTag,\n            numberOfChannels: numChannels,\n            sampleRate,\n            sampleSizeInBytes: Math.ceil(bitsPerSample / 8),\n            blockSizeInBytes: blockAlign,\n        };\n    }\n    async parseListChunk(startPos, size, littleEndian) {\n        let slice = this.reader.requestSlice(startPos, size);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            return; // File too short\n        const infoType = readAscii(slice, 4);\n        if (infoType !== 'INFO' && infoType !== 'INF0') { // exiftool.org claims INF0 can happen\n            return; // Not an INFO chunk\n        }\n        let currentPos = slice.filePos;\n        while (currentPos <= startPos + size - 8) {\n            slice.filePos = currentPos;\n            const chunkName = readAscii(slice, 4);\n            const chunkSize = readU32(slice, littleEndian);\n            const bytes = readBytes(slice, chunkSize);\n            let stringLength = 0;\n            for (let i = 0; i < bytes.length; i++) {\n                if (bytes[i] === 0) {\n                    break;\n                }\n                stringLength++;\n            }\n            const value = String.fromCharCode(...bytes.subarray(0, stringLength));\n            this.metadataTags.raw ??= {};\n            this.metadataTags.raw[chunkName] = value;\n            switch (chunkName) {\n                case 'INAM':\n                case 'TITL':\n                    {\n                        this.metadataTags.title ??= value;\n                    }\n                    ;\n                    break;\n                case 'TIT3':\n                    {\n                        this.metadataTags.description ??= value;\n                    }\n                    ;\n                    break;\n                case 'IART':\n                    {\n                        this.metadataTags.artist ??= value;\n                    }\n                    ;\n                    break;\n                case 'IPRD':\n                    {\n                        this.metadataTags.album ??= value;\n                    }\n                    ;\n                    break;\n                case 'IPRT':\n                case 'ITRK':\n                case 'TRCK':\n                    {\n                        const parts = value.split('/');\n                        const trackNum = Number.parseInt(parts[0], 10);\n                        const tracksTotal = parts[1] && Number.parseInt(parts[1], 10);\n                        if (Number.isInteger(trackNum) && trackNum > 0) {\n                            this.metadataTags.trackNumber ??= trackNum;\n                        }\n                        if (tracksTotal && Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                            this.metadataTags.tracksTotal ??= tracksTotal;\n                        }\n                    }\n                    ;\n                    break;\n                case 'ICRD':\n                case 'IDIT':\n                    {\n                        const date = new Date(value);\n                        if (!Number.isNaN(date.getTime())) {\n                            this.metadataTags.date ??= date;\n                        }\n                    }\n                    ;\n                    break;\n                case 'YEAR':\n                    {\n                        const year = Number.parseInt(value, 10);\n                        if (Number.isInteger(year) && year > 0) {\n                            this.metadataTags.date ??= new Date(year, 0, 1);\n                        }\n                    }\n                    ;\n                    break;\n                case 'IGNR':\n                case 'GENR':\n                    {\n                        this.metadataTags.genre ??= value;\n                    }\n                    ;\n                    break;\n                case 'ICMT':\n                case 'CMNT':\n                case 'COMM':\n                    {\n                        this.metadataTags.comment ??= value;\n                    }\n                    ;\n                    break;\n            }\n            currentPos += 8 + chunkSize + (chunkSize & 1); // Handle padding\n        }\n    }\n    async parseId3Chunk(startPos, size) {\n        // Parse ID3 tag embedded in WAV file (non-default, but used a lot in practice anyway)\n        let slice = this.reader.requestSlice(startPos, size);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            return; // File too short\n        const id3V2Header = readId3V2Header(slice);\n        if (id3V2Header) {\n            // Extract the content portion (skip the 10-byte header)\n            const contentSlice = slice.slice(startPos + 10, id3V2Header.size);\n            parseId3V2Tag(contentSlice, id3V2Header, this.metadataTags);\n        }\n    }\n    getCodec() {\n        assert(this.audioInfo);\n        if (this.audioInfo.format === WaveFormat.MULAW) {\n            return 'ulaw';\n        }\n        if (this.audioInfo.format === WaveFormat.ALAW) {\n            return 'alaw';\n        }\n        if (this.audioInfo.format === WaveFormat.PCM) {\n            // All formats are little-endian\n            if (this.audioInfo.sampleSizeInBytes === 1) {\n                return 'pcm-u8';\n            }\n            else if (this.audioInfo.sampleSizeInBytes === 2) {\n                return 'pcm-s16';\n            }\n            else if (this.audioInfo.sampleSizeInBytes === 3) {\n                return 'pcm-s24';\n            }\n            else if (this.audioInfo.sampleSizeInBytes === 4) {\n                return 'pcm-s32';\n            }\n        }\n        if (this.audioInfo.format === WaveFormat.IEEE_FLOAT) {\n            if (this.audioInfo.sampleSizeInBytes === 4) {\n                return 'pcm-f32';\n            }\n        }\n        return null;\n    }\n    async getMimeType() {\n        return 'audio/wav';\n    }\n    async computeDuration() {\n        await this.readMetadata();\n        const track = this.tracks[0];\n        assert(track);\n        return track.computeDuration();\n    }\n    async getTracks() {\n        await this.readMetadata();\n        return this.tracks;\n    }\n    async getMetadataTags() {\n        await this.readMetadata();\n        return this.metadataTags;\n    }\n}\nconst PACKET_SIZE_IN_FRAMES = 2048;\nclass WaveAudioTrackBacking {\n    constructor(demuxer) {\n        this.demuxer = demuxer;\n    }\n    getId() {\n        return 1;\n    }\n    getCodec() {\n        return this.demuxer.getCodec();\n    }\n    getInternalCodecId() {\n        assert(this.demuxer.audioInfo);\n        return this.demuxer.audioInfo.format;\n    }\n    async getDecoderConfig() {\n        const codec = this.demuxer.getCodec();\n        if (!codec) {\n            return null;\n        }\n        assert(this.demuxer.audioInfo);\n        return {\n            codec,\n            numberOfChannels: this.demuxer.audioInfo.numberOfChannels,\n            sampleRate: this.demuxer.audioInfo.sampleRate,\n        };\n    }\n    async computeDuration() {\n        const lastPacket = await this.getPacket(Infinity, { metadataOnly: true });\n        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);\n    }\n    getNumberOfChannels() {\n        assert(this.demuxer.audioInfo);\n        return this.demuxer.audioInfo.numberOfChannels;\n    }\n    getSampleRate() {\n        assert(this.demuxer.audioInfo);\n        return this.demuxer.audioInfo.sampleRate;\n    }\n    getTimeResolution() {\n        assert(this.demuxer.audioInfo);\n        return this.demuxer.audioInfo.sampleRate;\n    }\n    getName() {\n        return null;\n    }\n    getLanguageCode() {\n        return UNDETERMINED_LANGUAGE;\n    }\n    getDisposition() {\n        return {\n            ...DEFAULT_TRACK_DISPOSITION,\n        };\n    }\n    async getFirstTimestamp() {\n        return 0;\n    }\n    async getPacketAtIndex(packetIndex, options) {\n        assert(this.demuxer.audioInfo);\n        const startOffset = packetIndex * PACKET_SIZE_IN_FRAMES * this.demuxer.audioInfo.blockSizeInBytes;\n        if (startOffset >= this.demuxer.dataSize) {\n            return null;\n        }\n        const sizeInBytes = Math.min(PACKET_SIZE_IN_FRAMES * this.demuxer.audioInfo.blockSizeInBytes, this.demuxer.dataSize - startOffset);\n        if (this.demuxer.reader.fileSize === null) {\n            // If the file size is unknown, we weren't able to cap the dataSize in the init logic and we instead have to\n            // rely on the headers telling us how large the file is. But, these might be wrong, so let's check if the\n            // requested slice actually exists.\n            let slice = this.demuxer.reader.requestSlice(this.demuxer.dataStart + startOffset, sizeInBytes);\n            if (slice instanceof Promise)\n                slice = await slice;\n            if (!slice) {\n                return null;\n            }\n        }\n        let data;\n        if (options.metadataOnly) {\n            data = PLACEHOLDER_DATA;\n        }\n        else {\n            let slice = this.demuxer.reader.requestSlice(this.demuxer.dataStart + startOffset, sizeInBytes);\n            if (slice instanceof Promise)\n                slice = await slice;\n            assert(slice);\n            data = readBytes(slice, sizeInBytes);\n        }\n        const timestamp = packetIndex * PACKET_SIZE_IN_FRAMES / this.demuxer.audioInfo.sampleRate;\n        const duration = sizeInBytes / this.demuxer.audioInfo.blockSizeInBytes / this.demuxer.audioInfo.sampleRate;\n        this.demuxer.lastKnownPacketIndex = Math.max(packetIndex, timestamp);\n        return new EncodedPacket(data, 'key', timestamp, duration, packetIndex, sizeInBytes);\n    }\n    getFirstPacket(options) {\n        return this.getPacketAtIndex(0, options);\n    }\n    async getPacket(timestamp, options) {\n        assert(this.demuxer.audioInfo);\n        const packetIndex = Math.floor(Math.min(timestamp * this.demuxer.audioInfo.sampleRate / PACKET_SIZE_IN_FRAMES, (this.demuxer.dataSize - 1) / (PACKET_SIZE_IN_FRAMES * this.demuxer.audioInfo.blockSizeInBytes)));\n        const packet = await this.getPacketAtIndex(packetIndex, options);\n        if (packet) {\n            return packet;\n        }\n        if (packetIndex === 0) {\n            return null; // Empty data chunk\n        }\n        assert(this.demuxer.reader.fileSize === null);\n        // The file is shorter than we thought, meaning the packet we were looking for doesn't exist. So, let's find\n        // the last packet by doing a sequential scan, instead.\n        let currentPacket = await this.getPacketAtIndex(this.demuxer.lastKnownPacketIndex, options);\n        while (currentPacket) {\n            const nextPacket = await this.getNextPacket(currentPacket, options);\n            if (!nextPacket) {\n                break;\n            }\n            currentPacket = nextPacket;\n        }\n        return currentPacket;\n    }\n    getNextPacket(packet, options) {\n        assert(this.demuxer.audioInfo);\n        const packetIndex = Math.round(packet.timestamp * this.demuxer.audioInfo.sampleRate / PACKET_SIZE_IN_FRAMES);\n        return this.getPacketAtIndex(packetIndex + 1, options);\n    }\n    getKeyPacket(timestamp, options) {\n        return this.getPacket(timestamp, options);\n    }\n    getNextKeyPacket(packet, options) {\n        return this.getNextPacket(packet, options);\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Bitstream } from '../misc.js';\nimport { readBytes } from '../reader.js';\nexport const MIN_FRAME_HEADER_SIZE = 7;\nexport const MAX_FRAME_HEADER_SIZE = 9;\nexport const readFrameHeader = (slice) => {\n    // https://wiki.multimedia.cx/index.php/ADTS (last visited: 2025/08/17)\n    const startPos = slice.filePos;\n    const bytes = readBytes(slice, 9); // 9 with CRC, 7 without CRC\n    const bitstream = new Bitstream(bytes);\n    const syncword = bitstream.readBits(12);\n    if (syncword !== 0b1111_11111111) {\n        return null;\n    }\n    bitstream.skipBits(1); // MPEG version\n    const layer = bitstream.readBits(2);\n    if (layer !== 0) {\n        return null;\n    }\n    const protectionAbsence = bitstream.readBits(1);\n    const objectType = bitstream.readBits(2) + 1;\n    const samplingFrequencyIndex = bitstream.readBits(4);\n    if (samplingFrequencyIndex === 15) {\n        return null;\n    }\n    bitstream.skipBits(1); // Private bit\n    const channelConfiguration = bitstream.readBits(3);\n    if (channelConfiguration === 0) {\n        throw new Error('ADTS frames with channel configuration 0 are not supported.');\n    }\n    bitstream.skipBits(1); // Originality\n    bitstream.skipBits(1); // Home\n    bitstream.skipBits(1); // Copyright ID bit\n    bitstream.skipBits(1); // Copyright ID start\n    const frameLength = bitstream.readBits(13);\n    bitstream.skipBits(11); // Buffer fullness\n    const numberOfAacFrames = bitstream.readBits(2) + 1;\n    if (numberOfAacFrames !== 1) {\n        throw new Error('ADTS frames with more than one AAC frame are not supported.');\n    }\n    let crcCheck = null;\n    if (protectionAbsence === 1) { // No CRC\n        slice.filePos -= 2;\n    }\n    else { // CRC\n        crcCheck = bitstream.readBits(16);\n    }\n    return {\n        objectType,\n        samplingFrequencyIndex,\n        channelConfiguration,\n        frameLength,\n        numberOfAacFrames,\n        crcCheck,\n        startPos,\n    };\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { aacChannelMap, aacFrequencyTable } from '../codec.js';\nimport { Demuxer } from '../demuxer.js';\nimport { InputAudioTrack } from '../input-track.js';\nimport { assert, AsyncMutex, binarySearchExact, binarySearchLessOrEqual, Bitstream, UNDETERMINED_LANGUAGE, } from '../misc.js';\nimport { EncodedPacket, PLACEHOLDER_DATA } from '../packet.js';\nimport { readBytes } from '../reader.js';\nimport { DEFAULT_TRACK_DISPOSITION } from '../metadata.js';\nimport { MAX_FRAME_HEADER_SIZE, MIN_FRAME_HEADER_SIZE, readFrameHeader } from './adts-reader.js';\nconst SAMPLES_PER_AAC_FRAME = 1024;\nexport class AdtsDemuxer extends Demuxer {\n    constructor(input) {\n        super(input);\n        this.metadataPromise = null;\n        this.firstFrameHeader = null;\n        this.loadedSamples = [];\n        this.tracks = [];\n        this.readingMutex = new AsyncMutex();\n        this.lastSampleLoaded = false;\n        this.lastLoadedPos = 0;\n        this.nextTimestampInSamples = 0;\n        this.reader = input._reader;\n    }\n    async readMetadata() {\n        return this.metadataPromise ??= (async () => {\n            // Keep loading until we find the first frame header\n            while (!this.firstFrameHeader && !this.lastSampleLoaded) {\n                await this.advanceReader();\n            }\n            // There has to be a frame if this demuxer got selected\n            assert(this.firstFrameHeader);\n            // Create the single audio track\n            this.tracks = [new InputAudioTrack(this.input, new AdtsAudioTrackBacking(this))];\n        })();\n    }\n    async advanceReader() {\n        let slice = this.reader.requestSliceRange(this.lastLoadedPos, MIN_FRAME_HEADER_SIZE, MAX_FRAME_HEADER_SIZE);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice) {\n            this.lastSampleLoaded = true;\n            return;\n        }\n        const header = readFrameHeader(slice);\n        if (!header) {\n            this.lastSampleLoaded = true;\n            return;\n        }\n        if (this.reader.fileSize !== null && header.startPos + header.frameLength > this.reader.fileSize) {\n            // Frame doesn't fit in the rest of the file\n            this.lastSampleLoaded = true;\n            return;\n        }\n        if (!this.firstFrameHeader) {\n            this.firstFrameHeader = header;\n        }\n        const sampleRate = aacFrequencyTable[header.samplingFrequencyIndex];\n        assert(sampleRate !== undefined);\n        const sampleDuration = SAMPLES_PER_AAC_FRAME / sampleRate;\n        const headerSize = header.crcCheck ? MAX_FRAME_HEADER_SIZE : MIN_FRAME_HEADER_SIZE;\n        const sample = {\n            timestamp: this.nextTimestampInSamples / sampleRate,\n            duration: sampleDuration,\n            dataStart: header.startPos + headerSize,\n            dataSize: header.frameLength - headerSize,\n        };\n        this.loadedSamples.push(sample);\n        this.nextTimestampInSamples += SAMPLES_PER_AAC_FRAME;\n        this.lastLoadedPos = header.startPos + header.frameLength;\n    }\n    async getMimeType() {\n        return 'audio/aac';\n    }\n    async getTracks() {\n        await this.readMetadata();\n        return this.tracks;\n    }\n    async computeDuration() {\n        await this.readMetadata();\n        const track = this.tracks[0];\n        assert(track);\n        return track.computeDuration();\n    }\n    async getMetadataTags() {\n        return {}; // No tags in this one\n    }\n}\nclass AdtsAudioTrackBacking {\n    constructor(demuxer) {\n        this.demuxer = demuxer;\n    }\n    getId() {\n        return 1;\n    }\n    async getFirstTimestamp() {\n        return 0;\n    }\n    getTimeResolution() {\n        const sampleRate = this.getSampleRate();\n        return sampleRate / SAMPLES_PER_AAC_FRAME;\n    }\n    async computeDuration() {\n        const lastPacket = await this.getPacket(Infinity, { metadataOnly: true });\n        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);\n    }\n    getName() {\n        return null;\n    }\n    getLanguageCode() {\n        return UNDETERMINED_LANGUAGE;\n    }\n    getCodec() {\n        return 'aac';\n    }\n    getInternalCodecId() {\n        assert(this.demuxer.firstFrameHeader);\n        return this.demuxer.firstFrameHeader.objectType;\n    }\n    getNumberOfChannels() {\n        assert(this.demuxer.firstFrameHeader);\n        const numberOfChannels = aacChannelMap[this.demuxer.firstFrameHeader.channelConfiguration];\n        assert(numberOfChannels !== undefined);\n        return numberOfChannels;\n    }\n    getSampleRate() {\n        assert(this.demuxer.firstFrameHeader);\n        const sampleRate = aacFrequencyTable[this.demuxer.firstFrameHeader.samplingFrequencyIndex];\n        assert(sampleRate !== undefined);\n        return sampleRate;\n    }\n    getDisposition() {\n        return {\n            ...DEFAULT_TRACK_DISPOSITION,\n        };\n    }\n    async getDecoderConfig() {\n        assert(this.demuxer.firstFrameHeader);\n        const bytes = new Uint8Array(3); // 19 bits max\n        const bitstream = new Bitstream(bytes);\n        const { objectType, samplingFrequencyIndex, channelConfiguration } = this.demuxer.firstFrameHeader;\n        if (objectType > 31) {\n            bitstream.writeBits(5, 31);\n            bitstream.writeBits(6, objectType - 32);\n        }\n        else {\n            bitstream.writeBits(5, objectType);\n        }\n        bitstream.writeBits(4, samplingFrequencyIndex); // samplingFrequencyIndex === 15 is forbidden\n        bitstream.writeBits(4, channelConfiguration);\n        return {\n            codec: `mp4a.40.${this.demuxer.firstFrameHeader.objectType}`,\n            numberOfChannels: this.getNumberOfChannels(),\n            sampleRate: this.getSampleRate(),\n            description: bytes.subarray(0, Math.ceil((bitstream.pos - 1) / 8)),\n        };\n    }\n    async getPacketAtIndex(sampleIndex, options) {\n        if (sampleIndex === -1) {\n            return null;\n        }\n        const rawSample = this.demuxer.loadedSamples[sampleIndex];\n        if (!rawSample) {\n            return null;\n        }\n        let data;\n        if (options.metadataOnly) {\n            data = PLACEHOLDER_DATA;\n        }\n        else {\n            let slice = this.demuxer.reader.requestSlice(rawSample.dataStart, rawSample.dataSize);\n            if (slice instanceof Promise)\n                slice = await slice;\n            if (!slice) {\n                return null; // Data didn't fit into the rest of the file\n            }\n            data = readBytes(slice, rawSample.dataSize);\n        }\n        return new EncodedPacket(data, 'key', rawSample.timestamp, rawSample.duration, sampleIndex, rawSample.dataSize);\n    }\n    getFirstPacket(options) {\n        return this.getPacketAtIndex(0, options);\n    }\n    async getNextPacket(packet, options) {\n        const release = await this.demuxer.readingMutex.acquire();\n        try {\n            const sampleIndex = binarySearchExact(this.demuxer.loadedSamples, packet.timestamp, x => x.timestamp);\n            if (sampleIndex === -1) {\n                throw new Error('Packet was not created from this track.');\n            }\n            const nextIndex = sampleIndex + 1;\n            // Ensure the next sample exists\n            while (nextIndex >= this.demuxer.loadedSamples.length\n                && !this.demuxer.lastSampleLoaded) {\n                await this.demuxer.advanceReader();\n            }\n            return this.getPacketAtIndex(nextIndex, options);\n        }\n        finally {\n            release();\n        }\n    }\n    async getPacket(timestamp, options) {\n        const release = await this.demuxer.readingMutex.acquire();\n        try {\n            while (true) {\n                const index = binarySearchLessOrEqual(this.demuxer.loadedSamples, timestamp, x => x.timestamp);\n                if (index === -1 && this.demuxer.loadedSamples.length > 0) {\n                    // We're before the first sample\n                    return null;\n                }\n                if (this.demuxer.lastSampleLoaded) {\n                    // All data is loaded, return what we found\n                    return this.getPacketAtIndex(index, options);\n                }\n                if (index >= 0 && index + 1 < this.demuxer.loadedSamples.length) {\n                    // The next packet also exists, we're done\n                    return this.getPacketAtIndex(index, options);\n                }\n                // Otherwise, keep loading data\n                await this.demuxer.advanceReader();\n            }\n        }\n        finally {\n            release();\n        }\n    }\n    getKeyPacket(timestamp, options) {\n        return this.getPacket(timestamp, options);\n    }\n    getNextKeyPacket(packet, options) {\n        return this.getNextPacket(packet, options);\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert, assertNever, Bitstream } from '../misc.js';\nimport { readBytes, readU16Be, readU8 } from '../reader.js';\n// https://www.rfc-editor.org/rfc/rfc9639.html#name-block-size-bits\nexport const getBlockSizeOrUncommon = (bits) => {\n    if (bits === 0b0000) {\n        return null;\n    }\n    else if (bits === 0b0001) {\n        return 192;\n    }\n    else if (bits >= 0b0010 && bits <= 0b0101) {\n        return 144 * 2 ** bits;\n    }\n    else if (bits === 0b0110) {\n        return 'uncommon-u8';\n    }\n    else if (bits === 0b0111) {\n        return 'uncommon-u16';\n    }\n    else if (bits >= 0b1000 && bits <= 0b1111) {\n        return 2 ** bits;\n    }\n    else {\n        return null;\n    }\n};\n// https://www.rfc-editor.org/rfc/rfc9639.html#name-sample-rate-bits\nexport const getSampleRateOrUncommon = (sampleRateBits, streamInfoSampleRate) => {\n    switch (sampleRateBits) {\n        case 0b0000: return streamInfoSampleRate;\n        case 0b0001: return 88200;\n        case 0b0010: return 176400;\n        case 0b0011: return 192000;\n        case 0b0100: return 8000;\n        case 0b0101: return 16000;\n        case 0b0110: return 22050;\n        case 0b0111: return 24000;\n        case 0b1000: return 32000;\n        case 0b1001: return 44100;\n        case 0b1010: return 48000;\n        case 0b1011: return 96000;\n        case 0b1100: return 'uncommon-u8';\n        case 0b1101: return 'uncommon-u16';\n        case 0b1110: return 'uncommon-u16-10';\n        default: return null;\n    }\n};\n// https://www.rfc-editor.org/rfc/rfc9639.html#name-coded-number\nexport const readCodedNumber = (fileSlice) => {\n    let ones = 0;\n    const bitstream1 = new Bitstream(readBytes(fileSlice, 1));\n    while (bitstream1.readBits(1) === 1) {\n        ones++;\n    }\n    if (ones === 0) {\n        return bitstream1.readBits(7);\n    }\n    const bitArray = [];\n    const extraBytes = ones - 1;\n    const bitstream2 = new Bitstream(readBytes(fileSlice, extraBytes));\n    const firstByteBits = 8 - ones - 1;\n    for (let i = 0; i < firstByteBits; i++) {\n        bitArray.unshift(bitstream1.readBits(1));\n    }\n    for (let i = 0; i < extraBytes; i++) {\n        for (let j = 0; j < 8; j++) {\n            const val = bitstream2.readBits(1);\n            if (j < 2) {\n                continue;\n            }\n            bitArray.unshift(val);\n        }\n    }\n    const encoded = bitArray.reduce((acc, bit, index) => {\n        return acc | (bit << index);\n    }, 0);\n    return encoded;\n};\nexport const readBlockSize = (slice, blockSizeBits) => {\n    if (blockSizeBits === 'uncommon-u16') {\n        return readU16Be(slice) + 1;\n    }\n    else if (blockSizeBits === 'uncommon-u8') {\n        return readU8(slice) + 1;\n    }\n    else if (typeof blockSizeBits === 'number') {\n        return blockSizeBits;\n    }\n    else {\n        assertNever(blockSizeBits);\n        assert(false);\n    }\n};\nexport const readSampleRate = (slice, sampleRateOrUncommon) => {\n    if (sampleRateOrUncommon === 'uncommon-u16') {\n        return readU16Be(slice);\n    }\n    if (sampleRateOrUncommon === 'uncommon-u16-10') {\n        return readU16Be(slice) * 10;\n    }\n    if (sampleRateOrUncommon === 'uncommon-u8') {\n        return readU8(slice);\n    }\n    if (typeof sampleRateOrUncommon === 'number') {\n        return sampleRateOrUncommon;\n    }\n    return null;\n};\n// https://www.rfc-editor.org/rfc/rfc9639.html#section-9.1.1\nexport const calculateCrc8 = (data) => {\n    const polynomial = 0x07; // x^8 + x^2 + x^1 + x^0\n    let crc = 0x00; // Initialize CRC to 0\n    for (const byte of data) {\n        crc ^= byte; // XOR byte into least significant byte of crc\n        for (let i = 0; i < 8; i++) {\n            // For each bit in the byte\n            if ((crc & 0x80) !== 0) {\n                // If the leftmost bit (MSB) is set\n                crc = (crc << 1) ^ polynomial; // Shift left and XOR with polynomial\n            }\n            else {\n                crc <<= 1; // Just shift left\n            }\n            crc &= 0xff; // Ensure CRC remains 8-bit\n        }\n    }\n    return crc;\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { FlacBlockType, readVorbisComments } from '../codec-data.js';\nimport { Demuxer } from '../demuxer.js';\nimport { InputAudioTrack } from '../input-track.js';\nimport { assert, AsyncMutex, binarySearchLessOrEqual, Bitstream, textDecoder, UNDETERMINED_LANGUAGE, } from '../misc.js';\nimport { EncodedPacket, PLACEHOLDER_DATA } from '../packet.js';\nimport { readBytes, readU24Be, readU32Be, readU8, } from '../reader.js';\nimport { DEFAULT_TRACK_DISPOSITION } from '../metadata.js';\nimport { calculateCrc8, readBlockSize, getBlockSizeOrUncommon, readCodedNumber, readSampleRate, getSampleRateOrUncommon, } from './flac-misc.js';\nexport class FlacDemuxer extends Demuxer {\n    constructor(input) {\n        super(input);\n        this.loadedSamples = []; // All samples from the start of the file to lastLoadedPos\n        this.metadataPromise = null;\n        this.track = null;\n        this.metadataTags = {};\n        this.audioInfo = null;\n        this.lastLoadedPos = null;\n        this.blockingBit = null;\n        this.readingMutex = new AsyncMutex();\n        this.lastSampleLoaded = false;\n        this.reader = input._reader;\n    }\n    async computeDuration() {\n        await this.readMetadata();\n        assert(this.track);\n        return this.track.computeDuration();\n    }\n    async getMetadataTags() {\n        await this.readMetadata();\n        return this.metadataTags;\n    }\n    async getTracks() {\n        await this.readMetadata();\n        assert(this.track);\n        return [this.track];\n    }\n    async getMimeType() {\n        return 'audio/flac';\n    }\n    async readMetadata() {\n        let currentPos = 4; // Skip 'fLaC'\n        return (this.metadataPromise ??= (async () => {\n            while (this.reader.fileSize === null\n                || currentPos < this.reader.fileSize) {\n                let sizeSlice = this.reader.requestSlice(currentPos, 4);\n                if (sizeSlice instanceof Promise)\n                    sizeSlice = await sizeSlice;\n                currentPos += 4;\n                if (sizeSlice === null) {\n                    throw new Error(`Metadata block at position ${currentPos} is too small! Corrupted file.`);\n                }\n                assert(sizeSlice);\n                const byte = readU8(sizeSlice); // first bit: isLastMetadata, remaining 7 bits: metaBlockType\n                const size = readU24Be(sizeSlice);\n                const isLastMetadata = (byte & 0x80) !== 0;\n                const metaBlockType = byte & 0x7f;\n                switch (metaBlockType) {\n                    case FlacBlockType.STREAMINFO: {\n                        // Parse streaminfo block\n                        // https://www.rfc-editor.org/rfc/rfc9639.html#section-8.2\n                        let streamInfoBlock = this.reader.requestSlice(currentPos, size);\n                        if (streamInfoBlock instanceof Promise)\n                            streamInfoBlock = await streamInfoBlock;\n                        assert(streamInfoBlock);\n                        if (streamInfoBlock === null) {\n                            throw new Error(`StreamInfo block at position ${currentPos} is too small! Corrupted file.`);\n                        }\n                        const streamInfoBytes = readBytes(streamInfoBlock, 34);\n                        const bitstream = new Bitstream(streamInfoBytes);\n                        const minimumBlockSize = bitstream.readBits(16);\n                        const maximumBlockSize = bitstream.readBits(16);\n                        const minimumFrameSize = bitstream.readBits(24);\n                        const maximumFrameSize = bitstream.readBits(24);\n                        const sampleRate = bitstream.readBits(20);\n                        const numberOfChannels = bitstream.readBits(3) + 1;\n                        bitstream.readBits(5); // bitsPerSample - 1\n                        const totalSamples = bitstream.readBits(36);\n                        // https://www.w3.org/TR/webcodecs-flac-codec-registration/#audiodecoderconfig-description\n                        // description is required, and has to be the following:\n                        // 1. The bytes 0x66 0x4C 0x61 0x43 (\"fLaC\" in ASCII)\n                        // 2. A metadata block (called the STREAMINFO block) as described in section 7 of [FLAC]\n                        // 3. Optionaly (sic) other metadata blocks, that are not used by the specification\n                        bitstream.skipBits(16 * 8); // md5 hash\n                        const description = new Uint8Array(42);\n                        // 1. \"fLaC\"\n                        description.set(new Uint8Array([0x66, 0x4c, 0x61, 0x43]), 0);\n                        // 2. STREAMINFO block\n                        description.set(new Uint8Array([128, 0, 0, 34]), 4);\n                        // 3. Other metadata blocks\n                        description.set(streamInfoBytes, 8);\n                        this.audioInfo = {\n                            numberOfChannels,\n                            sampleRate,\n                            totalSamples,\n                            minimumBlockSize,\n                            maximumBlockSize,\n                            minimumFrameSize,\n                            maximumFrameSize,\n                            description,\n                        };\n                        this.track = new InputAudioTrack(this.input, new FlacAudioTrackBacking(this));\n                        break;\n                    }\n                    case FlacBlockType.VORBIS_COMMENT: {\n                        // Parse vorbis comment block\n                        // https://www.rfc-editor.org/rfc/rfc9639.html#name-vorbis-comment\n                        let vorbisCommentBlock = this.reader.requestSlice(currentPos, size);\n                        if (vorbisCommentBlock instanceof Promise)\n                            vorbisCommentBlock = await vorbisCommentBlock;\n                        assert(vorbisCommentBlock);\n                        readVorbisComments(readBytes(vorbisCommentBlock, size), this.metadataTags);\n                        break;\n                    }\n                    case FlacBlockType.PICTURE: {\n                        // Parse picture block\n                        // https://www.rfc-editor.org/rfc/rfc9639.html#name-picture\n                        let pictureBlock = this.reader.requestSlice(currentPos, size);\n                        if (pictureBlock instanceof Promise)\n                            pictureBlock = await pictureBlock;\n                        assert(pictureBlock);\n                        const pictureType = readU32Be(pictureBlock);\n                        const mediaTypeLength = readU32Be(pictureBlock);\n                        const mediaType = textDecoder.decode(readBytes(pictureBlock, mediaTypeLength));\n                        const descriptionLength = readU32Be(pictureBlock);\n                        const description = textDecoder.decode(readBytes(pictureBlock, descriptionLength));\n                        pictureBlock.skip(4 + 4 + 4 + 4); // Skip width, height, color depth, number of indexed colors\n                        const dataLength = readU32Be(pictureBlock);\n                        const data = readBytes(pictureBlock, dataLength);\n                        this.metadataTags.images ??= [];\n                        this.metadataTags.images.push({\n                            data,\n                            mimeType: mediaType,\n                            // https://www.rfc-editor.org/rfc/rfc9639.html#table13\n                            kind: pictureType === 3\n                                ? 'coverFront'\n                                : pictureType === 4\n                                    ? 'coverBack'\n                                    : 'unknown',\n                            description,\n                        });\n                        break;\n                    }\n                    default:\n                        break;\n                }\n                currentPos += size;\n                if (isLastMetadata) {\n                    this.lastLoadedPos = currentPos;\n                    break;\n                }\n            }\n        })());\n    }\n    async readNextFlacFrame({ startPos, isFirstPacket, }) {\n        assert(this.audioInfo);\n        // we expect that there are at least `minimumFrameSize` bytes left in the file\n        // Ideally we also want to validate the next header is valid\n        // to throw out an accidential sync word\n        // The shortest valid FLAC header I can think of, based off the code\n        // of readFlacFrameHeader:\n        // 4 bytes used for bitstream from syncword to bit depth\n        // 1 byte coded number\n        // (uncommon values, no bytes read)\n        // 1 byte crc\n        // --> 6 bytes\n        const minimumHeaderLength = 6;\n        // If we read everything in readFlacFrameHeader, we read 16 bytes\n        const maximumHeaderSize = 16;\n        const maximumSliceLength = this.audioInfo.maximumFrameSize + maximumHeaderSize;\n        const slice = await this.reader.requestSliceRange(startPos, this.audioInfo.minimumFrameSize, maximumSliceLength);\n        if (!slice) {\n            return null;\n        }\n        const frameHeader = this.readFlacFrameHeader({\n            slice,\n            isFirstPacket: isFirstPacket,\n        });\n        if (!frameHeader) {\n            return null;\n        }\n        // We don't know exactly how long the packet is, we only know the `minimumFrameSize` and `maximumFrameSize`\n        // The packet is over if the next 2 bytes are the sync word followed by a valid header\n        // or the end of the file is reached\n        // The next sync word is expected at earliest when `minimumFrameSize` is reached,\n        // we can skip over anything before that\n        slice.filePos = startPos + this.audioInfo.minimumFrameSize;\n        while (true) {\n            // Reached end of the file, packet is over\n            if (slice.filePos > slice.end - minimumHeaderLength) {\n                return {\n                    num: frameHeader.num,\n                    blockSize: frameHeader.blockSize,\n                    sampleRate: frameHeader.sampleRate,\n                    size: slice.end - startPos,\n                    isLastFrame: true,\n                };\n            }\n            const nextByte = readU8(slice);\n            if (nextByte === 0xff) {\n                const positionBeforeReading = slice.filePos;\n                const byteAfterNextByte = readU8(slice);\n                const expected = this.blockingBit === 1 ? 0b1111_1001 : 0b1111_1000;\n                if (byteAfterNextByte !== expected) {\n                    slice.filePos = positionBeforeReading;\n                    continue;\n                }\n                slice.skip(-2);\n                const lengthIfNextFlacFrameHeaderIsLegit = slice.filePos - startPos;\n                const nextFrameHeader = this.readFlacFrameHeader({\n                    slice,\n                    isFirstPacket: false,\n                });\n                if (!nextFrameHeader) {\n                    slice.filePos = positionBeforeReading;\n                    continue;\n                }\n                // Ensure the frameOrSampleNum is consecutive.\n                // https://github.com/Vanilagy/mediabunny/issues/194\n                if (this.blockingBit === 0) {\n                    // Case A: If the stream is fixed block size, this is the frame number, which increments by 1\n                    if (nextFrameHeader.num - frameHeader.num !== 1) {\n                        slice.filePos = positionBeforeReading;\n                        continue;\n                    }\n                }\n                else {\n                    // Case B: If the stream is variable block size, this is the sample number, which increments by\n                    // amount of samples in a frame.\n                    if (nextFrameHeader.num - frameHeader.num !== frameHeader.blockSize) {\n                        slice.filePos = positionBeforeReading;\n                        continue;\n                    }\n                }\n                return {\n                    num: frameHeader.num,\n                    blockSize: frameHeader.blockSize,\n                    sampleRate: frameHeader.sampleRate,\n                    size: lengthIfNextFlacFrameHeaderIsLegit,\n                    isLastFrame: false,\n                };\n            }\n        }\n    }\n    readFlacFrameHeader({ slice, isFirstPacket, }) {\n        // In this function, generally it is not safe to throw errors.\n        // We might end up here because we stumbled upon a syncword,\n        // but the data might not actually be a FLAC frame, it might be random bitstream\n        // data, in that case we should return null and continue.\n        const startOffset = slice.filePos;\n        // https://www.rfc-editor.org/rfc/rfc9639.html#section-9.1\n        // Each frame MUST start on a byte boundary and start with the 15-bit frame\n        // sync code 0b111111111111100. Following the sync code is the blocking strategy\n        // bit, which MUST NOT change during the audio stream.\n        const bytes = readBytes(slice, 4);\n        const bitstream = new Bitstream(bytes);\n        const bits = bitstream.readBits(15);\n        if (bits !== 0b111111111111100) {\n            // This cannot be a valid FLAC frame, must start with the syncword\n            return null;\n        }\n        if (this.blockingBit === null) {\n            assert(isFirstPacket);\n            const newBlockingBit = bitstream.readBits(1);\n            this.blockingBit = newBlockingBit;\n        }\n        else if (this.blockingBit === 1) {\n            assert(!isFirstPacket);\n            const newBlockingBit = bitstream.readBits(1);\n            if (newBlockingBit !== 1) {\n                // This cannot be a valid FLAC frame, expected 1 but got 0\n                return null;\n            }\n        }\n        else if (this.blockingBit === 0) {\n            assert(!isFirstPacket);\n            const newBlockingBit = bitstream.readBits(1);\n            if (newBlockingBit !== 0) {\n                // This cannot be a valid FLAC frame, expected 0 but got 1\n                return null;\n            }\n        }\n        else {\n            throw new Error('Invalid blocking bit');\n        }\n        const blockSizeOrUncommon = getBlockSizeOrUncommon(bitstream.readBits(4));\n        if (!blockSizeOrUncommon) {\n            // This cannot be a valid FLAC frame, the syncword was just coincidental\n            return null;\n        }\n        assert(this.audioInfo);\n        const sampleRateOrUncommon = getSampleRateOrUncommon(bitstream.readBits(4), this.audioInfo.sampleRate);\n        if (!sampleRateOrUncommon) {\n            // This cannot be a valid FLAC frame, the syncword was just coincidental\n            return null;\n        }\n        bitstream.readBits(4); // channel count\n        bitstream.readBits(3); // bit depth\n        const reservedZero = bitstream.readBits(1); // reserved zero\n        if (reservedZero !== 0) {\n            // This cannot be a valid FLAC frame, the syncword was just coincidental\n            return null;\n        }\n        const num = readCodedNumber(slice);\n        const blockSize = readBlockSize(slice, blockSizeOrUncommon);\n        const sampleRate = readSampleRate(slice, sampleRateOrUncommon);\n        if (sampleRate === null) {\n            // This cannot be a valid FLAC frame, the syncword was just coincidental\n            return null;\n        }\n        if (sampleRate !== this.audioInfo.sampleRate) {\n            // This cannot be a valid FLAC frame, the sample rate is not the same as in the stream info\n            return null;\n        }\n        const size = slice.filePos - startOffset;\n        const crc = readU8(slice);\n        slice.skip(-size);\n        slice.skip(-1);\n        const crcCalculated = calculateCrc8(readBytes(slice, size));\n        if (crc !== crcCalculated) {\n            // Maybe this wasn't a FLAC frame at all, the syncword was just coincidentally\n            // in the bitstream\n            return null;\n        }\n        return { num, blockSize, sampleRate };\n    }\n    async advanceReader() {\n        await this.readMetadata();\n        assert(this.lastLoadedPos !== null);\n        assert(this.audioInfo);\n        const startPos = this.lastLoadedPos;\n        const frame = await this.readNextFlacFrame({\n            startPos,\n            isFirstPacket: this.loadedSamples.length === 0,\n        });\n        if (!frame) {\n            // Unexpected case, failed to read next FLAC frame\n            // handling gracefully\n            this.lastSampleLoaded = true;\n            return;\n        }\n        const lastSample = this.loadedSamples[this.loadedSamples.length - 1];\n        const blockOffset = lastSample\n            ? lastSample.blockOffset + lastSample.blockSize\n            : 0;\n        const sample = {\n            blockOffset,\n            blockSize: frame.blockSize,\n            byteOffset: startPos,\n            byteSize: frame.size,\n        };\n        this.lastLoadedPos = this.lastLoadedPos + frame.size;\n        this.loadedSamples.push(sample);\n        if (frame.isLastFrame) {\n            this.lastSampleLoaded = true;\n            return;\n        }\n    }\n}\nclass FlacAudioTrackBacking {\n    constructor(demuxer) {\n        this.demuxer = demuxer;\n    }\n    getId() {\n        return 1;\n    }\n    getCodec() {\n        return 'flac';\n    }\n    getInternalCodecId() {\n        return null;\n    }\n    getNumberOfChannels() {\n        assert(this.demuxer.audioInfo);\n        return this.demuxer.audioInfo.numberOfChannels;\n    }\n    async computeDuration() {\n        const lastPacket = await this.getPacket(Infinity, { metadataOnly: true });\n        return (lastPacket?.timestamp ?? 0) + (lastPacket?.duration ?? 0);\n    }\n    getSampleRate() {\n        assert(this.demuxer.audioInfo);\n        return this.demuxer.audioInfo.sampleRate;\n    }\n    getName() {\n        return null;\n    }\n    getLanguageCode() {\n        return UNDETERMINED_LANGUAGE;\n    }\n    getTimeResolution() {\n        assert(this.demuxer.audioInfo);\n        return this.demuxer.audioInfo.sampleRate;\n    }\n    getDisposition() {\n        return {\n            ...DEFAULT_TRACK_DISPOSITION,\n        };\n    }\n    async getFirstTimestamp() {\n        return 0;\n    }\n    async getDecoderConfig() {\n        assert(this.demuxer.audioInfo);\n        return {\n            codec: 'flac',\n            numberOfChannels: this.demuxer.audioInfo.numberOfChannels,\n            sampleRate: this.demuxer.audioInfo.sampleRate,\n            description: this.demuxer.audioInfo.description,\n        };\n    }\n    async getPacket(timestamp, options) {\n        assert(this.demuxer.audioInfo);\n        if (timestamp < 0) {\n            throw new Error('Timestamp cannot be negative');\n        }\n        const release = await this.demuxer.readingMutex.acquire();\n        try {\n            while (true) {\n                const packetIndex = binarySearchLessOrEqual(this.demuxer.loadedSamples, timestamp, x => x.blockOffset / this.demuxer.audioInfo.sampleRate);\n                if (packetIndex === -1) {\n                    await this.demuxer.advanceReader();\n                    continue;\n                }\n                const packet = this.demuxer.loadedSamples[packetIndex];\n                const sampleTimestamp = packet.blockOffset / this.demuxer.audioInfo.sampleRate;\n                const sampleDuration = packet.blockSize / this.demuxer.audioInfo.sampleRate;\n                if (sampleTimestamp + sampleDuration <= timestamp) {\n                    if (this.demuxer.lastSampleLoaded) {\n                        return this.getPacketAtIndex(this.demuxer.loadedSamples.length - 1, options);\n                    }\n                    await this.demuxer.advanceReader();\n                    continue;\n                }\n                return this.getPacketAtIndex(packetIndex, options);\n            }\n        }\n        finally {\n            release();\n        }\n    }\n    async getNextPacket(packet, options) {\n        const release = await this.demuxer.readingMutex.acquire();\n        try {\n            const nextIndex = packet.sequenceNumber + 1;\n            if (this.demuxer.lastSampleLoaded\n                && nextIndex >= this.demuxer.loadedSamples.length) {\n                return null;\n            }\n            // Ensure the next sample exists\n            while (nextIndex >= this.demuxer.loadedSamples.length\n                && !this.demuxer.lastSampleLoaded) {\n                await this.demuxer.advanceReader();\n            }\n            return this.getPacketAtIndex(nextIndex, options);\n        }\n        finally {\n            release();\n        }\n    }\n    getKeyPacket(timestamp, options) {\n        return this.getPacket(timestamp, options);\n    }\n    getNextKeyPacket(packet, options) {\n        return this.getNextPacket(packet, options);\n    }\n    async getPacketAtIndex(sampleIndex, options) {\n        const rawSample = this.demuxer.loadedSamples[sampleIndex];\n        if (!rawSample) {\n            return null;\n        }\n        let data;\n        if (options.metadataOnly) {\n            data = PLACEHOLDER_DATA;\n        }\n        else {\n            let slice = this.demuxer.reader.requestSlice(rawSample.byteOffset, rawSample.byteSize);\n            if (slice instanceof Promise)\n                slice = await slice;\n            if (!slice) {\n                return null; // Data didn't fit into the rest of the file\n            }\n            data = readBytes(slice, rawSample.byteSize);\n        }\n        assert(this.demuxer.audioInfo);\n        const timestamp = rawSample.blockOffset / this.demuxer.audioInfo.sampleRate;\n        const duration = rawSample.blockSize / this.demuxer.audioInfo.sampleRate;\n        return new EncodedPacket(data, 'key', timestamp, duration, sampleIndex, rawSample.byteSize);\n    }\n    async getFirstPacket(options) {\n        // Ensure the next sample exists\n        while (this.demuxer.loadedSamples.length === 0\n            && !this.demuxer.lastSampleLoaded) {\n            await this.demuxer.advanceReader();\n        }\n        return this.getPacketAtIndex(0, options);\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { IsobmffDemuxer } from './isobmff/isobmff-demuxer.js';\nimport { EBMLId, MAX_HEADER_SIZE, MIN_HEADER_SIZE, readAsciiString, readElementHeader, readElementSize, readUnsignedInt, readVarIntSize, } from './matroska/ebml.js';\nimport { MatroskaDemuxer } from './matroska/matroska-demuxer.js';\nimport { Mp3Demuxer } from './mp3/mp3-demuxer.js';\nimport { FRAME_HEADER_SIZE } from '../shared/mp3-misc.js';\nimport { ID3_V2_HEADER_SIZE, readId3V2Header } from './id3.js';\nimport { readNextFrameHeader } from './mp3/mp3-reader.js';\nimport { OggDemuxer } from './ogg/ogg-demuxer.js';\nimport { WaveDemuxer } from './wave/wave-demuxer.js';\nimport { MAX_FRAME_HEADER_SIZE, MIN_FRAME_HEADER_SIZE, readFrameHeader } from './adts/adts-reader.js';\nimport { AdtsDemuxer } from './adts/adts-demuxer.js';\nimport { readAscii } from './reader.js';\nimport { FlacDemuxer } from './flac/flac-demuxer.js';\n/**\n * Base class representing an input media file format.\n * @group Input formats\n * @public\n */\nexport class InputFormat {\n}\n/**\n * Format representing files compatible with the ISO base media file format (ISOBMFF), like MP4 or MOV files.\n * @group Input formats\n * @public\n */\nexport class IsobmffInputFormat extends InputFormat {\n    /** @internal */\n    async _getMajorBrand(input) {\n        let slice = input._reader.requestSlice(0, 12);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            return null;\n        slice.skip(4);\n        const fourCc = readAscii(slice, 4);\n        if (fourCc !== 'ftyp') {\n            return null;\n        }\n        return readAscii(slice, 4);\n    }\n    /** @internal */\n    _createDemuxer(input) {\n        return new IsobmffDemuxer(input);\n    }\n}\n/**\n * MPEG-4 Part 14 (MP4) file format.\n *\n * Do not instantiate this class; use the {@link MP4} singleton instead.\n *\n * @group Input formats\n * @public\n */\nexport class Mp4InputFormat extends IsobmffInputFormat {\n    /** @internal */\n    async _canReadInput(input) {\n        const majorBrand = await this._getMajorBrand(input);\n        return !!majorBrand && majorBrand !== 'qt  ';\n    }\n    get name() {\n        return 'MP4';\n    }\n    get mimeType() {\n        return 'video/mp4';\n    }\n}\n/**\n * QuickTime File Format (QTFF), often called MOV.\n *\n * Do not instantiate this class; use the {@link QTFF} singleton instead.\n *\n * @group Input formats\n * @public\n */\nexport class QuickTimeInputFormat extends IsobmffInputFormat {\n    /** @internal */\n    async _canReadInput(input) {\n        const majorBrand = await this._getMajorBrand(input);\n        return majorBrand === 'qt  ';\n    }\n    get name() {\n        return 'QuickTime File Format';\n    }\n    get mimeType() {\n        return 'video/quicktime';\n    }\n}\n/**\n * Matroska file format.\n *\n * Do not instantiate this class; use the {@link MATROSKA} singleton instead.\n *\n * @group Input formats\n * @public\n */\nexport class MatroskaInputFormat extends InputFormat {\n    /** @internal */\n    async isSupportedEBMLOfDocType(input, desiredDocType) {\n        let headerSlice = input._reader.requestSlice(0, MAX_HEADER_SIZE);\n        if (headerSlice instanceof Promise)\n            headerSlice = await headerSlice;\n        if (!headerSlice)\n            return false;\n        const varIntSize = readVarIntSize(headerSlice);\n        if (varIntSize === null) {\n            return false;\n        }\n        if (varIntSize < 1 || varIntSize > 8) {\n            return false;\n        }\n        const id = readUnsignedInt(headerSlice, varIntSize);\n        if (id !== EBMLId.EBML) {\n            return false;\n        }\n        const dataSize = readElementSize(headerSlice);\n        if (dataSize === null) {\n            return false; // Miss me with that shit\n        }\n        let dataSlice = input._reader.requestSlice(headerSlice.filePos, dataSize);\n        if (dataSlice instanceof Promise)\n            dataSlice = await dataSlice;\n        if (!dataSlice)\n            return false;\n        const startPos = headerSlice.filePos;\n        while (dataSlice.filePos <= startPos + dataSize - MIN_HEADER_SIZE) {\n            const header = readElementHeader(dataSlice);\n            if (!header)\n                break;\n            const { id, size } = header;\n            const dataStartPos = dataSlice.filePos;\n            if (size === null)\n                return false;\n            switch (id) {\n                case EBMLId.EBMLVersion:\n                    {\n                        const ebmlVersion = readUnsignedInt(dataSlice, size);\n                        if (ebmlVersion !== 1) {\n                            return false;\n                        }\n                    }\n                    ;\n                    break;\n                case EBMLId.EBMLReadVersion:\n                    {\n                        const ebmlReadVersion = readUnsignedInt(dataSlice, size);\n                        if (ebmlReadVersion !== 1) {\n                            return false;\n                        }\n                    }\n                    ;\n                    break;\n                case EBMLId.DocType:\n                    {\n                        const docType = readAsciiString(dataSlice, size);\n                        if (docType !== desiredDocType) {\n                            return false;\n                        }\n                    }\n                    ;\n                    break;\n                case EBMLId.DocTypeVersion:\n                    {\n                        const docTypeVersion = readUnsignedInt(dataSlice, size);\n                        if (docTypeVersion > 4) { // Support up to Matroska v4\n                            return false;\n                        }\n                    }\n                    ;\n                    break;\n            }\n            dataSlice.filePos = dataStartPos + size;\n        }\n        return true;\n    }\n    /** @internal */\n    _canReadInput(input) {\n        return this.isSupportedEBMLOfDocType(input, 'matroska');\n    }\n    /** @internal */\n    _createDemuxer(input) {\n        return new MatroskaDemuxer(input);\n    }\n    get name() {\n        return 'Matroska';\n    }\n    get mimeType() {\n        return 'video/x-matroska';\n    }\n}\n/**\n * WebM file format, based on Matroska.\n *\n * Do not instantiate this class; use the {@link WEBM} singleton instead.\n *\n * @group Input formats\n * @public\n */\nexport class WebMInputFormat extends MatroskaInputFormat {\n    /** @internal */\n    _canReadInput(input) {\n        return this.isSupportedEBMLOfDocType(input, 'webm');\n    }\n    get name() {\n        return 'WebM';\n    }\n    get mimeType() {\n        return 'video/webm';\n    }\n}\n/**\n * MP3 file format.\n *\n * Do not instantiate this class; use the {@link MP3} singleton instead.\n *\n * @group Input formats\n * @public\n */\nexport class Mp3InputFormat extends InputFormat {\n    /** @internal */\n    async _canReadInput(input) {\n        let slice = input._reader.requestSlice(0, 10);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            return false;\n        let currentPos = 0;\n        let id3V2HeaderFound = false;\n        while (true) {\n            let slice = input._reader.requestSlice(currentPos, ID3_V2_HEADER_SIZE);\n            if (slice instanceof Promise)\n                slice = await slice;\n            if (!slice)\n                break;\n            const id3V2Header = readId3V2Header(slice);\n            if (!id3V2Header) {\n                break;\n            }\n            id3V2HeaderFound = true;\n            currentPos = slice.filePos + id3V2Header.size;\n        }\n        const firstResult = await readNextFrameHeader(input._reader, currentPos, currentPos + 4096);\n        if (!firstResult) {\n            return false;\n        }\n        if (id3V2HeaderFound) {\n            // If there was an ID3v2 tag at the start, we can be pretty sure this is MP3 by now\n            return true;\n        }\n        currentPos = firstResult.startPos + firstResult.header.totalSize;\n        // Fine, we found one frame header, but we're still not entirely sure this is MP3. Let's check if we can find\n        // another header right after it:\n        const secondResult = await readNextFrameHeader(input._reader, currentPos, currentPos + FRAME_HEADER_SIZE);\n        if (!secondResult) {\n            return false;\n        }\n        const firstHeader = firstResult.header;\n        const secondHeader = secondResult.header;\n        // In a well-formed MP3 file, we'd expect these two frames to share some similarities:\n        if (firstHeader.channel !== secondHeader.channel || firstHeader.sampleRate !== secondHeader.sampleRate) {\n            return false;\n        }\n        // We have found two matching consecutive MP3 frames, a strong indicator that this is an MP3 file\n        return true;\n    }\n    /** @internal */\n    _createDemuxer(input) {\n        return new Mp3Demuxer(input);\n    }\n    get name() {\n        return 'MP3';\n    }\n    get mimeType() {\n        return 'audio/mpeg';\n    }\n}\n/**\n * WAVE file format, based on RIFF.\n *\n * Do not instantiate this class; use the {@link WAVE} singleton instead.\n *\n * @group Input formats\n * @public\n */\nexport class WaveInputFormat extends InputFormat {\n    /** @internal */\n    async _canReadInput(input) {\n        let slice = input._reader.requestSlice(0, 12);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            return false;\n        const riffType = readAscii(slice, 4);\n        if (riffType !== 'RIFF' && riffType !== 'RIFX' && riffType !== 'RF64') {\n            return false;\n        }\n        slice.skip(4);\n        const format = readAscii(slice, 4);\n        return format === 'WAVE';\n    }\n    /** @internal */\n    _createDemuxer(input) {\n        return new WaveDemuxer(input);\n    }\n    get name() {\n        return 'WAVE';\n    }\n    get mimeType() {\n        return 'audio/wav';\n    }\n}\n/**\n * Ogg file format.\n *\n * Do not instantiate this class; use the {@link OGG} singleton instead.\n *\n * @group Input formats\n * @public\n */\nexport class OggInputFormat extends InputFormat {\n    /** @internal */\n    async _canReadInput(input) {\n        let slice = input._reader.requestSlice(0, 4);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            return false;\n        return readAscii(slice, 4) === 'OggS';\n    }\n    /** @internal */\n    _createDemuxer(input) {\n        return new OggDemuxer(input);\n    }\n    get name() {\n        return 'Ogg';\n    }\n    get mimeType() {\n        return 'application/ogg';\n    }\n}\n/**\n * FLAC file format.\n *\n * Do not instantiate this class; use the {@link FLAC} singleton instead.\n *\n * @group Input formats\n * @public\n */\nexport class FlacInputFormat extends InputFormat {\n    /** @internal */\n    async _canReadInput(input) {\n        let slice = input._reader.requestSlice(0, 4);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            return false;\n        return readAscii(slice, 4) === 'fLaC';\n    }\n    get name() {\n        return 'FLAC';\n    }\n    get mimeType() {\n        return 'audio/flac';\n    }\n    /** @internal */\n    _createDemuxer(input) {\n        return new FlacDemuxer(input);\n    }\n}\n/**\n * ADTS file format.\n *\n * Do not instantiate this class; use the {@link ADTS} singleton instead.\n *\n * @group Input formats\n * @public\n */\nexport class AdtsInputFormat extends InputFormat {\n    /** @internal */\n    async _canReadInput(input) {\n        let slice = input._reader.requestSliceRange(0, MIN_FRAME_HEADER_SIZE, MAX_FRAME_HEADER_SIZE);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            return false;\n        const firstHeader = readFrameHeader(slice);\n        if (!firstHeader) {\n            return false;\n        }\n        slice = input._reader.requestSliceRange(firstHeader.frameLength, MIN_FRAME_HEADER_SIZE, MAX_FRAME_HEADER_SIZE);\n        if (slice instanceof Promise)\n            slice = await slice;\n        if (!slice)\n            return false;\n        const secondHeader = readFrameHeader(slice);\n        if (!secondHeader) {\n            return false;\n        }\n        return firstHeader.objectType === secondHeader.objectType\n            && firstHeader.samplingFrequencyIndex === secondHeader.samplingFrequencyIndex\n            && firstHeader.channelConfiguration === secondHeader.channelConfiguration;\n    }\n    /** @internal */\n    _createDemuxer(input) {\n        return new AdtsDemuxer(input);\n    }\n    get name() {\n        return 'ADTS';\n    }\n    get mimeType() {\n        return 'audio/aac';\n    }\n}\n/**\n * MP4 input format singleton.\n * @group Input formats\n * @public\n */\nexport const MP4 = /* #__PURE__ */ new Mp4InputFormat();\n/**\n * QuickTime File Format input format singleton.\n * @group Input formats\n * @public\n */\nexport const QTFF = /* #__PURE__ */ new QuickTimeInputFormat();\n/**\n * Matroska input format singleton.\n * @group Input formats\n * @public\n */\nexport const MATROSKA = /* #__PURE__ */ new MatroskaInputFormat();\n/**\n * WebM input format singleton.\n * @group Input formats\n * @public\n */\nexport const WEBM = /* #__PURE__ */ new WebMInputFormat();\n/**\n * MP3 input format singleton.\n * @group Input formats\n * @public\n */\nexport const MP3 = /* #__PURE__ */ new Mp3InputFormat();\n/**\n * WAVE input format singleton.\n * @group Input formats\n * @public\n */\nexport const WAVE = /* #__PURE__ */ new WaveInputFormat();\n/**\n * Ogg input format singleton.\n * @group Input formats\n * @public\n */\nexport const OGG = /* #__PURE__ */ new OggInputFormat();\n/**\n * ADTS input format singleton.\n * @group Input formats\n * @public\n */\nexport const ADTS = /* #__PURE__ */ new AdtsInputFormat();\n/**\n * FLAC input format singleton.\n * @group Input formats\n * @public\n */\nexport const FLAC = /* #__PURE__ */ new FlacInputFormat();\n/**\n * List of all input format singletons. If you don't need to support all input formats, you should specify the\n * formats individually for better tree shaking.\n * @group Input formats\n * @public\n */\nexport const ALL_FORMATS = [MP4, QTFF, MATROSKA, WEBM, WAVE, OGG, FLAC, MP3, ADTS];\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert, binarySearchLessOrEqual, closedIntervalsOverlap, isNumber, isWebKit, mergeRequestInit, promiseWithResolvers, retriedFetch, toDataView, toUint8Array, } from './misc.js';\nimport * as nodeAlias from './node.js';\nimport { InputDisposedError } from './input.js';\nconst node = typeof nodeAlias !== 'undefined'\n    ? nodeAlias // Aliasing it prevents some bundler warnings\n    : undefined;\n/**\n * The source base class, representing a resource from which bytes can be read.\n * @group Input sources\n * @public\n */\nexport class Source {\n    constructor() {\n        /** @internal */\n        this._disposed = false;\n        /** @internal */\n        this._sizePromise = null;\n        /** Called each time data is retrieved from the source. Will be called with the retrieved range (end exclusive). */\n        this.onread = null;\n    }\n    /**\n     * Resolves with the total size of the file in bytes. This function is memoized, meaning only the first call\n     * will retrieve the size.\n     *\n     * Returns null if the source is unsized.\n     */\n    async getSizeOrNull() {\n        if (this._disposed) {\n            throw new InputDisposedError();\n        }\n        return this._sizePromise ??= Promise.resolve(this._retrieveSize());\n    }\n    /**\n     * Resolves with the total size of the file in bytes. This function is memoized, meaning only the first call\n     * will retrieve the size.\n     *\n     * Throws an error if the source is unsized.\n     */\n    async getSize() {\n        if (this._disposed) {\n            throw new InputDisposedError();\n        }\n        const result = await this.getSizeOrNull();\n        if (result === null) {\n            throw new Error('Cannot determine the size of an unsized source.');\n        }\n        return result;\n    }\n}\n/**\n * A source backed by an ArrayBuffer or ArrayBufferView, with the entire file held in memory.\n * @group Input sources\n * @public\n */\nexport class BufferSource extends Source {\n    /**\n     * Creates a new {@link BufferSource} backed by the specified `ArrayBuffer`, `SharedArrayBuffer`,\n     * or `ArrayBufferView`.\n     */\n    constructor(buffer) {\n        if (!(buffer instanceof ArrayBuffer)\n            && !(typeof SharedArrayBuffer !== 'undefined' && buffer instanceof SharedArrayBuffer)\n            && !ArrayBuffer.isView(buffer)) {\n            throw new TypeError('buffer must be an ArrayBuffer, SharedArrayBuffer, or ArrayBufferView.');\n        }\n        super();\n        /** @internal */\n        this._onreadCalled = false;\n        this._bytes = toUint8Array(buffer);\n        this._view = toDataView(buffer);\n    }\n    /** @internal */\n    _retrieveSize() {\n        return this._bytes.byteLength;\n    }\n    /** @internal */\n    _read() {\n        if (!this._onreadCalled) {\n            // We just say the first read retrives all bytes from the source (which, I mean, it does)\n            this.onread?.(0, this._bytes.byteLength);\n            this._onreadCalled = true;\n        }\n        return {\n            bytes: this._bytes,\n            view: this._view,\n            offset: 0,\n        };\n    }\n    /** @internal */\n    _dispose() { }\n}\n/**\n * A source backed by a [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob). Since a\n * [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) is also a `Blob`, this is the source to use when\n * reading files off the disk.\n * @group Input sources\n * @public\n */\nexport class BlobSource extends Source {\n    /**\n     * Creates a new {@link BlobSource} backed by the specified\n     * [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob).\n     */\n    constructor(blob, options = {}) {\n        if (!(blob instanceof Blob)) {\n            throw new TypeError('blob must be a Blob.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.maxCacheSize !== undefined\n            && (!isNumber(options.maxCacheSize) || options.maxCacheSize < 0)) {\n            throw new TypeError('options.maxCacheSize, when provided, must be a non-negative number.');\n        }\n        super();\n        /** @internal */\n        this._readers = new WeakMap();\n        this._blob = blob;\n        this._orchestrator = new ReadOrchestrator({\n            maxCacheSize: options.maxCacheSize ?? (8 * 2 ** 20 /* 8 MiB */),\n            maxWorkerCount: 4,\n            runWorker: this._runWorker.bind(this),\n            prefetchProfile: PREFETCH_PROFILES.fileSystem,\n        });\n    }\n    /** @internal */\n    _retrieveSize() {\n        const size = this._blob.size;\n        this._orchestrator.fileSize = size;\n        return size;\n    }\n    /** @internal */\n    _read(start, end) {\n        return this._orchestrator.read(start, end);\n    }\n    /** @internal */\n    async _runWorker(worker) {\n        let reader = this._readers.get(worker);\n        if (reader === undefined) {\n            // https://github.com/Vanilagy/mediabunny/issues/184\n            // WebKit has critical bugs with blob.stream():\n            // - WebKitBlobResource error 1 when streaming large files\n            // - Memory buildup and reload loops on iOS (network process crashes)\n            // - ReadableStream stalls under backpressure (especially video)\n            // Affects Safari and all iOS browsers (Chrome, Firefox, etc.).\n            // Use arrayBuffer() fallback for WebKit browsers.\n            if ('stream' in this._blob && !isWebKit()) {\n                // Get a reader of the blob starting at the required offset, and then keep it around\n                const slice = this._blob.slice(worker.currentPos);\n                reader = slice.stream().getReader();\n            }\n            else {\n                // We'll need to use more primitive ways\n                reader = null;\n            }\n            this._readers.set(worker, reader);\n        }\n        while (worker.currentPos < worker.targetPos && !worker.aborted) {\n            if (reader) {\n                const { done, value } = await reader.read();\n                if (done) {\n                    this._orchestrator.forgetWorker(worker);\n                    throw new Error('Blob reader stopped unexpectedly before all requested data was read.');\n                }\n                if (worker.aborted) {\n                    break;\n                }\n                this.onread?.(worker.currentPos, worker.currentPos + value.length);\n                this._orchestrator.supplyWorkerData(worker, value);\n            }\n            else {\n                const data = await this._blob.slice(worker.currentPos, worker.targetPos).arrayBuffer();\n                if (worker.aborted) {\n                    break;\n                }\n                this.onread?.(worker.currentPos, worker.currentPos + data.byteLength);\n                this._orchestrator.supplyWorkerData(worker, new Uint8Array(data));\n            }\n        }\n        worker.running = false;\n        if (worker.aborted) {\n            // MDN: \"Calling this method signals a loss of interest in the stream by a consumer.\"\n            await reader?.cancel();\n        }\n    }\n    /** @internal */\n    _dispose() {\n        this._orchestrator.dispose();\n    }\n}\nconst URL_SOURCE_MIN_LOAD_AMOUNT = 0.5 * 2 ** 20; // 0.5 MiB\nconst DEFAULT_RETRY_DELAY = ((previousAttempts, error, src) => {\n    // Check if this could be a CORS error. If so, we cannot recover from it and\n    // should not attempt to retry.\n    // CORS errors are intentionally not opaque, so we need to rely on heuristics.\n    const couldBeCorsError = error instanceof Error && (error.message.includes('Failed to fetch') // Chrome\n        || error.message.includes('Load failed') // Safari\n        || error.message.includes('NetworkError when attempting to fetch resource') // Firefox\n    );\n    if (couldBeCorsError) {\n        let originOfSrc = null;\n        // Checking if the origin is different, because only then a CORS error could originate\n        try {\n            if (typeof window !== 'undefined' && typeof window.location !== 'undefined') {\n                originOfSrc = new URL(src instanceof Request ? src.url : src, window.location.href).origin;\n            }\n        }\n        catch {\n            // URL parse failed\n        }\n        // If user is offline, it is probably not a CORS error.\n        const isOnline = typeof navigator !== 'undefined' && typeof navigator.onLine === 'boolean' ? navigator.onLine : true;\n        if (isOnline && originOfSrc !== null && originOfSrc !== window.location.origin) {\n            console.warn(`Request will not be retried because a CORS error was suspected due to different origins. You can`\n                + ` modify this behavior by providing your own function for the 'getRetryDelay' option.`);\n            return null;\n        }\n    }\n    return Math.min(2 ** (previousAttempts - 2), 16);\n});\n/**\n * A source backed by a URL. This is useful for reading data from the network. Requests will be made using an optimized\n * reading and prefetching pattern to minimize request count and latency.\n * @group Input sources\n * @public\n */\nexport class UrlSource extends Source {\n    /** Creates a new {@link UrlSource} backed by the resource at the specified URL. */\n    constructor(url, options = {}) {\n        if (typeof url !== 'string'\n            && !(url instanceof URL)\n            && !(typeof Request !== 'undefined' && url instanceof Request)) {\n            throw new TypeError('url must be a string, URL or Request.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.requestInit !== undefined && (!options.requestInit || typeof options.requestInit !== 'object')) {\n            throw new TypeError('options.requestInit, when provided, must be an object.');\n        }\n        if (options.getRetryDelay !== undefined && typeof options.getRetryDelay !== 'function') {\n            throw new TypeError('options.getRetryDelay, when provided, must be a function.');\n        }\n        if (options.maxCacheSize !== undefined\n            && (!isNumber(options.maxCacheSize) || options.maxCacheSize < 0)) {\n            throw new TypeError('options.maxCacheSize, when provided, must be a non-negative number.');\n        }\n        if (options.fetchFn !== undefined && typeof options.fetchFn !== 'function') {\n            throw new TypeError('options.fetchFn, when provided, must be a function.');\n            // Won't bother validating this function beyond this\n        }\n        super();\n        /** @internal */\n        this._existingResponses = new WeakMap();\n        this._url = url;\n        this._options = options;\n        this._getRetryDelay = options.getRetryDelay ?? DEFAULT_RETRY_DELAY;\n        this._orchestrator = new ReadOrchestrator({\n            maxCacheSize: options.maxCacheSize ?? (64 * 2 ** 20 /* 64 MiB */),\n            // Most files in the real-world have a single sequential access pattern, but having two in parallel can\n            // also happen\n            maxWorkerCount: 2,\n            runWorker: this._runWorker.bind(this),\n            prefetchProfile: PREFETCH_PROFILES.network,\n        });\n    }\n    /** @internal */\n    async _retrieveSize() {\n        // Retrieving the resource size for UrlSource is optimized: Almost always (= always), the first bytes we have to\n        // read are the start of the file. This means it's smart to combine size fetching with fetching the start of the\n        // file. We additionally use this step to probe if the server supports range requests, killing three birds with\n        // one stone.\n        const abortController = new AbortController();\n        const response = await retriedFetch(this._options.fetchFn ?? fetch, this._url, mergeRequestInit(this._options.requestInit ?? {}, {\n            headers: {\n                // We could also send a non-range request to request the same bytes (all of them), but doing it like\n                // this is an easy way to check if the server supports range requests in the first place\n                Range: 'bytes=0-',\n            },\n            signal: abortController.signal,\n        }), this._getRetryDelay, () => this._disposed);\n        if (!response.ok) {\n            // eslint-disable-next-line @typescript-eslint/no-base-to-string\n            throw new Error(`Error fetching ${String(this._url)}: ${response.status} ${response.statusText}`);\n        }\n        let worker;\n        let fileSize;\n        if (response.status === 206) {\n            fileSize = this._getTotalLengthFromRangeResponse(response);\n            worker = this._orchestrator.createWorker(0, Math.min(fileSize, URL_SOURCE_MIN_LOAD_AMOUNT));\n        }\n        else {\n            // Server probably returned a 200.\n            const contentLength = response.headers.get('Content-Length');\n            if (contentLength) {\n                fileSize = Number(contentLength);\n                worker = this._orchestrator.createWorker(0, fileSize);\n                this._orchestrator.options.maxCacheSize = Infinity; // \n                console.warn('HTTP server did not respond with 206 Partial Content, meaning the entire remote resource now has'\n                    + ' to be downloaded. For efficient media file streaming across a network, please make sure your'\n                    + ' server supports range requests.');\n            }\n            else {\n                throw new Error(`HTTP response (status ${response.status}) must surface Content-Length header.`);\n            }\n        }\n        this._orchestrator.fileSize = fileSize;\n        this._existingResponses.set(worker, { response, abortController });\n        this._orchestrator.runWorker(worker);\n        return fileSize;\n    }\n    /** @internal */\n    _read(start, end) {\n        return this._orchestrator.read(start, end);\n    }\n    /** @internal */\n    async _runWorker(worker) {\n        // The outer loop is for resuming a request if it dies mid-response\n        while (true) {\n            const existing = this._existingResponses.get(worker);\n            this._existingResponses.delete(worker);\n            let abortController = existing?.abortController;\n            let response = existing?.response;\n            if (!abortController) {\n                abortController = new AbortController();\n                response = await retriedFetch(this._options.fetchFn ?? fetch, this._url, mergeRequestInit(this._options.requestInit ?? {}, {\n                    headers: {\n                        Range: `bytes=${worker.currentPos}-`,\n                    },\n                    signal: abortController.signal,\n                }), this._getRetryDelay, () => this._disposed);\n            }\n            assert(response);\n            if (!response.ok) {\n                // eslint-disable-next-line @typescript-eslint/no-base-to-string\n                throw new Error(`Error fetching ${String(this._url)}: ${response.status} ${response.statusText}`);\n            }\n            if (worker.currentPos > 0 && response.status !== 206) {\n                throw new Error('HTTP server did not respond with 206 Partial Content to a range request. To enable efficient media'\n                    + ' file streaming across a network, please make sure your server supports range requests.');\n            }\n            if (!response.body) {\n                throw new Error('Missing HTTP response body stream. The used fetch function must provide the response body as a'\n                    + ' ReadableStream.');\n            }\n            const reader = response.body.getReader();\n            while (true) {\n                if (worker.currentPos >= worker.targetPos || worker.aborted) {\n                    abortController.abort();\n                    worker.running = false;\n                    return;\n                }\n                let readResult;\n                try {\n                    readResult = await reader.read();\n                }\n                catch (error) {\n                    if (this._disposed) {\n                        // No need to try to retry\n                        throw error;\n                    }\n                    const retryDelayInSeconds = this._getRetryDelay(1, error, this._url);\n                    if (retryDelayInSeconds !== null) {\n                        console.error('Error while reading response stream. Attempting to resume.', error);\n                        await new Promise(resolve => setTimeout(resolve, 1000 * retryDelayInSeconds));\n                        break;\n                    }\n                    else {\n                        throw error;\n                    }\n                }\n                if (worker.aborted) {\n                    continue; // Cleanup happens in next iteration\n                }\n                const { done, value } = readResult;\n                if (done) {\n                    if (worker.currentPos >= worker.targetPos) {\n                        // All data was delivered, we're good\n                        this._orchestrator.forgetWorker(worker);\n                        worker.running = false;\n                        return;\n                    }\n                    // The response stopped early, before the target. This can happen if server decides to cap range\n                    // requests arbitrarily, even if the request had an uncapped end. In this case, let's fetch the rest\n                    // of the data using a new request.\n                    break;\n                }\n                this.onread?.(worker.currentPos, worker.currentPos + value.length);\n                this._orchestrator.supplyWorkerData(worker, value);\n            }\n        }\n        // The previous UrlSource had logic for circumventing https://issues.chromium.org/issues/436025873; I haven't\n        // been able to observe this bug with the new UrlSource (maybe because we're using response streaming), so the\n        // logic for that has vanished for now. Leaving a comment here if this becomes relevant again.\n    }\n    /** @internal */\n    _getTotalLengthFromRangeResponse(response) {\n        const contentRange = response.headers.get('Content-Range');\n        if (contentRange) {\n            const match = /\\/(\\d+)/.exec(contentRange);\n            if (match) {\n                return Number(match[1]);\n            }\n        }\n        const contentLength = response.headers.get('Content-Length');\n        if (contentLength) {\n            return Number(contentLength);\n        }\n        else {\n            throw new Error('Partial HTTP response (status 206) must surface either Content-Range or'\n                + ' Content-Length header.');\n        }\n    }\n    /** @internal */\n    _dispose() {\n        this._orchestrator.dispose();\n    }\n}\n/**\n * A source backed by a path to a file. Intended for server-side usage in Node, Bun, or Deno.\n *\n * Make sure to call `.dispose()` on the corresponding {@link Input} when done to explicitly free the internal file\n * handle acquired by this source.\n * @group Input sources\n * @public\n */\nexport class FilePathSource extends Source {\n    /** Creates a new {@link FilePathSource} backed by the file at the specified file path. */\n    constructor(filePath, options = {}) {\n        if (typeof filePath !== 'string') {\n            throw new TypeError('filePath must be a string.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.maxCacheSize !== undefined\n            && (!isNumber(options.maxCacheSize) || options.maxCacheSize < 0)) {\n            throw new TypeError('options.maxCacheSize, when provided, must be a non-negative number.');\n        }\n        super();\n        /** @internal */\n        this._fileHandle = null;\n        // Let's back this source with a StreamSource, makes the implementation very simple\n        this._streamSource = new StreamSource({\n            getSize: async () => {\n                this._fileHandle = await node.fs.open(filePath, 'r');\n                const stats = await this._fileHandle.stat();\n                return stats.size;\n            },\n            read: async (start, end) => {\n                assert(this._fileHandle);\n                const buffer = new Uint8Array(end - start);\n                await this._fileHandle.read(buffer, 0, end - start, start);\n                return buffer;\n            },\n            maxCacheSize: options.maxCacheSize,\n            prefetchProfile: 'fileSystem',\n        });\n    }\n    /** @internal */\n    _read(start, end) {\n        return this._streamSource._read(start, end);\n    }\n    /** @internal */\n    _retrieveSize() {\n        return this._streamSource._retrieveSize();\n    }\n    /** @internal */\n    _dispose() {\n        this._streamSource._dispose();\n        void this._fileHandle?.close();\n        this._fileHandle = null;\n    }\n}\n/**\n * A general-purpose, callback-driven source that can get its data from anywhere.\n * @group Input sources\n * @public\n */\nexport class StreamSource extends Source {\n    /** Creates a new {@link StreamSource} whose behavior is specified by `options`.  */\n    constructor(options) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (typeof options.getSize !== 'function') {\n            throw new TypeError('options.getSize must be a function.');\n        }\n        if (typeof options.read !== 'function') {\n            throw new TypeError('options.read must be a function.');\n        }\n        if (options.dispose !== undefined && typeof options.dispose !== 'function') {\n            throw new TypeError('options.dispose, when provided, must be a function.');\n        }\n        if (options.maxCacheSize !== undefined\n            && (!isNumber(options.maxCacheSize) || options.maxCacheSize < 0)) {\n            throw new TypeError('options.maxCacheSize, when provided, must be a non-negative number.');\n        }\n        if (options.prefetchProfile && !['none', 'fileSystem', 'network'].includes(options.prefetchProfile)) {\n            throw new TypeError('options.prefetchProfile, when provided, must be one of \\'none\\', \\'fileSystem\\' or \\'network\\'.');\n        }\n        super();\n        this._options = options;\n        this._orchestrator = new ReadOrchestrator({\n            maxCacheSize: options.maxCacheSize ?? (8 * 2 ** 20 /* 8 MiB */),\n            maxWorkerCount: 2, // Fixed for now, *should* be fine\n            prefetchProfile: PREFETCH_PROFILES[options.prefetchProfile ?? 'none'],\n            runWorker: this._runWorker.bind(this),\n        });\n    }\n    /** @internal */\n    _retrieveSize() {\n        const result = this._options.getSize();\n        if (result instanceof Promise) {\n            return result.then((size) => {\n                if (!Number.isInteger(size) || size < 0) {\n                    throw new TypeError('options.getSize must return or resolve to a non-negative integer.');\n                }\n                this._orchestrator.fileSize = size;\n                return size;\n            });\n        }\n        else {\n            if (!Number.isInteger(result) || result < 0) {\n                throw new TypeError('options.getSize must return or resolve to a non-negative integer.');\n            }\n            this._orchestrator.fileSize = result;\n            return result;\n        }\n    }\n    /** @internal */\n    _read(start, end) {\n        return this._orchestrator.read(start, end);\n    }\n    /** @internal */\n    async _runWorker(worker) {\n        while (worker.currentPos < worker.targetPos && !worker.aborted) {\n            const originalCurrentPos = worker.currentPos;\n            const originalTargetPos = worker.targetPos;\n            let data = this._options.read(worker.currentPos, originalTargetPos);\n            if (data instanceof Promise)\n                data = await data;\n            if (worker.aborted) {\n                break;\n            }\n            if (data instanceof Uint8Array) {\n                data = toUint8Array(data); // Normalize things like Node.js Buffer to Uint8Array\n                if (data.length !== originalTargetPos - worker.currentPos) {\n                    // Yes, we're that strict\n                    throw new Error(`options.read returned a Uint8Array with unexpected length: Requested ${originalTargetPos - worker.currentPos} bytes, but got ${data.length}.`);\n                }\n                this.onread?.(worker.currentPos, worker.currentPos + data.length);\n                this._orchestrator.supplyWorkerData(worker, data);\n            }\n            else if (data instanceof ReadableStream) {\n                const reader = data.getReader();\n                while (worker.currentPos < originalTargetPos && !worker.aborted) {\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        if (worker.currentPos < originalTargetPos) {\n                            // Yes, we're *that* strict\n                            throw new Error(`ReadableStream returned by options.read ended before supplying enough data.`\n                                + ` Requested ${originalTargetPos - originalCurrentPos} bytes, but got ${worker.currentPos - originalCurrentPos}`);\n                        }\n                        break;\n                    }\n                    if (!(value instanceof Uint8Array)) {\n                        throw new TypeError('ReadableStream returned by options.read must yield Uint8Array chunks.');\n                    }\n                    if (worker.aborted) {\n                        break;\n                    }\n                    const data = toUint8Array(value); // Normalize things like Node.js Buffer to Uint8Array\n                    this.onread?.(worker.currentPos, worker.currentPos + data.length);\n                    this._orchestrator.supplyWorkerData(worker, data);\n                }\n            }\n            else {\n                throw new TypeError('options.read must return or resolve to a Uint8Array or a ReadableStream.');\n            }\n        }\n        worker.running = false;\n    }\n    /** @internal */\n    _dispose() {\n        this._orchestrator.dispose();\n        this._options.dispose?.();\n    }\n}\n/**\n * A source backed by a [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) of\n * `Uint8Array`, representing an append-only byte stream of unknown length. This is the source to use for incrementally\n * streaming in input files that are still being constructed and whose size we don't yet know, like for example the\n * output chunks of [MediaRecorder](https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder).\n *\n * This source is *unsized*, meaning calls to `.getSize()` will throw and readers are more limited due to the\n * lack of random file access. You should only use this source with sequential access patterns, such as reading all\n * packets from start to end. This source does not work well with random access patterns unless you increase its\n * max cache size.\n *\n * @group Input sources\n * @public\n */\nexport class ReadableStreamSource extends Source {\n    /** Creates a new {@link ReadableStreamSource} backed by the specified `ReadableStream<Uint8Array>`. */\n    constructor(stream, options = {}) {\n        if (!(stream instanceof ReadableStream)) {\n            throw new TypeError('stream must be a ReadableStream.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.maxCacheSize !== undefined\n            && (!isNumber(options.maxCacheSize) || options.maxCacheSize < 0)) {\n            throw new TypeError('options.maxCacheSize, when provided, must be a non-negative number.');\n        }\n        super();\n        /** @internal */\n        this._reader = null;\n        /** @internal */\n        this._cache = [];\n        /** @internal */\n        this._pendingSlices = [];\n        /** @internal */\n        this._currentIndex = 0;\n        /** @internal */\n        this._targetIndex = 0;\n        /** @internal */\n        this._maxRequestedIndex = 0;\n        /** @internal */\n        this._endIndex = null;\n        /** @internal */\n        this._pulling = false;\n        this._stream = stream;\n        this._maxCacheSize = options.maxCacheSize ?? (16 * 2 ** 20 /* 16 MiB */);\n    }\n    /** @internal */\n    _retrieveSize() {\n        return this._endIndex; // Starts out as null, meaning this source is unsized\n    }\n    /** @internal */\n    _read(start, end) {\n        if (this._endIndex !== null && end > this._endIndex) {\n            return null;\n        }\n        this._maxRequestedIndex = Math.max(this._maxRequestedIndex, end);\n        const cacheStartIndex = binarySearchLessOrEqual(this._cache, start, x => x.start);\n        const cacheStartEntry = cacheStartIndex !== -1 ? this._cache[cacheStartIndex] : null;\n        if (cacheStartEntry && cacheStartEntry.start <= start && end <= cacheStartEntry.end) {\n            // The request can be satisfied with a single cache entry\n            return {\n                bytes: cacheStartEntry.bytes,\n                view: cacheStartEntry.view,\n                offset: cacheStartEntry.start,\n            };\n        }\n        let lastEnd = start;\n        const bytes = new Uint8Array(end - start);\n        if (cacheStartIndex !== -1) {\n            // Walk over the cache to see if we can satisfy the request using multiple cache entries\n            for (let i = cacheStartIndex; i < this._cache.length; i++) {\n                const cacheEntry = this._cache[i];\n                if (cacheEntry.start >= end) {\n                    break;\n                }\n                const cappedStart = Math.max(start, cacheEntry.start);\n                if (cappedStart > lastEnd) {\n                    // We're too far behind\n                    this._throwDueToCacheMiss();\n                }\n                const cappedEnd = Math.min(end, cacheEntry.end);\n                if (cappedStart < cappedEnd) {\n                    bytes.set(cacheEntry.bytes.subarray(cappedStart - cacheEntry.start, cappedEnd - cacheEntry.start), cappedStart - start);\n                    lastEnd = cappedEnd;\n                }\n            }\n        }\n        if (lastEnd === end) {\n            return {\n                bytes,\n                view: toDataView(bytes),\n                offset: start,\n            };\n        }\n        // We need to pull more data\n        if (this._currentIndex > lastEnd) {\n            // We're too far behind\n            this._throwDueToCacheMiss();\n        }\n        const { promise, resolve, reject } = promiseWithResolvers();\n        this._pendingSlices.push({\n            start,\n            end,\n            bytes,\n            resolve,\n            reject,\n        });\n        this._targetIndex = Math.max(this._targetIndex, end);\n        // Start pulling from the stream if we're not already doing it\n        if (!this._pulling) {\n            this._pulling = true;\n            void this._pull()\n                .catch((error) => {\n                this._pulling = false;\n                if (this._pendingSlices.length > 0) {\n                    this._pendingSlices.forEach(x => x.reject(error)); // Make sure to propagate any errors\n                    this._pendingSlices.length = 0;\n                }\n                else {\n                    throw error; // So it doesn't get swallowed\n                }\n            });\n        }\n        return promise;\n    }\n    /** @internal */\n    _throwDueToCacheMiss() {\n        throw new Error('Read is before the cached region. With ReadableStreamSource, you must access the data more'\n            + ' sequentially or increase the size of its cache.');\n    }\n    /** @internal */\n    async _pull() {\n        this._reader ??= this._stream.getReader();\n        // This is the loop that keeps pulling data from the stream until a target index is reached, filling requests\n        // in the process\n        while (this._currentIndex < this._targetIndex && !this._disposed) {\n            const { done, value } = await this._reader.read();\n            if (done) {\n                for (const pendingSlice of this._pendingSlices) {\n                    pendingSlice.resolve(null);\n                }\n                this._pendingSlices.length = 0;\n                this._endIndex = this._currentIndex; // We know how long the file is now!\n                break;\n            }\n            const startIndex = this._currentIndex;\n            const endIndex = this._currentIndex + value.byteLength;\n            // Fill the pending slices with the data\n            for (let i = 0; i < this._pendingSlices.length; i++) {\n                const pendingSlice = this._pendingSlices[i];\n                const cappedStart = Math.max(startIndex, pendingSlice.start);\n                const cappedEnd = Math.min(endIndex, pendingSlice.end);\n                if (cappedStart < cappedEnd) {\n                    pendingSlice.bytes.set(value.subarray(cappedStart - startIndex, cappedEnd - startIndex), cappedStart - pendingSlice.start);\n                    if (cappedEnd === pendingSlice.end) {\n                        // Pending slice fully filled\n                        pendingSlice.resolve({\n                            bytes: pendingSlice.bytes,\n                            view: toDataView(pendingSlice.bytes),\n                            offset: pendingSlice.start,\n                        });\n                        this._pendingSlices.splice(i, 1);\n                        i--;\n                    }\n                }\n            }\n            this._cache.push({\n                start: startIndex,\n                end: endIndex,\n                bytes: value,\n                view: toDataView(value),\n                age: 0, // Unused\n            });\n            // Do cache eviction, based on the distance from the last-requested index. It's important that we do it like\n            // this and not based on where the reader is at, because if the reader is fast, we'll unnecessarily evict\n            // data that we still might need.\n            while (this._cache.length > 0) {\n                const firstEntry = this._cache[0];\n                const distance = this._maxRequestedIndex - firstEntry.end;\n                if (distance <= this._maxCacheSize) {\n                    break;\n                }\n                this._cache.shift();\n            }\n            this._currentIndex += value.byteLength;\n        }\n        this._pulling = false;\n    }\n    /** @internal */\n    _dispose() {\n        this._pendingSlices.length = 0;\n        this._cache.length = 0;\n    }\n}\nconst PREFETCH_PROFILES = {\n    none: (start, end) => ({ start, end }),\n    fileSystem: (start, end) => {\n        const padding = 2 ** 16;\n        start = Math.floor((start - padding) / padding) * padding;\n        end = Math.ceil((end + padding) / padding) * padding;\n        return { start, end };\n    },\n    network: (start, end, workers) => {\n        // Add a slight bit of start padding because backwards reading is painful\n        const paddingStart = 2 ** 16;\n        start = Math.max(0, Math.floor((start - paddingStart) / paddingStart) * paddingStart);\n        // Remote resources have extreme latency (relatively speaking), so the benefit from intelligent\n        // prefetching is great. The network prefetch strategy is as follows: When we notice\n        // successive reads to a worker's read region, we prefetch more data at the end of that region,\n        // growing exponentially (up to a cap). This performs well for real-world use cases: Either we read a\n        // small part of the file once and then never need it again, in which case the requested about of data\n        // is small. Or, we're repeatedly doing a sequential access pattern (common in media files), in which\n        // case we can become more and more confident to prefetch more and more data.\n        for (const worker of workers) {\n            const maxExtensionAmount = 8 * 2 ** 20; // 8 MiB\n            // When the read region cross the threshold point, we trigger a prefetch. This point is typically\n            // in the middle of the worker's read region, or a fixed offset from the end if the region has grown\n            // really large.\n            const thresholdPoint = Math.max((worker.startPos + worker.targetPos) / 2, worker.targetPos - maxExtensionAmount);\n            if (closedIntervalsOverlap(start, end, thresholdPoint, worker.targetPos)) {\n                const size = worker.targetPos - worker.startPos;\n                // If we extend by maxExtensionAmount\n                const a = Math.ceil((size + 1) / maxExtensionAmount) * maxExtensionAmount;\n                // If we extend to the next power of 2\n                const b = 2 ** Math.ceil(Math.log2(size + 1));\n                const extent = Math.min(b, a);\n                end = Math.max(end, worker.startPos + extent);\n            }\n        }\n        end = Math.max(end, start + URL_SOURCE_MIN_LOAD_AMOUNT);\n        return {\n            start,\n            end,\n        };\n    },\n};\n/**\n * Godclass for orchestrating complex, cached read operations. The reading model is as follows: Any reading task is\n * delegated to a *worker*, which is a sequential reader positioned somewhere along the file. All workers run in\n * parallel and can be stopped and resumed in their forward movement. When read requests come in, this orchestrator will\n * first try to satisfy the request with only the cached data. If this isn't possible, workers are spun up for all\n * missing parts (or existing workers are repurposed), and these workers will then fill the holes in the data as they\n * march along the file.\n */\nclass ReadOrchestrator {\n    constructor(options) {\n        this.options = options;\n        this.fileSize = null;\n        this.nextAge = 0; // Used for LRU eviction of both cache entries and workers\n        this.workers = [];\n        this.cache = [];\n        this.currentCacheSize = 0;\n        this.disposed = false;\n    }\n    read(innerStart, innerEnd) {\n        assert(this.fileSize !== null);\n        const prefetchRange = this.options.prefetchProfile(innerStart, innerEnd, this.workers);\n        const outerStart = Math.max(prefetchRange.start, 0);\n        const outerEnd = Math.min(prefetchRange.end, this.fileSize);\n        assert(outerStart <= innerStart && innerEnd <= outerEnd);\n        let result = null;\n        const innerCacheStartIndex = binarySearchLessOrEqual(this.cache, innerStart, x => x.start);\n        const innerStartEntry = innerCacheStartIndex !== -1 ? this.cache[innerCacheStartIndex] : null;\n        // See if the read request can be satisfied by a single cache entry\n        if (innerStartEntry && innerStartEntry.start <= innerStart && innerEnd <= innerStartEntry.end) {\n            innerStartEntry.age = this.nextAge++;\n            result = {\n                bytes: innerStartEntry.bytes,\n                view: innerStartEntry.view,\n                offset: innerStartEntry.start,\n            };\n            // Can't return yet though, still need to check if the prefetch range might lie outside the cached area\n        }\n        const outerCacheStartIndex = binarySearchLessOrEqual(this.cache, outerStart, x => x.start);\n        const bytes = result ? null : new Uint8Array(innerEnd - innerStart);\n        let contiguousBytesWriteEnd = 0; // Used to track if the cache is able to completely cover the bytes\n        let lastEnd = outerStart;\n        // The \"holes\" in the cache (the parts we need to load)\n        const outerHoles = [];\n        // Loop over the cache and build up the list of holes\n        if (outerCacheStartIndex !== -1) {\n            for (let i = outerCacheStartIndex; i < this.cache.length; i++) {\n                const entry = this.cache[i];\n                if (entry.start >= outerEnd) {\n                    break;\n                }\n                if (entry.end <= outerStart) {\n                    continue;\n                }\n                const cappedOuterStart = Math.max(outerStart, entry.start);\n                const cappedOuterEnd = Math.min(outerEnd, entry.end);\n                assert(cappedOuterStart <= cappedOuterEnd);\n                if (lastEnd < cappedOuterStart) {\n                    outerHoles.push({ start: lastEnd, end: cappedOuterStart });\n                }\n                lastEnd = cappedOuterEnd;\n                if (bytes) {\n                    const cappedInnerStart = Math.max(innerStart, entry.start);\n                    const cappedInnerEnd = Math.min(innerEnd, entry.end);\n                    if (cappedInnerStart < cappedInnerEnd) {\n                        const relativeOffset = cappedInnerStart - innerStart;\n                        // Fill the relevant section of the bytes with the cached data\n                        bytes.set(entry.bytes.subarray(cappedInnerStart - entry.start, cappedInnerEnd - entry.start), relativeOffset);\n                        if (relativeOffset === contiguousBytesWriteEnd) {\n                            contiguousBytesWriteEnd = cappedInnerEnd - innerStart;\n                        }\n                    }\n                }\n                entry.age = this.nextAge++;\n            }\n            if (lastEnd < outerEnd) {\n                outerHoles.push({ start: lastEnd, end: outerEnd });\n            }\n        }\n        else {\n            outerHoles.push({ start: outerStart, end: outerEnd });\n        }\n        if (bytes && contiguousBytesWriteEnd >= bytes.length) {\n            // Multiple cache entries were able to completely cover the requested bytes!\n            result = {\n                bytes,\n                view: toDataView(bytes),\n                offset: innerStart,\n            };\n        }\n        if (outerHoles.length === 0) {\n            assert(result);\n            return result;\n        }\n        // We need to read more data, so now we're in async land\n        const { promise, resolve, reject } = promiseWithResolvers();\n        const innerHoles = [];\n        for (const outerHole of outerHoles) {\n            const cappedStart = Math.max(innerStart, outerHole.start);\n            const cappedEnd = Math.min(innerEnd, outerHole.end);\n            if (cappedStart === outerHole.start && cappedEnd === outerHole.end) {\n                innerHoles.push(outerHole); // Can reuse without allocating a new object\n            }\n            else if (cappedStart < cappedEnd) {\n                innerHoles.push({ start: cappedStart, end: cappedEnd });\n            }\n        }\n        // Fire off workers to take care of patching the holes\n        for (const outerHole of outerHoles) {\n            const pendingSlice = bytes && {\n                start: innerStart,\n                bytes,\n                holes: innerHoles,\n                resolve,\n                reject,\n            };\n            let workerFound = false;\n            for (const worker of this.workers) {\n                // A small tolerance in the case that the requested region is *just* after the target position of an\n                // existing worker. In that case, it's probably more efficient to repurpose that worker than to spawn\n                // another one so close to it\n                const gapTolerance = 2 ** 17;\n                // This check also implies worker.currentPos <= outerHole.start, a critical condition\n                if (closedIntervalsOverlap(outerHole.start - gapTolerance, outerHole.start, worker.currentPos, worker.targetPos)) {\n                    worker.targetPos = Math.max(worker.targetPos, outerHole.end); // Update the worker's target position\n                    workerFound = true;\n                    if (pendingSlice && !worker.pendingSlices.includes(pendingSlice)) {\n                        worker.pendingSlices.push(pendingSlice);\n                    }\n                    if (!worker.running) {\n                        // Kick it off if it's idle\n                        this.runWorker(worker);\n                    }\n                    break;\n                }\n            }\n            if (!workerFound) {\n                // We need to spawn a new worker\n                const newWorker = this.createWorker(outerHole.start, outerHole.end);\n                if (pendingSlice) {\n                    newWorker.pendingSlices = [pendingSlice];\n                }\n                this.runWorker(newWorker);\n            }\n        }\n        if (!result) {\n            assert(bytes);\n            result = promise.then(bytes => ({\n                bytes,\n                view: toDataView(bytes),\n                offset: innerStart,\n            }));\n        }\n        else {\n            // The requested region was satisfied by the cache, but the entire prefetch region was not\n        }\n        return result;\n    }\n    createWorker(startPos, targetPos) {\n        const worker = {\n            startPos,\n            currentPos: startPos,\n            targetPos,\n            running: false,\n            // Due to async shenanigans, it can happen that workers are started after disposal. In this case, instead of\n            // simply not creating the worker, we allow it to run but immediately label it as aborted, so it can then\n            // shut itself down.\n            aborted: this.disposed,\n            pendingSlices: [],\n            age: this.nextAge++,\n        };\n        this.workers.push(worker);\n        // LRU eviction of the other workers\n        while (this.workers.length > this.options.maxWorkerCount) {\n            let oldestIndex = 0;\n            let oldestWorker = this.workers[0];\n            for (let i = 1; i < this.workers.length; i++) {\n                const worker = this.workers[i];\n                if (worker.age < oldestWorker.age) {\n                    oldestIndex = i;\n                    oldestWorker = worker;\n                }\n            }\n            if (oldestWorker.running && oldestWorker.pendingSlices.length > 0) {\n                break;\n            }\n            oldestWorker.aborted = true;\n            this.workers.splice(oldestIndex, 1);\n        }\n        return worker;\n    }\n    runWorker(worker) {\n        assert(!worker.running);\n        assert(worker.currentPos < worker.targetPos);\n        worker.running = true;\n        worker.age = this.nextAge++;\n        void this.options.runWorker(worker)\n            .catch((error) => {\n            worker.running = false;\n            if (worker.pendingSlices.length > 0) {\n                worker.pendingSlices.forEach(x => x.reject(error)); // Make sure to propagate any errors\n                worker.pendingSlices.length = 0;\n            }\n            else {\n                throw error; // So it doesn't get swallowed\n            }\n        });\n    }\n    /** Called by a worker when it has read some data. */\n    supplyWorkerData(worker, bytes) {\n        assert(!worker.aborted);\n        const start = worker.currentPos;\n        const end = start + bytes.length;\n        this.insertIntoCache({\n            start,\n            end,\n            bytes,\n            view: toDataView(bytes),\n            age: this.nextAge++,\n        });\n        worker.currentPos += bytes.length;\n        worker.targetPos = Math.max(worker.targetPos, worker.currentPos); // In case it overshoots\n        // Now, let's see if we can use the read bytes to fill any pending slice\n        for (let i = 0; i < worker.pendingSlices.length; i++) {\n            const pendingSlice = worker.pendingSlices[i];\n            const clampedStart = Math.max(start, pendingSlice.start);\n            const clampedEnd = Math.min(end, pendingSlice.start + pendingSlice.bytes.length);\n            if (clampedStart < clampedEnd) {\n                pendingSlice.bytes.set(bytes.subarray(clampedStart - start, clampedEnd - start), clampedStart - pendingSlice.start);\n            }\n            for (let j = 0; j < pendingSlice.holes.length; j++) {\n                // The hole is intentionally not modified here if the read section starts somewhere in the middle of\n                // the hole. We don't need to do \"hole splitting\", since the workers are spawned *by* the holes,\n                // meaning there's always a worker which will consume the hole left to right.\n                const hole = pendingSlice.holes[j];\n                if (start <= hole.start && end > hole.start) {\n                    hole.start = end;\n                }\n                if (hole.end <= hole.start) {\n                    pendingSlice.holes.splice(j, 1);\n                    j--;\n                }\n            }\n            if (pendingSlice.holes.length === 0) {\n                // The slice has been fulfilled, everything has been read. Let's resolve the promise\n                pendingSlice.resolve(pendingSlice.bytes);\n                worker.pendingSlices.splice(i, 1);\n                i--;\n            }\n        }\n        // Remove other idle workers if we \"ate\" into their territory\n        for (let i = 0; i < this.workers.length; i++) {\n            const otherWorker = this.workers[i];\n            if (worker === otherWorker || otherWorker.running) {\n                continue;\n            }\n            if (closedIntervalsOverlap(start, end, otherWorker.currentPos, otherWorker.targetPos)) {\n                this.workers.splice(i, 1);\n                i--;\n            }\n        }\n    }\n    forgetWorker(worker) {\n        const index = this.workers.indexOf(worker);\n        assert(index !== -1);\n        this.workers.splice(index, 1);\n    }\n    insertIntoCache(entry) {\n        if (this.options.maxCacheSize === 0) {\n            return; // No caching\n        }\n        let insertionIndex = binarySearchLessOrEqual(this.cache, entry.start, x => x.start) + 1;\n        if (insertionIndex > 0) {\n            const previous = this.cache[insertionIndex - 1];\n            if (previous.end >= entry.end) {\n                // Previous entry swallows the one to be inserted; we don't need to do anything\n                return;\n            }\n            if (previous.end > entry.start) {\n                // Partial overlap with the previous entry, let's join\n                const joined = new Uint8Array(entry.end - previous.start);\n                joined.set(previous.bytes, 0);\n                joined.set(entry.bytes, entry.start - previous.start);\n                this.currentCacheSize += entry.end - previous.end;\n                previous.bytes = joined;\n                previous.view = toDataView(joined);\n                previous.end = entry.end;\n                // Do the rest of the logic with the previous entry instead\n                insertionIndex--;\n                entry = previous;\n            }\n            else {\n                this.cache.splice(insertionIndex, 0, entry);\n                this.currentCacheSize += entry.bytes.length;\n            }\n        }\n        else {\n            this.cache.splice(insertionIndex, 0, entry);\n            this.currentCacheSize += entry.bytes.length;\n        }\n        for (let i = insertionIndex + 1; i < this.cache.length; i++) {\n            const next = this.cache[i];\n            if (entry.end <= next.start) {\n                // Even if they touch, we don't wanna merge them, no need\n                break;\n            }\n            if (entry.end >= next.end) {\n                // The inserted entry completely swallows the next entry\n                this.cache.splice(i, 1);\n                this.currentCacheSize -= next.bytes.length;\n                i--;\n                continue;\n            }\n            // Partial overlap, let's join\n            const joined = new Uint8Array(next.end - entry.start);\n            joined.set(entry.bytes, 0);\n            joined.set(next.bytes, next.start - entry.start);\n            this.currentCacheSize -= entry.end - next.start; // Subtract the overlap\n            entry.bytes = joined;\n            entry.view = toDataView(joined);\n            entry.end = next.end;\n            this.cache.splice(i, 1);\n            break; // After the join case, we're done: the next entry cannot possibly overlap with the inserted one.\n        }\n        // LRU eviction of cache entries\n        while (this.currentCacheSize > this.options.maxCacheSize) {\n            let oldestIndex = 0;\n            let oldestEntry = this.cache[0];\n            for (let i = 1; i < this.cache.length; i++) {\n                const entry = this.cache[i];\n                if (entry.age < oldestEntry.age) {\n                    oldestIndex = i;\n                    oldestEntry = entry;\n                }\n            }\n            if (this.currentCacheSize - oldestEntry.bytes.length <= this.options.maxCacheSize) {\n                // Don't evict if it would shrink the cache below the max size\n                break;\n            }\n            this.cache.splice(oldestIndex, 1);\n            this.currentCacheSize -= oldestEntry.bytes.length;\n        }\n    }\n    dispose() {\n        for (const worker of this.workers) {\n            worker.aborted = true;\n        }\n        this.workers.length = 0;\n        this.cache.length = 0;\n        this.disposed = true;\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { InputFormat } from './input-format.js';\nimport { assert, polyfillSymbolDispose } from './misc.js';\nimport { Reader } from './reader.js';\nimport { Source } from './source.js';\npolyfillSymbolDispose();\n/**\n * Represents an input media file. This is the root object from which all media read operations start.\n * @group Input files & tracks\n * @public\n */\nexport class Input {\n    /** True if the input has been disposed. */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * Creates a new input file from the specified options. No reading operations will be performed until methods are\n     * called on this instance.\n     */\n    constructor(options) {\n        /** @internal */\n        this._demuxerPromise = null;\n        /** @internal */\n        this._format = null;\n        /** @internal */\n        this._disposed = false;\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!Array.isArray(options.formats) || options.formats.some(x => !(x instanceof InputFormat))) {\n            throw new TypeError('options.formats must be an array of InputFormat.');\n        }\n        if (!(options.source instanceof Source)) {\n            throw new TypeError('options.source must be a Source.');\n        }\n        if (options.source._disposed) {\n            throw new Error('options.source must not be disposed.');\n        }\n        this._formats = options.formats;\n        this._source = options.source;\n        this._reader = new Reader(options.source);\n    }\n    /** @internal */\n    _getDemuxer() {\n        return this._demuxerPromise ??= (async () => {\n            this._reader.fileSize = await this._source.getSizeOrNull();\n            for (const format of this._formats) {\n                const canRead = await format._canReadInput(this);\n                if (canRead) {\n                    this._format = format;\n                    return format._createDemuxer(this);\n                }\n            }\n            throw new Error('Input has an unsupported or unrecognizable format.');\n        })();\n    }\n    /**\n     * Returns the source from which this input file reads its data. This is the same source that was passed to the\n     * constructor.\n     */\n    get source() {\n        return this._source;\n    }\n    /**\n     * Returns the format of the input file. You can compare this result directly to the {@link InputFormat} singletons\n     * or use `instanceof` checks for subset-aware logic (for example, `format instanceof MatroskaInputFormat` is true\n     * for both MKV and WebM).\n     */\n    async getFormat() {\n        await this._getDemuxer();\n        assert(this._format);\n        return this._format;\n    }\n    /**\n     * Computes the duration of the input file, in seconds. More precisely, returns the largest end timestamp among\n     * all tracks.\n     */\n    async computeDuration() {\n        const demuxer = await this._getDemuxer();\n        return demuxer.computeDuration();\n    }\n    /** Returns the list of all tracks of this input file. */\n    async getTracks() {\n        const demuxer = await this._getDemuxer();\n        return demuxer.getTracks();\n    }\n    /** Returns the list of all video tracks of this input file. */\n    async getVideoTracks() {\n        const tracks = await this.getTracks();\n        return tracks.filter(x => x.isVideoTrack());\n    }\n    /** Returns the list of all audio tracks of this input file. */\n    async getAudioTracks() {\n        const tracks = await this.getTracks();\n        return tracks.filter(x => x.isAudioTrack());\n    }\n    /** Returns the primary video track of this input file, or null if there are no video tracks. */\n    async getPrimaryVideoTrack() {\n        const tracks = await this.getTracks();\n        return tracks.find(x => x.isVideoTrack()) ?? null;\n    }\n    /** Returns the primary audio track of this input file, or null if there are no audio tracks. */\n    async getPrimaryAudioTrack() {\n        const tracks = await this.getTracks();\n        return tracks.find(x => x.isAudioTrack()) ?? null;\n    }\n    /** Returns the full MIME type of this input file, including track codecs. */\n    async getMimeType() {\n        const demuxer = await this._getDemuxer();\n        return demuxer.getMimeType();\n    }\n    /**\n     * Returns descriptive metadata tags about the media file, such as title, author, date, cover art, or other\n     * attached files.\n     */\n    async getMetadataTags() {\n        const demuxer = await this._getDemuxer();\n        return demuxer.getMetadataTags();\n    }\n    /**\n     * Disposes this input and frees connected resources. When an input is disposed, ongoing read operations will be\n     * canceled, all future read operations will fail, any open decoders will be closed, and all ongoing media sink\n     * operations will be canceled. Disallowed and canceled operations will throw an {@link InputDisposedError}.\n     *\n     * You are expected not to use an input after disposing it. While some operations may still work, it is not\n     * specified and may change in any future update.\n     */\n    dispose() {\n        if (this._disposed) {\n            return;\n        }\n        this._disposed = true;\n        this._source._disposed = true;\n        this._source._dispose();\n    }\n    /**\n     * Calls `.dispose()` on the input, implementing the `Disposable` interface for use with\n     * JavaScript Explicit Resource Management features.\n     */\n    [Symbol.dispose]() {\n        this.dispose();\n    }\n}\n/**\n * Thrown when an operation was prevented because the corresponding {@link Input} has been disposed.\n * @group Input files & tracks\n * @public\n */\nexport class InputDisposedError extends Error {\n    /** Creates a new {@link InputDisposedError}. */\n    constructor(message = 'Input has been disposed.') {\n        super(message);\n        this.name = 'InputDisposedError';\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { InputDisposedError } from './input.js';\nimport { assert, clamp, getUint24, toDataView } from './misc.js';\nexport class Reader {\n    constructor(source) {\n        this.source = source;\n    }\n    requestSlice(start, length) {\n        if (this.source._disposed) {\n            throw new InputDisposedError();\n        }\n        if (this.fileSize !== null && start + length > this.fileSize) {\n            return null;\n        }\n        const end = start + length;\n        const result = this.source._read(start, end);\n        if (result instanceof Promise) {\n            return result.then((x) => {\n                if (!x) {\n                    return null;\n                }\n                return new FileSlice(x.bytes, x.view, x.offset, start, end);\n            });\n        }\n        else {\n            if (!result) {\n                return null;\n            }\n            return new FileSlice(result.bytes, result.view, result.offset, start, end);\n        }\n    }\n    requestSliceRange(start, minLength, maxLength) {\n        if (this.source._disposed) {\n            throw new InputDisposedError();\n        }\n        if (this.fileSize !== null) {\n            return this.requestSlice(start, clamp(this.fileSize - start, minLength, maxLength));\n        }\n        else {\n            const promisedAttempt = this.requestSlice(start, maxLength);\n            const handleAttempt = (attempt) => {\n                if (attempt) {\n                    return attempt;\n                }\n                const handleFileSize = (fileSize) => {\n                    assert(fileSize !== null); // The slice couldn't fit, meaning we must know the file size now\n                    return this.requestSlice(start, clamp(fileSize - start, minLength, maxLength));\n                };\n                const promisedFileSize = this.source._retrieveSize();\n                if (promisedFileSize instanceof Promise) {\n                    return promisedFileSize.then(handleFileSize);\n                }\n                else {\n                    return handleFileSize(promisedFileSize);\n                }\n            };\n            if (promisedAttempt instanceof Promise) {\n                return promisedAttempt.then(handleAttempt);\n            }\n            else {\n                return handleAttempt(promisedAttempt);\n            }\n        }\n    }\n}\nexport class FileSlice {\n    constructor(\n    /** The underlying bytes backing this slice. Avoid using this directly and prefer reader functions instead. */\n    bytes, \n    /** A view into the bytes backing this slice. Avoid using this directly and prefer reader functions instead. */\n    view, \n    /** The offset in \"file bytes\" at which `bytes` begins in the file. */\n    offset, \n    /** The offset in \"file bytes\" where this slice begins. */\n    start, \n    /** The offset in \"file bytes\" where this slice ends (exclusive). */\n    end) {\n        this.bytes = bytes;\n        this.view = view;\n        this.offset = offset;\n        this.start = start;\n        this.end = end;\n        this.bufferPos = start - offset;\n    }\n    static tempFromBytes(bytes) {\n        return new FileSlice(bytes, toDataView(bytes), 0, 0, bytes.length);\n    }\n    get length() {\n        return this.end - this.start;\n    }\n    get filePos() {\n        return this.offset + this.bufferPos;\n    }\n    set filePos(value) {\n        this.bufferPos = value - this.offset;\n    }\n    /** The number of bytes left from the current pos to the end of the slice. */\n    get remainingLength() {\n        return Math.max(this.end - this.filePos, 0);\n    }\n    skip(byteCount) {\n        this.bufferPos += byteCount;\n    }\n    /** Creates a new subslice of this slice whose byte range must be contained within this slice. */\n    slice(filePos, length = this.end - filePos) {\n        if (filePos < this.start || filePos + length > this.end) {\n            throw new RangeError('Slicing outside of original slice.');\n        }\n        return new FileSlice(this.bytes, this.view, this.offset, filePos, filePos + length);\n    }\n}\nconst checkIsInRange = (slice, bytesToRead) => {\n    if (slice.filePos < slice.start || slice.filePos + bytesToRead > slice.end) {\n        throw new RangeError(`Tried reading [${slice.filePos}, ${slice.filePos + bytesToRead}), but slice is`\n            + ` [${slice.start}, ${slice.end}). This is likely an internal error, please report it alongside the file`\n            + ` that caused it.`);\n    }\n};\nexport const readBytes = (slice, length) => {\n    checkIsInRange(slice, length);\n    const bytes = slice.bytes.subarray(slice.bufferPos, slice.bufferPos + length);\n    slice.bufferPos += length;\n    return bytes;\n};\nexport const readU8 = (slice) => {\n    checkIsInRange(slice, 1);\n    return slice.view.getUint8(slice.bufferPos++);\n};\nexport const readU16 = (slice, littleEndian) => {\n    checkIsInRange(slice, 2);\n    const value = slice.view.getUint16(slice.bufferPos, littleEndian);\n    slice.bufferPos += 2;\n    return value;\n};\nexport const readU16Be = (slice) => {\n    checkIsInRange(slice, 2);\n    const value = slice.view.getUint16(slice.bufferPos, false);\n    slice.bufferPos += 2;\n    return value;\n};\nexport const readU24Be = (slice) => {\n    checkIsInRange(slice, 3);\n    const value = getUint24(slice.view, slice.bufferPos, false);\n    slice.bufferPos += 3;\n    return value;\n};\nexport const readI16Be = (slice) => {\n    checkIsInRange(slice, 2);\n    const value = slice.view.getInt16(slice.bufferPos, false);\n    slice.bufferPos += 2;\n    return value;\n};\nexport const readU32 = (slice, littleEndian) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getUint32(slice.bufferPos, littleEndian);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readU32Be = (slice) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getUint32(slice.bufferPos, false);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readU32Le = (slice) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getUint32(slice.bufferPos, true);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readI32Be = (slice) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getInt32(slice.bufferPos, false);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readI32Le = (slice) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getInt32(slice.bufferPos, true);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readU64 = (slice, littleEndian) => {\n    let low;\n    let high;\n    if (littleEndian) {\n        low = readU32(slice, true);\n        high = readU32(slice, true);\n    }\n    else {\n        high = readU32(slice, false);\n        low = readU32(slice, false);\n    }\n    return high * 0x100000000 + low;\n};\nexport const readU64Be = (slice) => {\n    const high = readU32Be(slice);\n    const low = readU32Be(slice);\n    return high * 0x100000000 + low;\n};\nexport const readI64Be = (slice) => {\n    const high = readI32Be(slice);\n    const low = readU32Be(slice);\n    return high * 0x100000000 + low;\n};\nexport const readI64Le = (slice) => {\n    const low = readU32Le(slice);\n    const high = readI32Le(slice);\n    return high * 0x100000000 + low;\n};\nexport const readF32Be = (slice) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getFloat32(slice.bufferPos, false);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readF64Be = (slice) => {\n    checkIsInRange(slice, 8);\n    const value = slice.view.getFloat64(slice.bufferPos, false);\n    slice.bufferPos += 8;\n    return value;\n};\nexport const readAscii = (slice, length) => {\n    checkIsInRange(slice, length);\n    let str = '';\n    for (let i = 0; i < length; i++) {\n        str += String.fromCharCode(slice.bytes[slice.bufferPos++]);\n    }\n    return str;\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { validateAudioChunkMetadata } from '../codec.js';\nimport { createVorbisComments, FlacBlockType } from '../codec-data.js';\nimport { assert, Bitstream, textEncoder, toDataView, toUint8Array, } from '../misc.js';\nimport { Muxer } from '../muxer.js';\nimport { FileSlice, readBytes } from '../reader.js';\nimport { metadataTagsAreEmpty } from '../metadata.js';\nimport { readBlockSize, getBlockSizeOrUncommon, readCodedNumber, } from './flac-misc.js';\nconst FLAC_HEADER = /* #__PURE__ */ new Uint8Array([0x66, 0x4c, 0x61, 0x43]); // 'fLaC'\nconst STREAMINFO_SIZE = 38;\nconst STREAMINFO_BLOCK_SIZE = 34;\nexport class FlacMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.metadataWritten = false;\n        this.blockSizes = [];\n        this.frameSizes = [];\n        this.sampleRate = null;\n        this.channels = null;\n        this.bitsPerSample = null;\n        this.writer = output._writer;\n        this.format = format;\n    }\n    async start() {\n        this.writer.write(FLAC_HEADER);\n    }\n    writeHeader({ bitsPerSample, minimumBlockSize, maximumBlockSize, minimumFrameSize, maximumFrameSize, sampleRate, channels, totalSamples, }) {\n        assert(this.writer.getPos() === 4);\n        const hasMetadata = !metadataTagsAreEmpty(this.output._metadataTags);\n        const headerBitstream = new Bitstream(new Uint8Array(4));\n        headerBitstream.writeBits(1, Number(!hasMetadata)); // isLastMetadata\n        headerBitstream.writeBits(7, FlacBlockType.STREAMINFO); // metaBlockType = streaminfo\n        headerBitstream.writeBits(24, STREAMINFO_BLOCK_SIZE); // size\n        this.writer.write(headerBitstream.bytes);\n        const contentBitstream = new Bitstream(new Uint8Array(18));\n        contentBitstream.writeBits(16, minimumBlockSize);\n        contentBitstream.writeBits(16, maximumBlockSize);\n        contentBitstream.writeBits(24, minimumFrameSize);\n        contentBitstream.writeBits(24, maximumFrameSize);\n        contentBitstream.writeBits(20, sampleRate);\n        contentBitstream.writeBits(3, channels - 1);\n        contentBitstream.writeBits(5, bitsPerSample - 1);\n        // Bitstream operations are only safe until 32bit, breaks when using 36 bits\n        // Splitting up into writing 4 0 bits and then 32 bits is safe\n        // This is safe for audio up to (2 ** 32 / 44100 / 3600) -> 27 hours\n        // Not implementing support for more than 32 bits now\n        if (totalSamples >= 2 ** 32) {\n            throw new Error('This muxer only supports writing up to 2 ** 32 samples');\n        }\n        contentBitstream.writeBits(4, 0);\n        contentBitstream.writeBits(32, totalSamples);\n        this.writer.write(contentBitstream.bytes);\n        // The MD5 hash is calculated from decoded audio data, but we do not have access\n        // to it here. We are allowed to set 0:\n        // \"A value of 0 signifies that the value is not known.\"\n        // https://www.rfc-editor.org/rfc/rfc9639.html#name-streaminfo\n        this.writer.write(new Uint8Array(16));\n    }\n    writePictureBlock(picture) {\n        // Header size:\n        // 4 bytes: picture type\n        // 4 bytes: media type length\n        // x bytes: media type\n        // 4 bytes: description length\n        // y bytes: description\n        // 1 bytes: width\n        // 1 bytes: height\n        // 1 bytes: color depth\n        // 1 bytes: number of indexed colors\n        // 4 bytes: picture data length\n        // z bytes: picture data\n        // Total: 20 + x + y + z\n        const headerSize = 32\n            + picture.mimeType.length\n            + (picture.description?.length ?? 0)\n            + picture.data.length;\n        const header = new Uint8Array(headerSize);\n        let offset = 0;\n        const dataView = toDataView(header);\n        dataView.setUint32(offset, picture.kind === 'coverFront' ? 3 : picture.kind === 'coverBack' ? 4 : 0);\n        offset += 4;\n        dataView.setUint32(offset, picture.mimeType.length);\n        offset += 4;\n        header.set(textEncoder.encode(picture.mimeType), 8);\n        offset += picture.mimeType.length;\n        dataView.setUint32(offset, picture.description?.length ?? 0);\n        offset += 4;\n        header.set(textEncoder.encode(picture.description ?? ''), offset);\n        offset += picture.description?.length ?? 0;\n        offset += 4 + 4 + 4 + 4; // setting width, height, color depth, number of indexed colors to 0\n        dataView.setUint32(offset, picture.data.length);\n        offset += 4;\n        header.set(picture.data, offset);\n        offset += picture.data.length;\n        assert(offset === headerSize);\n        const headerBitstream = new Bitstream(new Uint8Array(4));\n        headerBitstream.writeBits(1, 0); // Last metadata block -> false, will be continued by vorbis comment\n        headerBitstream.writeBits(7, FlacBlockType.PICTURE); // Type -> Picture\n        headerBitstream.writeBits(24, headerSize);\n        this.writer.write(headerBitstream.bytes);\n        this.writer.write(header);\n    }\n    writeVorbisCommentAndPictureBlock() {\n        this.writer.seek(STREAMINFO_SIZE + FLAC_HEADER.byteLength);\n        if (metadataTagsAreEmpty(this.output._metadataTags)) {\n            this.metadataWritten = true;\n            return;\n        }\n        const pictures = this.output._metadataTags.images ?? [];\n        for (const picture of pictures) {\n            this.writePictureBlock(picture);\n        }\n        const vorbisComment = createVorbisComments(new Uint8Array(0), this.output._metadataTags, false);\n        const headerBitstream = new Bitstream(new Uint8Array(4));\n        headerBitstream.writeBits(1, 1); // Last metadata block -> true\n        headerBitstream.writeBits(7, FlacBlockType.VORBIS_COMMENT); // Type -> Vorbis comment\n        headerBitstream.writeBits(24, vorbisComment.length);\n        this.writer.write(headerBitstream.bytes);\n        this.writer.write(vorbisComment);\n        this.metadataWritten = true;\n    }\n    async getMimeType() {\n        return 'audio/flac';\n    }\n    async addEncodedVideoPacket() {\n        throw new Error('FLAC does not support video.');\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        validateAudioChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        assert(meta.decoderConfig.description);\n        try {\n            this.validateAndNormalizeTimestamp(track, packet.timestamp, packet.type === 'key');\n            if (this.sampleRate === null) {\n                this.sampleRate = meta.decoderConfig.sampleRate;\n            }\n            if (this.channels === null) {\n                this.channels = meta.decoderConfig.numberOfChannels;\n            }\n            if (this.bitsPerSample === null) {\n                const descriptionBitstream = new Bitstream(toUint8Array(meta.decoderConfig.description));\n                // skip 'fLaC' + block size + frame size + sample rate + number of channels\n                // See demuxer for the exact structure\n                descriptionBitstream.skipBits(103 + 64);\n                const bitsPerSample = descriptionBitstream.readBits(5) + 1;\n                this.bitsPerSample = bitsPerSample;\n            }\n            if (!this.metadataWritten) {\n                this.writeVorbisCommentAndPictureBlock();\n            }\n            const slice = FileSlice.tempFromBytes(packet.data);\n            readBytes(slice, 2);\n            const bytes = readBytes(slice, 2);\n            const bitstream = new Bitstream(bytes);\n            const blockSizeOrUncommon = getBlockSizeOrUncommon(bitstream.readBits(4));\n            if (blockSizeOrUncommon === null) {\n                throw new Error('Invalid FLAC frame: Invalid block size.');\n            }\n            readCodedNumber(slice); // num\n            const blockSize = readBlockSize(slice, blockSizeOrUncommon);\n            this.blockSizes.push(blockSize);\n            this.frameSizes.push(packet.data.length);\n            const startPos = this.writer.getPos();\n            this.writer.write(packet.data);\n            if (this.format._options.onFrame) {\n                this.format._options.onFrame(packet.data, startPos);\n            }\n            await this.writer.flush();\n        }\n        finally {\n            release();\n        }\n    }\n    addSubtitleCue() {\n        throw new Error('FLAC does not support subtitles.');\n    }\n    async finalize() {\n        const release = await this.mutex.acquire();\n        let minimumBlockSize = Infinity;\n        let maximumBlockSize = 0;\n        let minimumFrameSize = Infinity;\n        let maximumFrameSize = 0;\n        let totalSamples = 0;\n        for (let i = 0; i < this.blockSizes.length; i++) {\n            minimumFrameSize = Math.min(minimumFrameSize, this.frameSizes[i]);\n            maximumFrameSize = Math.max(maximumFrameSize, this.frameSizes[i]);\n            maximumBlockSize = Math.max(maximumBlockSize, this.blockSizes[i]);\n            totalSamples += this.blockSizes[i];\n            // Excluding the last frame from block size calculation\n            // https://www.rfc-editor.org/rfc/rfc9639.html#name-streaminfo\n            // \"The minimum block size (in samples) used in the stream, excluding the last block.\"\n            const isLastFrame = i === this.blockSizes.length - 1;\n            if (isLastFrame) {\n                continue;\n            }\n            minimumBlockSize = Math.min(minimumBlockSize, this.blockSizes[i]);\n        }\n        assert(this.sampleRate !== null);\n        assert(this.channels !== null);\n        assert(this.bitsPerSample !== null);\n        this.writer.seek(4);\n        this.writeHeader({\n            minimumBlockSize,\n            maximumBlockSize,\n            minimumFrameSize,\n            maximumFrameSize,\n            sampleRate: this.sampleRate,\n            channels: this.channels,\n            bitsPerSample: this.bitsPerSample,\n            totalSamples,\n        });\n        release();\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nconst cueBlockHeaderRegex = /(?:(.+?)\\n)?((?:\\d{2}:)?\\d{2}:\\d{2}.\\d{3})\\s+-->\\s+((?:\\d{2}:)?\\d{2}:\\d{2}.\\d{3})/g;\nconst preambleStartRegex = /^WEBVTT(.|\\n)*?\\n{2}/;\nexport const inlineTimestampRegex = /<(?:(\\d{2}):)?(\\d{2}):(\\d{2}).(\\d{3})>/g;\nexport class SubtitleParser {\n    constructor(options) {\n        this.preambleText = null;\n        this.preambleEmitted = false;\n        this.options = options;\n    }\n    parse(text) {\n        text = text.replaceAll('\\r\\n', '\\n').replaceAll('\\r', '\\n');\n        cueBlockHeaderRegex.lastIndex = 0;\n        let match;\n        if (!this.preambleText) {\n            if (!preambleStartRegex.test(text)) {\n                throw new Error('WebVTT preamble incorrect.');\n            }\n            match = cueBlockHeaderRegex.exec(text);\n            const preamble = text.slice(0, match?.index ?? text.length).trimEnd();\n            if (!preamble) {\n                throw new Error('No WebVTT preamble provided.');\n            }\n            this.preambleText = preamble;\n            if (match) {\n                text = text.slice(match.index);\n                cueBlockHeaderRegex.lastIndex = 0;\n            }\n        }\n        while ((match = cueBlockHeaderRegex.exec(text))) {\n            const notes = text.slice(0, match.index);\n            const cueIdentifier = match[1];\n            const matchEnd = match.index + match[0].length;\n            const bodyStart = text.indexOf('\\n', matchEnd) + 1;\n            const cueSettings = text.slice(matchEnd, bodyStart).trim();\n            let bodyEnd = text.indexOf('\\n\\n', matchEnd);\n            if (bodyEnd === -1)\n                bodyEnd = text.length;\n            const startTime = parseSubtitleTimestamp(match[2]);\n            const endTime = parseSubtitleTimestamp(match[3]);\n            const duration = endTime - startTime;\n            const body = text.slice(bodyStart, bodyEnd).trim();\n            text = text.slice(bodyEnd).trimStart();\n            cueBlockHeaderRegex.lastIndex = 0;\n            const cue = {\n                timestamp: startTime / 1000,\n                duration: duration / 1000,\n                text: body,\n                identifier: cueIdentifier,\n                settings: cueSettings,\n                notes,\n            };\n            const meta = {};\n            if (!this.preambleEmitted) {\n                meta.config = {\n                    description: this.preambleText,\n                };\n                this.preambleEmitted = true;\n            }\n            this.options.output(cue, meta);\n        }\n    }\n}\nconst timestampRegex = /(?:(\\d{2}):)?(\\d{2}):(\\d{2}).(\\d{3})/;\nexport const parseSubtitleTimestamp = (string) => {\n    const match = timestampRegex.exec(string);\n    if (!match)\n        throw new Error('Expected match.');\n    return 60 * 60 * 1000 * Number(match[1] || '0')\n        + 60 * 1000 * Number(match[2])\n        + 1000 * Number(match[3])\n        + Number(match[4]);\n};\nexport const formatSubtitleTimestamp = (timestamp) => {\n    const hours = Math.floor(timestamp / (60 * 60 * 1000));\n    const minutes = Math.floor((timestamp % (60 * 60 * 1000)) / (60 * 1000));\n    const seconds = Math.floor((timestamp % (60 * 1000)) / 1000);\n    const milliseconds = timestamp % 1000;\n    return hours.toString().padStart(2, '0') + ':'\n        + minutes.toString().padStart(2, '0') + ':'\n        + seconds.toString().padStart(2, '0') + '.'\n        + milliseconds.toString().padStart(3, '0');\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { toUint8Array, assert, isU32, last, textEncoder, COLOR_PRIMARIES_MAP, TRANSFER_CHARACTERISTICS_MAP, MATRIX_COEFFICIENTS_MAP, colorSpaceIsComplete, UNDETERMINED_LANGUAGE, assertNever, keyValueIterator, } from '../misc.js';\nimport { generateAv1CodecConfigurationFromCodecString, parsePcmCodec, PCM_AUDIO_CODECS, } from '../codec.js';\nimport { formatSubtitleTimestamp } from '../subtitles.js';\nimport { getTrackMetadata, GLOBAL_TIMESCALE, intoTimescale, } from './isobmff-muxer.js';\nimport { parseOpusIdentificationHeader } from '../codec-data.js';\nimport { RichImageData } from '../metadata.js';\nexport class IsobmffBoxWriter {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n        /**\n         * Stores the position from the start of the file to where boxes elements have been written. This is used to\n         * rewrite/edit elements that were already added before, and to measure sizes of things.\n         */\n        this.offsets = new WeakMap();\n    }\n    writeU32(value) {\n        this.helperView.setUint32(0, value, false);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeU64(value) {\n        this.helperView.setUint32(0, Math.floor(value / 2 ** 32), false);\n        this.helperView.setUint32(4, value, false);\n        this.writer.write(this.helper.subarray(0, 8));\n    }\n    writeAscii(text) {\n        for (let i = 0; i < text.length; i++) {\n            this.helperView.setUint8(i % 8, text.charCodeAt(i));\n            if (i % 8 === 7)\n                this.writer.write(this.helper);\n        }\n        if (text.length % 8 !== 0) {\n            this.writer.write(this.helper.subarray(0, text.length % 8));\n        }\n    }\n    writeBox(box) {\n        this.offsets.set(box, this.writer.getPos());\n        if (box.contents && !box.children) {\n            this.writeBoxHeader(box, box.size ?? box.contents.byteLength + 8);\n            this.writer.write(box.contents);\n        }\n        else {\n            const startPos = this.writer.getPos();\n            this.writeBoxHeader(box, 0);\n            if (box.contents)\n                this.writer.write(box.contents);\n            if (box.children)\n                for (const child of box.children)\n                    if (child)\n                        this.writeBox(child);\n            const endPos = this.writer.getPos();\n            const size = box.size ?? endPos - startPos;\n            this.writer.seek(startPos);\n            this.writeBoxHeader(box, size);\n            this.writer.seek(endPos);\n        }\n    }\n    writeBoxHeader(box, size) {\n        this.writeU32(box.largeSize ? 1 : size);\n        this.writeAscii(box.type);\n        if (box.largeSize)\n            this.writeU64(size);\n    }\n    measureBoxHeader(box) {\n        return 8 + (box.largeSize ? 8 : 0);\n    }\n    patchBox(box) {\n        const boxOffset = this.offsets.get(box);\n        assert(boxOffset !== undefined);\n        const endPos = this.writer.getPos();\n        this.writer.seek(boxOffset);\n        this.writeBox(box);\n        this.writer.seek(endPos);\n    }\n    measureBox(box) {\n        if (box.contents && !box.children) {\n            const headerSize = this.measureBoxHeader(box);\n            return headerSize + box.contents.byteLength;\n        }\n        else {\n            let result = this.measureBoxHeader(box);\n            if (box.contents)\n                result += box.contents.byteLength;\n            if (box.children)\n                for (const child of box.children)\n                    if (child)\n                        result += this.measureBox(child);\n            return result;\n        }\n    }\n}\nconst bytes = /* #__PURE__ */ new Uint8Array(8);\nconst view = /* #__PURE__ */ new DataView(bytes.buffer);\nconst u8 = (value) => {\n    return [(value % 0x100 + 0x100) % 0x100];\n};\nconst u16 = (value) => {\n    view.setUint16(0, value, false);\n    return [bytes[0], bytes[1]];\n};\nconst i16 = (value) => {\n    view.setInt16(0, value, false);\n    return [bytes[0], bytes[1]];\n};\nconst u24 = (value) => {\n    view.setUint32(0, value, false);\n    return [bytes[1], bytes[2], bytes[3]];\n};\nconst u32 = (value) => {\n    view.setUint32(0, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst i32 = (value) => {\n    view.setInt32(0, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst u64 = (value) => {\n    view.setUint32(0, Math.floor(value / 2 ** 32), false);\n    view.setUint32(4, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]];\n};\nconst fixed_8_8 = (value) => {\n    view.setInt16(0, 2 ** 8 * value, false);\n    return [bytes[0], bytes[1]];\n};\nconst fixed_16_16 = (value) => {\n    view.setInt32(0, 2 ** 16 * value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst fixed_2_30 = (value) => {\n    view.setInt32(0, 2 ** 30 * value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst variableUnsignedInt = (value, byteLength) => {\n    const bytes = [];\n    let remaining = value;\n    do {\n        let byte = remaining & 0x7f;\n        remaining >>= 7;\n        // If this isn't the first byte we're adding (meaning there will be more bytes after it\n        // when we reverse the array), set the continuation bit\n        if (bytes.length > 0) {\n            byte |= 0x80;\n        }\n        bytes.push(byte);\n        if (byteLength !== undefined) {\n            byteLength--;\n        }\n    } while (remaining > 0 || byteLength);\n    // Reverse the array since we built it backwards\n    return bytes.reverse();\n};\nconst ascii = (text, nullTerminated = false) => {\n    const bytes = Array(text.length).fill(null).map((_, i) => text.charCodeAt(i));\n    if (nullTerminated)\n        bytes.push(0x00);\n    return bytes;\n};\nconst lastPresentedSample = (samples) => {\n    let result = null;\n    for (const sample of samples) {\n        if (!result || sample.timestamp > result.timestamp) {\n            result = sample;\n        }\n    }\n    return result;\n};\nconst rotationMatrix = (rotationInDegrees) => {\n    const theta = rotationInDegrees * (Math.PI / 180);\n    const cosTheta = Math.round(Math.cos(theta));\n    const sinTheta = Math.round(Math.sin(theta));\n    // Matrices are post-multiplied in ISOBMFF, meaning this is the transpose of your typical rotation matrix\n    return [\n        cosTheta, sinTheta, 0,\n        -sinTheta, cosTheta, 0,\n        0, 0, 1,\n    ];\n};\nconst IDENTITY_MATRIX = /* #__PURE__ */ rotationMatrix(0);\nconst matrixToBytes = (matrix) => {\n    return [\n        fixed_16_16(matrix[0]), fixed_16_16(matrix[1]), fixed_2_30(matrix[2]),\n        fixed_16_16(matrix[3]), fixed_16_16(matrix[4]), fixed_2_30(matrix[5]),\n        fixed_16_16(matrix[6]), fixed_16_16(matrix[7]), fixed_2_30(matrix[8]),\n    ];\n};\nexport const box = (type, contents, children) => ({\n    type,\n    contents: contents && new Uint8Array(contents.flat(10)),\n    children,\n});\n/** A FullBox always starts with a version byte, followed by three flag bytes. */\nexport const fullBox = (type, version, flags, contents, children) => box(type, [u8(version), u24(flags), contents ?? []], children);\n/**\n * File Type Compatibility Box: Allows the reader to determine whether this is a type of file that the\n * reader understands.\n */\nexport const ftyp = (details) => {\n    // You can find the full logic for this at\n    // https://github.com/FFmpeg/FFmpeg/blob/de2fb43e785773738c660cdafb9309b1ef1bc80d/libavformat/movenc.c#L5518\n    // Obviously, this lib only needs a small subset of that logic.\n    const minorVersion = 0x200;\n    if (details.isQuickTime) {\n        return box('ftyp', [\n            ascii('qt  '), // Major brand\n            u32(minorVersion), // Minor version\n            // Compatible brands\n            ascii('qt  '),\n        ]);\n    }\n    if (details.fragmented) {\n        return box('ftyp', [\n            ascii('iso5'), // Major brand\n            u32(minorVersion), // Minor version\n            // Compatible brands\n            ascii('iso5'),\n            ascii('iso6'),\n            ascii('mp41'),\n        ]);\n    }\n    return box('ftyp', [\n        ascii('isom'), // Major brand\n        u32(minorVersion), // Minor version\n        // Compatible brands\n        ascii('isom'),\n        details.holdsAvc ? ascii('avc1') : [],\n        ascii('mp41'),\n    ]);\n};\n/** Movie Sample Data Box. Contains the actual frames/samples of the media. */\nexport const mdat = (reserveLargeSize) => ({ type: 'mdat', largeSize: reserveLargeSize });\n/** Free Space Box: A box that designates unused space in the movie data file. */\nexport const free = (size) => ({ type: 'free', size });\n/**\n * Movie Box: Used to specify the information that defines a movie - that is, the information that allows\n * an application to interpret the sample data that is stored elsewhere.\n */\nexport const moov = (muxer) => box('moov', undefined, [\n    mvhd(muxer.creationTime, muxer.trackDatas),\n    ...muxer.trackDatas.map(x => trak(x, muxer.creationTime)),\n    muxer.isFragmented ? mvex(muxer.trackDatas) : null,\n    udta(muxer),\n]);\n/** Movie Header Box: Used to specify the characteristics of the entire movie, such as timescale and duration. */\nexport const mvhd = (creationTime, trackDatas) => {\n    const duration = intoTimescale(Math.max(0, ...trackDatas\n        .filter(x => x.samples.length > 0)\n        .map((x) => {\n        const lastSample = lastPresentedSample(x.samples);\n        return lastSample.timestamp + lastSample.duration;\n    })), GLOBAL_TIMESCALE);\n    const nextTrackId = Math.max(0, ...trackDatas.map(x => x.track.id)) + 1;\n    // Conditionally use u64 if u32 isn't enough\n    const needsU64 = !isU32(creationTime) || !isU32(duration);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    return fullBox('mvhd', +needsU64, 0, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(GLOBAL_TIMESCALE), // Timescale\n        u32OrU64(duration), // Duration\n        fixed_16_16(1), // Preferred rate\n        fixed_8_8(1), // Preferred volume\n        Array(10).fill(0), // Reserved\n        matrixToBytes(IDENTITY_MATRIX), // Matrix\n        Array(24).fill(0), // Pre-defined\n        u32(nextTrackId), // Next track ID\n    ]);\n};\n/**\n * Track Box: Defines a single track of a movie. A movie may consist of one or more tracks. Each track is\n * independent of the other tracks in the movie and carries its own temporal and spatial information. Each Track Box\n * contains its associated Media Box.\n */\nexport const trak = (trackData, creationTime) => {\n    const trackMetadata = getTrackMetadata(trackData);\n    return box('trak', undefined, [\n        tkhd(trackData, creationTime),\n        mdia(trackData, creationTime),\n        trackMetadata.name !== undefined\n            ? box('udta', undefined, [\n                box('name', [\n                    ...textEncoder.encode(trackMetadata.name),\n                ]),\n            ])\n            : null,\n    ]);\n};\n/** Track Header Box: Specifies the characteristics of a single track within a movie. */\nexport const tkhd = (trackData, creationTime) => {\n    const lastSample = lastPresentedSample(trackData.samples);\n    const durationInGlobalTimescale = intoTimescale(lastSample ? lastSample.timestamp + lastSample.duration : 0, GLOBAL_TIMESCALE);\n    const needsU64 = !isU32(creationTime) || !isU32(durationInGlobalTimescale);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    let matrix;\n    if (trackData.type === 'video') {\n        const rotation = trackData.track.metadata.rotation;\n        matrix = rotationMatrix(rotation ?? 0);\n    }\n    else {\n        matrix = IDENTITY_MATRIX;\n    }\n    let flags = 0x2; // Track in movie\n    if (trackData.track.metadata.disposition?.default !== false) {\n        flags |= 0x1; // Track enabled\n    }\n    return fullBox('tkhd', +needsU64, flags, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(trackData.track.id), // Track ID\n        u32(0), // Reserved\n        u32OrU64(durationInGlobalTimescale), // Duration\n        Array(8).fill(0), // Reserved\n        u16(0), // Layer\n        u16(trackData.track.id), // Alternate group\n        fixed_8_8(trackData.type === 'audio' ? 1 : 0), // Volume\n        u16(0), // Reserved\n        matrixToBytes(matrix), // Matrix\n        fixed_16_16(trackData.type === 'video' ? trackData.info.width : 0), // Track width\n        fixed_16_16(trackData.type === 'video' ? trackData.info.height : 0), // Track height\n    ]);\n};\n/** Media Box: Describes and define a track's media type and sample data. */\nexport const mdia = (trackData, creationTime) => box('mdia', undefined, [\n    mdhd(trackData, creationTime),\n    hdlr(true, TRACK_TYPE_TO_COMPONENT_SUBTYPE[trackData.type], TRACK_TYPE_TO_HANDLER_NAME[trackData.type]),\n    minf(trackData),\n]);\n/** Media Header Box: Specifies the characteristics of a media, including timescale and duration. */\nexport const mdhd = (trackData, creationTime) => {\n    const lastSample = lastPresentedSample(trackData.samples);\n    const localDuration = intoTimescale(lastSample ? lastSample.timestamp + lastSample.duration : 0, trackData.timescale);\n    const needsU64 = !isU32(creationTime) || !isU32(localDuration);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    return fullBox('mdhd', +needsU64, 0, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(trackData.timescale), // Timescale\n        u32OrU64(localDuration), // Duration\n        u16(getLanguageCodeInt(trackData.track.metadata.languageCode ?? UNDETERMINED_LANGUAGE)), // Language\n        u16(0), // Quality\n    ]);\n};\nconst TRACK_TYPE_TO_COMPONENT_SUBTYPE = {\n    video: 'vide',\n    audio: 'soun',\n    subtitle: 'text',\n};\nconst TRACK_TYPE_TO_HANDLER_NAME = {\n    video: 'MediabunnyVideoHandler',\n    audio: 'MediabunnySoundHandler',\n    subtitle: 'MediabunnyTextHandler',\n};\n/** Handler Reference Box. */\nexport const hdlr = (hasComponentType, handlerType, name, manufacturer = '\\0\\0\\0\\0') => fullBox('hdlr', 0, 0, [\n    hasComponentType ? ascii('mhlr') : u32(0), // Component type\n    ascii(handlerType), // Component subtype\n    ascii(manufacturer), // Component manufacturer\n    u32(0), // Component flags\n    u32(0), // Component flags mask\n    ascii(name, true), // Component name\n]);\n/**\n * Media Information Box: Stores handler-specific information for a track's media data. The media handler uses this\n * information to map from media time to media data and to process the media data.\n */\nexport const minf = (trackData) => box('minf', undefined, [\n    TRACK_TYPE_TO_HEADER_BOX[trackData.type](),\n    dinf(),\n    stbl(trackData),\n]);\n/** Video Media Information Header Box: Defines specific color and graphics mode information. */\nexport const vmhd = () => fullBox('vmhd', 0, 1, [\n    u16(0), // Graphics mode\n    u16(0), // Opcolor R\n    u16(0), // Opcolor G\n    u16(0), // Opcolor B\n]);\n/** Sound Media Information Header Box: Stores the sound media's control information, such as balance. */\nexport const smhd = () => fullBox('smhd', 0, 0, [\n    u16(0), // Balance\n    u16(0), // Reserved\n]);\n/** Null Media Header Box. */\nexport const nmhd = () => fullBox('nmhd', 0, 0);\nconst TRACK_TYPE_TO_HEADER_BOX = {\n    video: vmhd,\n    audio: smhd,\n    subtitle: nmhd,\n};\n/**\n * Data Information Box: Contains information specifying the data handler component that provides access to the\n * media data. The data handler component uses the Data Information Box to interpret the media's data.\n */\nexport const dinf = () => box('dinf', undefined, [\n    dref(),\n]);\n/**\n * Data Reference Box: Contains tabular data that instructs the data handler component how to access the media's data.\n */\nexport const dref = () => fullBox('dref', 0, 0, [\n    u32(1), // Entry count\n], [\n    url(),\n]);\nexport const url = () => fullBox('url ', 0, 1); // Self-reference flag enabled\n/**\n * Sample Table Box: Contains information for converting from media time to sample number to sample location. This box\n * also indicates how to interpret the sample (for example, whether to decompress the video data and, if so, how).\n */\nexport const stbl = (trackData) => {\n    const needsCtts = trackData.compositionTimeOffsetTable.length > 1\n        || trackData.compositionTimeOffsetTable.some(x => x.sampleCompositionTimeOffset !== 0);\n    return box('stbl', undefined, [\n        stsd(trackData),\n        stts(trackData),\n        needsCtts ? ctts(trackData) : null,\n        needsCtts ? cslg(trackData) : null,\n        stsc(trackData),\n        stsz(trackData),\n        stco(trackData),\n        stss(trackData),\n    ]);\n};\n/**\n * Sample Description Box: Stores information that allows you to decode samples in the media. The data stored in the\n * sample description varies, depending on the media type.\n */\nexport const stsd = (trackData) => {\n    let sampleDescription;\n    if (trackData.type === 'video') {\n        sampleDescription = videoSampleDescription(videoCodecToBoxName(trackData.track.source._codec, trackData.info.decoderConfig.codec), trackData);\n    }\n    else if (trackData.type === 'audio') {\n        const boxName = audioCodecToBoxName(trackData.track.source._codec, trackData.muxer.isQuickTime);\n        assert(boxName);\n        sampleDescription = soundSampleDescription(boxName, trackData);\n    }\n    else if (trackData.type === 'subtitle') {\n        sampleDescription = subtitleSampleDescription(SUBTITLE_CODEC_TO_BOX_NAME[trackData.track.source._codec], trackData);\n    }\n    assert(sampleDescription);\n    return fullBox('stsd', 0, 0, [\n        u32(1), // Entry count\n    ], [\n        sampleDescription,\n    ]);\n};\n/** Video Sample Description Box: Contains information that defines how to interpret video media data. */\nexport const videoSampleDescription = (compressionType, trackData) => box(compressionType, [\n    Array(6).fill(0), // Reserved\n    u16(1), // Data reference index\n    u16(0), // Pre-defined\n    u16(0), // Reserved\n    Array(12).fill(0), // Pre-defined\n    u16(trackData.info.width), // Width\n    u16(trackData.info.height), // Height\n    u32(0x00480000), // Horizontal resolution\n    u32(0x00480000), // Vertical resolution\n    u32(0), // Reserved\n    u16(1), // Frame count\n    Array(32).fill(0), // Compressor name\n    u16(0x0018), // Depth\n    i16(0xffff), // Pre-defined\n], [\n    VIDEO_CODEC_TO_CONFIGURATION_BOX[trackData.track.source._codec](trackData),\n    colorSpaceIsComplete(trackData.info.decoderConfig.colorSpace) ? colr(trackData) : null,\n]);\n/** Colour Information Box: Specifies the color space of the video. */\nexport const colr = (trackData) => box('colr', [\n    ascii('nclx'), // Colour type\n    u16(COLOR_PRIMARIES_MAP[trackData.info.decoderConfig.colorSpace.primaries]), // Colour primaries\n    u16(TRANSFER_CHARACTERISTICS_MAP[trackData.info.decoderConfig.colorSpace.transfer]), // Transfer characteristics\n    u16(MATRIX_COEFFICIENTS_MAP[trackData.info.decoderConfig.colorSpace.matrix]), // Matrix coefficients\n    u8((trackData.info.decoderConfig.colorSpace.fullRange ? 1 : 0) << 7), // Full range flag\n]);\n/** AVC Configuration Box: Provides additional information to the decoder. */\nexport const avcC = (trackData) => trackData.info.decoderConfig && box('avcC', [\n    // For AVC, description is an AVCDecoderConfigurationRecord, so nothing else to do here\n    ...toUint8Array(trackData.info.decoderConfig.description),\n]);\n/** HEVC Configuration Box: Provides additional information to the decoder. */\nexport const hvcC = (trackData) => trackData.info.decoderConfig && box('hvcC', [\n    // For HEVC, description is an HEVCDecoderConfigurationRecord, so nothing else to do here\n    ...toUint8Array(trackData.info.decoderConfig.description),\n]);\n/** VP Configuration Box: Provides additional information to the decoder. */\nexport const vpcC = (trackData) => {\n    // Reference: https://www.webmproject.org/vp9/mp4/\n    if (!trackData.info.decoderConfig) {\n        return null;\n    }\n    const decoderConfig = trackData.info.decoderConfig;\n    const parts = decoderConfig.codec.split('.'); // We can derive the required values from the codec string\n    const profile = Number(parts[1]);\n    const level = Number(parts[2]);\n    const bitDepth = Number(parts[3]);\n    const chromaSubsampling = parts[4] ? Number(parts[4]) : 1; // 4:2:0 colocated with luma (0,0)\n    const videoFullRangeFlag = parts[8] ? Number(parts[8]) : Number(decoderConfig.colorSpace?.fullRange ?? 0);\n    const thirdByte = (bitDepth << 4) + (chromaSubsampling << 1) + videoFullRangeFlag;\n    const colourPrimaries = parts[5]\n        ? Number(parts[5])\n        : decoderConfig.colorSpace?.primaries\n            ? COLOR_PRIMARIES_MAP[decoderConfig.colorSpace.primaries]\n            : 2; // Default to undetermined\n    const transferCharacteristics = parts[6]\n        ? Number(parts[6])\n        : decoderConfig.colorSpace?.transfer\n            ? TRANSFER_CHARACTERISTICS_MAP[decoderConfig.colorSpace.transfer]\n            : 2;\n    const matrixCoefficients = parts[7]\n        ? Number(parts[7])\n        : decoderConfig.colorSpace?.matrix\n            ? MATRIX_COEFFICIENTS_MAP[decoderConfig.colorSpace.matrix]\n            : 2;\n    return fullBox('vpcC', 1, 0, [\n        u8(profile), // Profile\n        u8(level), // Level\n        u8(thirdByte), // Bit depth, chroma subsampling, full range\n        u8(colourPrimaries), // Colour primaries\n        u8(transferCharacteristics), // Transfer characteristics\n        u8(matrixCoefficients), // Matrix coefficients\n        u16(0), // Codec initialization data size\n    ]);\n};\n/** AV1 Configuration Box: Provides additional information to the decoder. */\nexport const av1C = (trackData) => {\n    return box('av1C', generateAv1CodecConfigurationFromCodecString(trackData.info.decoderConfig.codec));\n};\n/** Sound Sample Description Box: Contains information that defines how to interpret sound media data. */\nexport const soundSampleDescription = (compressionType, trackData) => {\n    let version = 0;\n    let contents;\n    let sampleSizeInBits = 16;\n    if (PCM_AUDIO_CODECS.includes(trackData.track.source._codec)) {\n        const codec = trackData.track.source._codec;\n        const { sampleSize } = parsePcmCodec(codec);\n        sampleSizeInBits = 8 * sampleSize;\n        if (sampleSizeInBits > 16) {\n            version = 1;\n        }\n    }\n    if (version === 0) {\n        contents = [\n            Array(6).fill(0), // Reserved\n            u16(1), // Data reference index\n            u16(version), // Version\n            u16(0), // Revision level\n            u32(0), // Vendor\n            u16(trackData.info.numberOfChannels), // Number of channels\n            u16(sampleSizeInBits), // Sample size (bits)\n            u16(0), // Compression ID\n            u16(0), // Packet size\n            u16(trackData.info.sampleRate < 2 ** 16 ? trackData.info.sampleRate : 0), // Sample rate (upper)\n            u16(0), // Sample rate (lower)\n        ];\n    }\n    else {\n        contents = [\n            Array(6).fill(0), // Reserved\n            u16(1), // Data reference index\n            u16(version), // Version\n            u16(0), // Revision level\n            u32(0), // Vendor\n            u16(trackData.info.numberOfChannels), // Number of channels\n            u16(Math.min(sampleSizeInBits, 16)), // Sample size (bits)\n            u16(0), // Compression ID\n            u16(0), // Packet size\n            u16(trackData.info.sampleRate < 2 ** 16 ? trackData.info.sampleRate : 0), // Sample rate (upper)\n            u16(0), // Sample rate (lower)\n            u32(1), // Samples per packet (must be 1 for uncompressed formats)\n            u32(sampleSizeInBits / 8), // Bytes per packet\n            u32(trackData.info.numberOfChannels * sampleSizeInBits / 8), // Bytes per frame\n            u32(2), // Bytes per sample (constant in FFmpeg)\n        ];\n    }\n    return box(compressionType, contents, [\n        audioCodecToConfigurationBox(trackData.track.source._codec, trackData.muxer.isQuickTime)?.(trackData) ?? null,\n    ]);\n};\n/** MPEG-4 Elementary Stream Descriptor Box. */\nexport const esds = (trackData) => {\n    // We build up the bytes in a layered way which reflects the nested structure\n    let objectTypeIndication;\n    switch (trackData.track.source._codec) {\n        case 'aac':\n            {\n                objectTypeIndication = 0x40;\n            }\n            ;\n            break;\n        case 'mp3':\n            {\n                objectTypeIndication = 0x6b;\n            }\n            ;\n            break;\n        case 'vorbis':\n            {\n                objectTypeIndication = 0xdd;\n            }\n            ;\n            break;\n        default: throw new Error(`Unhandled audio codec: ${trackData.track.source._codec}`);\n    }\n    let bytes = [\n        ...u8(objectTypeIndication), // Object type indication\n        ...u8(0x15), // stream type(6bits)=5 audio, flags(2bits)=1\n        ...u24(0), // 24bit buffer size\n        ...u32(0), // max bitrate\n        ...u32(0), // avg bitrate\n    ];\n    if (trackData.info.decoderConfig.description) {\n        const description = toUint8Array(trackData.info.decoderConfig.description);\n        // Add the decoder description to the end\n        bytes = [\n            ...bytes,\n            ...u8(0x05), // TAG(5) = DecoderSpecificInfo\n            ...variableUnsignedInt(description.byteLength),\n            ...description,\n        ];\n    }\n    bytes = [\n        ...u16(1), // ES_ID = 1\n        ...u8(0x00), // flags etc = 0\n        ...u8(0x04), // TAG(4) = ES Descriptor\n        ...variableUnsignedInt(bytes.length),\n        ...bytes,\n        ...u8(0x06), // TAG(6)\n        ...u8(0x01), // length\n        ...u8(0x02), // data\n    ];\n    bytes = [\n        ...u8(0x03), // TAG(3) = Object Descriptor\n        ...variableUnsignedInt(bytes.length),\n        ...bytes,\n    ];\n    return fullBox('esds', 0, 0, bytes);\n};\nexport const wave = (trackData) => {\n    return box('wave', undefined, [\n        frma(trackData),\n        enda(trackData),\n        box('\\x00\\x00\\x00\\x00'), // NULL tag at the end\n    ]);\n};\nexport const frma = (trackData) => {\n    return box('frma', [\n        ascii(audioCodecToBoxName(trackData.track.source._codec, trackData.muxer.isQuickTime)),\n    ]);\n};\n// This box specifies PCM endianness\nexport const enda = (trackData) => {\n    const { littleEndian } = parsePcmCodec(trackData.track.source._codec);\n    return box('enda', [\n        u16(+littleEndian),\n    ]);\n};\n/** Opus Specific Box. */\nexport const dOps = (trackData) => {\n    let outputChannelCount = trackData.info.numberOfChannels;\n    // Default PreSkip, should be at least 80 milliseconds worth of playback, measured in 48000 Hz samples\n    let preSkip = 3840;\n    let inputSampleRate = trackData.info.sampleRate;\n    let outputGain = 0;\n    let channelMappingFamily = 0;\n    let channelMappingTable = new Uint8Array(0);\n    // Read preskip and from codec private data from the encoder\n    // https://www.rfc-editor.org/rfc/rfc7845#section-5\n    const description = trackData.info.decoderConfig?.description;\n    if (description) {\n        assert(description.byteLength >= 18);\n        const bytes = toUint8Array(description);\n        const header = parseOpusIdentificationHeader(bytes);\n        outputChannelCount = header.outputChannelCount;\n        preSkip = header.preSkip;\n        inputSampleRate = header.inputSampleRate;\n        outputGain = header.outputGain;\n        channelMappingFamily = header.channelMappingFamily;\n        if (header.channelMappingTable) {\n            channelMappingTable = header.channelMappingTable;\n        }\n    }\n    // https://www.opus-codec.org/docs/opus_in_isobmff.html\n    return box('dOps', [\n        u8(0), // Version\n        u8(outputChannelCount), // OutputChannelCount\n        u16(preSkip), // PreSkip\n        u32(inputSampleRate), // InputSampleRate\n        i16(outputGain), // OutputGain\n        u8(channelMappingFamily), // ChannelMappingFamily\n        ...channelMappingTable,\n    ]);\n};\n/** FLAC specific box. */\nexport const dfLa = (trackData) => {\n    const description = trackData.info.decoderConfig?.description;\n    assert(description);\n    const bytes = toUint8Array(description);\n    return fullBox('dfLa', 0, 0, [\n        ...bytes.subarray(4),\n    ]);\n};\n/** PCM Configuration Box, ISO/IEC 23003-5. */\nconst pcmC = (trackData) => {\n    const { littleEndian, sampleSize } = parsePcmCodec(trackData.track.source._codec);\n    const formatFlags = +littleEndian;\n    return fullBox('pcmC', 0, 0, [\n        u8(formatFlags),\n        u8(8 * sampleSize),\n    ]);\n};\nexport const subtitleSampleDescription = (compressionType, trackData) => box(compressionType, [\n    Array(6).fill(0), // Reserved\n    u16(1), // Data reference index\n], [\n    SUBTITLE_CODEC_TO_CONFIGURATION_BOX[trackData.track.source._codec](trackData),\n]);\nexport const vttC = (trackData) => box('vttC', [\n    ...textEncoder.encode(trackData.info.config.description),\n]);\nexport const txtC = (textConfig) => fullBox('txtC', 0, 0, [\n    ...textConfig, 0, // Text config (null-terminated)\n]);\n/**\n * Time-To-Sample Box: Stores duration information for a media's samples, providing a mapping from a time in a media\n * to the corresponding data sample. The table is compact, meaning that consecutive samples with the same time delta\n * will be grouped.\n */\nexport const stts = (trackData) => {\n    return fullBox('stts', 0, 0, [\n        u32(trackData.timeToSampleTable.length), // Number of entries\n        trackData.timeToSampleTable.map(x => [\n            u32(x.sampleCount), // Sample count\n            u32(x.sampleDelta), // Sample duration\n        ]),\n    ]);\n};\n/** Sync Sample Box: Identifies the key frames in the media, marking the random access points within a stream. */\nexport const stss = (trackData) => {\n    if (trackData.samples.every(x => x.type === 'key'))\n        return null; // No stss box -> every frame is a key frame\n    const keySamples = [...trackData.samples.entries()].filter(([, sample]) => sample.type === 'key');\n    return fullBox('stss', 0, 0, [\n        u32(keySamples.length), // Number of entries\n        keySamples.map(([index]) => u32(index + 1)), // Sync sample table\n    ]);\n};\n/**\n * Sample-To-Chunk Box: As samples are added to a media, they are collected into chunks that allow optimized data\n * access. A chunk contains one or more samples. Chunks in a media may have different sizes, and the samples within a\n * chunk may have different sizes. The Sample-To-Chunk Box stores chunk information for the samples in a media, stored\n * in a compactly-coded fashion.\n */\nexport const stsc = (trackData) => {\n    return fullBox('stsc', 0, 0, [\n        u32(trackData.compactlyCodedChunkTable.length), // Number of entries\n        trackData.compactlyCodedChunkTable.map(x => [\n            u32(x.firstChunk), // First chunk\n            u32(x.samplesPerChunk), // Samples per chunk\n            u32(1), // Sample description index\n        ]),\n    ]);\n};\n/** Sample Size Box: Specifies the byte size of each sample in the media. */\nexport const stsz = (trackData) => {\n    if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n        const { sampleSize } = parsePcmCodec(trackData.track.source._codec);\n        // With PCM, every sample has the same size\n        return fullBox('stsz', 0, 0, [\n            u32(sampleSize * trackData.info.numberOfChannels), // Sample size\n            u32(trackData.samples.reduce((acc, x) => acc + intoTimescale(x.duration, trackData.timescale), 0)),\n        ]);\n    }\n    return fullBox('stsz', 0, 0, [\n        u32(0), // Sample size (0 means non-constant size)\n        u32(trackData.samples.length), // Number of entries\n        trackData.samples.map(x => u32(x.size)), // Sample size table\n    ]);\n};\n/** Chunk Offset Box: Identifies the location of each chunk of data in the media's data stream, relative to the file. */\nexport const stco = (trackData) => {\n    if (trackData.finalizedChunks.length > 0 && last(trackData.finalizedChunks).offset >= 2 ** 32) {\n        // If the file is large, use the co64 box\n        return fullBox('co64', 0, 0, [\n            u32(trackData.finalizedChunks.length), // Number of entries\n            trackData.finalizedChunks.map(x => u64(x.offset)), // Chunk offset table\n        ]);\n    }\n    return fullBox('stco', 0, 0, [\n        u32(trackData.finalizedChunks.length), // Number of entries\n        trackData.finalizedChunks.map(x => u32(x.offset)), // Chunk offset table\n    ]);\n};\n/**\n * Composition Time to Sample Box: Stores composition time offset information (PTS-DTS) for a\n * media's samples. The table is compact, meaning that consecutive samples with the same time\n * composition time offset will be grouped.\n */\nexport const ctts = (trackData) => {\n    return fullBox('ctts', 1, 0, [\n        u32(trackData.compositionTimeOffsetTable.length), // Number of entries\n        trackData.compositionTimeOffsetTable.map(x => [\n            u32(x.sampleCount), // Sample count\n            i32(x.sampleCompositionTimeOffset), // Sample offset\n        ]),\n    ]);\n};\n/**\n * Composition to Decode Box: Stores information about the composition and display times of the media samples.\n */\nexport const cslg = (trackData) => {\n    let leastDecodeToDisplayDelta = Infinity;\n    let greatestDecodeToDisplayDelta = -Infinity;\n    let compositionStartTime = Infinity;\n    let compositionEndTime = -Infinity;\n    assert(trackData.compositionTimeOffsetTable.length > 0);\n    assert(trackData.samples.length > 0);\n    for (let i = 0; i < trackData.compositionTimeOffsetTable.length; i++) {\n        const entry = trackData.compositionTimeOffsetTable[i];\n        leastDecodeToDisplayDelta = Math.min(leastDecodeToDisplayDelta, entry.sampleCompositionTimeOffset);\n        greatestDecodeToDisplayDelta = Math.max(greatestDecodeToDisplayDelta, entry.sampleCompositionTimeOffset);\n    }\n    for (let i = 0; i < trackData.samples.length; i++) {\n        const sample = trackData.samples[i];\n        compositionStartTime = Math.min(compositionStartTime, intoTimescale(sample.timestamp, trackData.timescale));\n        compositionEndTime = Math.max(compositionEndTime, intoTimescale(sample.timestamp + sample.duration, trackData.timescale));\n    }\n    const compositionToDtsShift = Math.max(-leastDecodeToDisplayDelta, 0);\n    if (compositionEndTime >= 2 ** 31) {\n        // For very large files, the composition end time can't be represented in i32, so let's just scrap the box in\n        // that case. QuickTime fails to read the file if there's a cslg box with version 1, so that's sadly not an\n        // option.\n        return null;\n    }\n    return fullBox('cslg', 0, 0, [\n        i32(compositionToDtsShift), // Composition to DTS shift\n        i32(leastDecodeToDisplayDelta), // Least decode to display delta\n        i32(greatestDecodeToDisplayDelta), // Greatest decode to display delta\n        i32(compositionStartTime), // Composition start time\n        i32(compositionEndTime), // Composition end time\n    ]);\n};\n/**\n * Movie Extends Box: This box signals to readers that the file is fragmented. Contains a single Track Extends Box\n * for each track in the movie.\n */\nexport const mvex = (trackDatas) => {\n    return box('mvex', undefined, trackDatas.map(trex));\n};\n/** Track Extends Box: Contains the default values used by the movie fragments. */\nexport const trex = (trackData) => {\n    return fullBox('trex', 0, 0, [\n        u32(trackData.track.id), // Track ID\n        u32(1), // Default sample description index\n        u32(0), // Default sample duration\n        u32(0), // Default sample size\n        u32(0), // Default sample flags\n    ]);\n};\n/**\n * Movie Fragment Box: The movie fragments extend the presentation in time. They provide the information that would\n * previously have been\tin the Movie Box.\n */\nexport const moof = (sequenceNumber, trackDatas) => {\n    return box('moof', undefined, [\n        mfhd(sequenceNumber),\n        ...trackDatas.map(traf),\n    ]);\n};\n/** Movie Fragment Header Box: Contains a sequence number as a safety check. */\nexport const mfhd = (sequenceNumber) => {\n    return fullBox('mfhd', 0, 0, [\n        u32(sequenceNumber), // Sequence number\n    ]);\n};\nconst fragmentSampleFlags = (sample) => {\n    let byte1 = 0;\n    let byte2 = 0;\n    const byte3 = 0;\n    const byte4 = 0;\n    const sampleIsDifferenceSample = sample.type === 'delta';\n    byte2 |= +sampleIsDifferenceSample;\n    if (sampleIsDifferenceSample) {\n        byte1 |= 1; // There is redundant coding in this sample\n    }\n    else {\n        byte1 |= 2; // There is no redundant coding in this sample\n    }\n    // Note that there are a lot of other flags to potentially set here, but most are irrelevant / non-necessary\n    return byte1 << 24 | byte2 << 16 | byte3 << 8 | byte4;\n};\n/** Track Fragment Box */\nexport const traf = (trackData) => {\n    return box('traf', undefined, [\n        tfhd(trackData),\n        tfdt(trackData),\n        trun(trackData),\n    ]);\n};\n/** Track Fragment Header Box: Provides a reference to the extended track, and flags. */\nexport const tfhd = (trackData) => {\n    assert(trackData.currentChunk);\n    let tfFlags = 0;\n    tfFlags |= 0x00008; // Default sample duration present\n    tfFlags |= 0x00010; // Default sample size present\n    tfFlags |= 0x00020; // Default sample flags present\n    tfFlags |= 0x20000; // Default base is moof\n    // Prefer the second sample over the first one, as the first one is a sync sample and therefore the \"odd one out\"\n    const referenceSample = trackData.currentChunk.samples[1] ?? trackData.currentChunk.samples[0];\n    const referenceSampleInfo = {\n        duration: referenceSample.timescaleUnitsToNextSample,\n        size: referenceSample.size,\n        flags: fragmentSampleFlags(referenceSample),\n    };\n    return fullBox('tfhd', 0, tfFlags, [\n        u32(trackData.track.id), // Track ID\n        u32(referenceSampleInfo.duration), // Default sample duration\n        u32(referenceSampleInfo.size), // Default sample size\n        u32(referenceSampleInfo.flags), // Default sample flags\n    ]);\n};\n/**\n * Track Fragment Decode Time Box: Provides the absolute decode time of the first sample of the fragment. This is\n * useful for performing random access on the media file.\n */\nexport const tfdt = (trackData) => {\n    assert(trackData.currentChunk);\n    return fullBox('tfdt', 1, 0, [\n        u64(intoTimescale(trackData.currentChunk.startTimestamp, trackData.timescale)), // Base Media Decode Time\n    ]);\n};\n/** Track Run Box: Specifies a run of contiguous samples for a given track. */\nexport const trun = (trackData) => {\n    assert(trackData.currentChunk);\n    const allSampleDurations = trackData.currentChunk.samples.map(x => x.timescaleUnitsToNextSample);\n    const allSampleSizes = trackData.currentChunk.samples.map(x => x.size);\n    const allSampleFlags = trackData.currentChunk.samples.map(fragmentSampleFlags);\n    const allSampleCompositionTimeOffsets = trackData.currentChunk.samples\n        .map(x => intoTimescale(x.timestamp - x.decodeTimestamp, trackData.timescale));\n    const uniqueSampleDurations = new Set(allSampleDurations);\n    const uniqueSampleSizes = new Set(allSampleSizes);\n    const uniqueSampleFlags = new Set(allSampleFlags);\n    const uniqueSampleCompositionTimeOffsets = new Set(allSampleCompositionTimeOffsets);\n    const firstSampleFlagsPresent = uniqueSampleFlags.size === 2 && allSampleFlags[0] !== allSampleFlags[1];\n    const sampleDurationPresent = uniqueSampleDurations.size > 1;\n    const sampleSizePresent = uniqueSampleSizes.size > 1;\n    const sampleFlagsPresent = !firstSampleFlagsPresent && uniqueSampleFlags.size > 1;\n    const sampleCompositionTimeOffsetsPresent = uniqueSampleCompositionTimeOffsets.size > 1 || [...uniqueSampleCompositionTimeOffsets].some(x => x !== 0);\n    let flags = 0;\n    flags |= 0x0001; // Data offset present\n    flags |= 0x0004 * +firstSampleFlagsPresent; // First sample flags present\n    flags |= 0x0100 * +sampleDurationPresent; // Sample duration present\n    flags |= 0x0200 * +sampleSizePresent; // Sample size present\n    flags |= 0x0400 * +sampleFlagsPresent; // Sample flags present\n    flags |= 0x0800 * +sampleCompositionTimeOffsetsPresent; // Sample composition time offsets present\n    return fullBox('trun', 1, flags, [\n        u32(trackData.currentChunk.samples.length), // Sample count\n        u32(trackData.currentChunk.offset - trackData.currentChunk.moofOffset || 0), // Data offset\n        firstSampleFlagsPresent ? u32(allSampleFlags[0]) : [],\n        trackData.currentChunk.samples.map((_, i) => [\n            sampleDurationPresent ? u32(allSampleDurations[i]) : [], // Sample duration\n            sampleSizePresent ? u32(allSampleSizes[i]) : [], // Sample size\n            sampleFlagsPresent ? u32(allSampleFlags[i]) : [], // Sample flags\n            // Sample composition time offsets\n            sampleCompositionTimeOffsetsPresent ? i32(allSampleCompositionTimeOffsets[i]) : [],\n        ]),\n    ]);\n};\n/**\n * Movie Fragment Random Access Box: For each track, provides pointers to sync samples within the file\n * for random access.\n */\nexport const mfra = (trackDatas) => {\n    return box('mfra', undefined, [\n        ...trackDatas.map(tfra),\n        mfro(),\n    ]);\n};\n/** Track Fragment Random Access Box: Provides pointers to sync samples within the file for random access. */\nexport const tfra = (trackData, trackIndex) => {\n    const version = 1; // Using this version allows us to use 64-bit time and offset values\n    return fullBox('tfra', version, 0, [\n        u32(trackData.track.id), // Track ID\n        u32(0b111111), // This specifies that traf number, trun number and sample number are 32-bit ints\n        u32(trackData.finalizedChunks.length), // Number of entries\n        trackData.finalizedChunks.map(chunk => [\n            u64(intoTimescale(chunk.samples[0].timestamp, trackData.timescale)), // Time (in presentation time)\n            u64(chunk.moofOffset), // moof offset\n            u32(trackIndex + 1), // traf number\n            u32(1), // trun number\n            u32(1), // Sample number\n        ]),\n    ]);\n};\n/**\n * Movie Fragment Random Access Offset Box: Provides the size of the enclosing mfra box. This box can be used by readers\n * to quickly locate the mfra box by searching from the end of the file.\n */\nexport const mfro = () => {\n    return fullBox('mfro', 0, 0, [\n        // This value needs to be overwritten manually from the outside, where the actual size of the enclosing mfra box\n        // is known\n        u32(0), // Size\n    ]);\n};\n/** VTT Empty Cue Box */\nexport const vtte = () => box('vtte');\n/** VTT Cue Box */\nexport const vttc = (payload, timestamp, identifier, settings, sourceId) => box('vttc', undefined, [\n    sourceId !== null ? box('vsid', [i32(sourceId)]) : null,\n    identifier !== null ? box('iden', [...textEncoder.encode(identifier)]) : null,\n    timestamp !== null ? box('ctim', [...textEncoder.encode(formatSubtitleTimestamp(timestamp))]) : null,\n    settings !== null ? box('sttg', [...textEncoder.encode(settings)]) : null,\n    box('payl', [...textEncoder.encode(payload)]),\n]);\n/** VTT Additional Text Box */\nexport const vtta = (notes) => box('vtta', [...textEncoder.encode(notes)]);\n/** User Data Box */\nconst udta = (muxer) => {\n    const boxes = [];\n    const metadataFormat = muxer.format._options.metadataFormat ?? 'auto';\n    const metadataTags = muxer.output._metadataTags;\n    // Depending on the format, metadata tags are written differently\n    if (metadataFormat === 'mdir' || (metadataFormat === 'auto' && !muxer.isQuickTime)) {\n        const metaBox = metaMdir(metadataTags);\n        if (metaBox)\n            boxes.push(metaBox);\n    }\n    else if (metadataFormat === 'mdta') {\n        const metaBox = metaMdta(metadataTags);\n        if (metaBox)\n            boxes.push(metaBox);\n    }\n    else if (metadataFormat === 'udta' || (metadataFormat === 'auto' && muxer.isQuickTime)) {\n        addQuickTimeMetadataTagBoxes(boxes, muxer.output._metadataTags);\n    }\n    if (boxes.length === 0) {\n        return null;\n    }\n    return box('udta', undefined, boxes);\n};\nconst addQuickTimeMetadataTagBoxes = (boxes, tags) => {\n    // https://exiftool.org/TagNames/QuickTime.html (QuickTime UserData Tags)\n    // For QuickTime files, metadata tags are dumped into the udta box\n    for (const { key, value } of keyValueIterator(tags)) {\n        switch (key) {\n            case 'title':\n                {\n                    boxes.push(metadataTagStringBoxShort('nam', value));\n                }\n                ;\n                break;\n            case 'description':\n                {\n                    boxes.push(metadataTagStringBoxShort('des', value));\n                }\n                ;\n                break;\n            case 'artist':\n                {\n                    boxes.push(metadataTagStringBoxShort('ART', value));\n                }\n                ;\n                break;\n            case 'album':\n                {\n                    boxes.push(metadataTagStringBoxShort('alb', value));\n                }\n                ;\n                break;\n            case 'albumArtist':\n                {\n                    boxes.push(metadataTagStringBoxShort('albr', value));\n                }\n                ;\n                break;\n            case 'genre':\n                {\n                    boxes.push(metadataTagStringBoxShort('gen', value));\n                }\n                ;\n                break;\n            case 'date':\n                {\n                    boxes.push(metadataTagStringBoxShort('day', value.toISOString().slice(0, 10)));\n                }\n                ;\n                break;\n            case 'comment':\n                {\n                    boxes.push(metadataTagStringBoxShort('cmt', value));\n                }\n                ;\n                break;\n            case 'lyrics':\n                {\n                    boxes.push(metadataTagStringBoxShort('lyr', value));\n                }\n                ;\n                break;\n            case 'raw':\n                {\n                    // Handled later\n                }\n                ;\n                break;\n            case 'discNumber':\n            case 'discsTotal':\n            case 'trackNumber':\n            case 'tracksTotal':\n            case 'images':\n                {\n                    // Not written for QuickTime (common Apple L)\n                }\n                ;\n                break;\n            default: assertNever(key);\n        }\n    }\n    if (tags.raw) {\n        for (const key in tags.raw) {\n            const value = tags.raw[key];\n            if (value == null || key.length !== 4 || boxes.some(x => x.type === key)) {\n                continue;\n            }\n            if (typeof value === 'string') {\n                boxes.push(metadataTagStringBoxShort(key, value));\n            }\n            else if (value instanceof Uint8Array) {\n                boxes.push(box(key, Array.from(value)));\n            }\n        }\n    }\n};\nconst metadataTagStringBoxShort = (name, value) => {\n    const encoded = textEncoder.encode(value);\n    return box(name, [\n        u16(encoded.length),\n        u16(getLanguageCodeInt('und')),\n        Array.from(encoded),\n    ]);\n};\nconst DATA_BOX_MIME_TYPE_MAP = {\n    'image/jpeg': 13,\n    'image/png': 14,\n    'image/bmp': 27,\n};\n/**\n * Generates key-value metadata for inclusion in the \"meta\" box.\n */\nconst generateMetadataPairs = (tags, isMdta) => {\n    const pairs = [];\n    // https://exiftool.org/TagNames/QuickTime.html (QuickTime ItemList Tags)\n    // This is the metadata format used for MP4 files\n    for (const { key, value } of keyValueIterator(tags)) {\n        switch (key) {\n            case 'title':\n                {\n                    pairs.push({ key: isMdta ? 'title' : 'nam', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'description':\n                {\n                    pairs.push({ key: isMdta ? 'description' : 'des', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'artist':\n                {\n                    pairs.push({ key: isMdta ? 'artist' : 'ART', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'album':\n                {\n                    pairs.push({ key: isMdta ? 'album' : 'alb', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'albumArtist':\n                {\n                    pairs.push({ key: isMdta ? 'album_artist' : 'aART', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'comment':\n                {\n                    pairs.push({ key: isMdta ? 'comment' : 'cmt', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'genre':\n                {\n                    pairs.push({ key: isMdta ? 'genre' : 'gen', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'lyrics':\n                {\n                    pairs.push({ key: isMdta ? 'lyrics' : 'lyr', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'date':\n                {\n                    pairs.push({\n                        key: isMdta ? 'date' : 'day',\n                        value: dataStringBoxLong(value.toISOString().slice(0, 10)),\n                    });\n                }\n                ;\n                break;\n            case 'images':\n                {\n                    for (const image of value) {\n                        if (image.kind !== 'coverFront') {\n                            continue;\n                        }\n                        pairs.push({ key: 'covr', value: box('data', [\n                                u32(DATA_BOX_MIME_TYPE_MAP[image.mimeType] ?? 0), // Type indicator\n                                u32(0), // Locale indicator\n                                Array.from(image.data), // Kinda slow, hopefully temp\n                            ]) });\n                    }\n                }\n                ;\n                break;\n            case 'trackNumber':\n                {\n                    if (isMdta) {\n                        const string = tags.tracksTotal !== undefined\n                            ? `${value}/${tags.tracksTotal}`\n                            : value.toString();\n                        pairs.push({ key: 'track', value: dataStringBoxLong(string) });\n                    }\n                    else {\n                        pairs.push({ key: 'trkn', value: box('data', [\n                                u32(0), // 8 bytes empty\n                                u32(0),\n                                u16(0), // Empty\n                                u16(value),\n                                u16(tags.tracksTotal ?? 0),\n                                u16(0), // Empty\n                            ]) });\n                    }\n                }\n                ;\n                break;\n            case 'discNumber':\n                {\n                    if (!isMdta) {\n                        // Only written for mdir\n                        pairs.push({ key: 'disc', value: box('data', [\n                                u32(0), // 8 bytes empty\n                                u32(0),\n                                u16(0), // Empty\n                                u16(value),\n                                u16(tags.discsTotal ?? 0),\n                                u16(0), // Empty\n                            ]) });\n                    }\n                }\n                ;\n                break;\n            case 'tracksTotal':\n            case 'discsTotal':\n                {\n                    // These are included with 'trackNumber' and 'discNumber' respectively\n                }\n                ;\n                break;\n            case 'raw':\n                {\n                    // Handled later\n                }\n                ;\n                break;\n            default: assertNever(key);\n        }\n    }\n    if (tags.raw) {\n        for (const key in tags.raw) {\n            const value = tags.raw[key];\n            if (value == null || (!isMdta && key.length !== 4) || pairs.some(x => x.key === key)) {\n                continue;\n            }\n            if (typeof value === 'string') {\n                pairs.push({ key, value: dataStringBoxLong(value) });\n            }\n            else if (value instanceof Uint8Array) {\n                pairs.push({ key, value: box('data', [\n                        u32(0), // Type indicator\n                        u32(0), // Locale indicator\n                        Array.from(value),\n                    ]) });\n            }\n            else if (value instanceof RichImageData) {\n                pairs.push({ key, value: box('data', [\n                        u32(DATA_BOX_MIME_TYPE_MAP[value.mimeType] ?? 0), // Type indicator\n                        u32(0), // Locale indicator\n                        Array.from(value.data), // Kinda slow, hopefully temp\n                    ]) });\n            }\n        }\n    }\n    return pairs;\n};\n/** Metadata Box (mdir format) */\nconst metaMdir = (tags) => {\n    const pairs = generateMetadataPairs(tags, false);\n    if (pairs.length === 0) {\n        return null;\n    }\n    // fullBox format\n    return fullBox('meta', 0, 0, undefined, [\n        hdlr(false, 'mdir', '', 'appl'), // mdir handler\n        box('ilst', undefined, pairs.map(pair => box(pair.key, undefined, [pair.value]))), // Item list without keys box\n    ]);\n};\n/** Metadata Box (mdta format with keys box) */\nconst metaMdta = (tags) => {\n    const pairs = generateMetadataPairs(tags, true);\n    if (pairs.length === 0) {\n        return null;\n    }\n    // box without version and flags\n    return box('meta', undefined, [\n        hdlr(false, 'mdta', ''), // mdta handler\n        fullBox('keys', 0, 0, [\n            u32(pairs.length),\n        ], pairs.map(pair => box('mdta', [\n            ...textEncoder.encode(pair.key),\n        ]))),\n        box('ilst', undefined, pairs.map((pair, i) => {\n            const boxName = String.fromCharCode(...u32(i + 1));\n            return box(boxName, undefined, [pair.value]);\n        })),\n    ]);\n};\nconst dataStringBoxLong = (value) => {\n    return box('data', [\n        u32(1), // Type indicator (UTF-8)\n        u32(0), // Locale indicator\n        ...textEncoder.encode(value),\n    ]);\n};\nconst videoCodecToBoxName = (codec, fullCodecString) => {\n    switch (codec) {\n        case 'avc': return fullCodecString.startsWith('avc3') ? 'avc3' : 'avc1';\n        case 'hevc': return 'hvc1';\n        case 'vp8': return 'vp08';\n        case 'vp9': return 'vp09';\n        case 'av1': return 'av01';\n    }\n};\nconst VIDEO_CODEC_TO_CONFIGURATION_BOX = {\n    avc: avcC,\n    hevc: hvcC,\n    vp8: vpcC,\n    vp9: vpcC,\n    av1: av1C,\n};\nconst audioCodecToBoxName = (codec, isQuickTime) => {\n    switch (codec) {\n        case 'aac': return 'mp4a';\n        case 'mp3': return 'mp4a';\n        case 'opus': return 'Opus';\n        case 'vorbis': return 'mp4a';\n        case 'flac': return 'fLaC';\n        case 'ulaw': return 'ulaw';\n        case 'alaw': return 'alaw';\n        case 'pcm-u8': return 'raw ';\n        case 'pcm-s8': return 'sowt';\n    }\n    // Logic diverges here\n    if (isQuickTime) {\n        switch (codec) {\n            case 'pcm-s16': return 'sowt';\n            case 'pcm-s16be': return 'twos';\n            case 'pcm-s24': return 'in24';\n            case 'pcm-s24be': return 'in24';\n            case 'pcm-s32': return 'in32';\n            case 'pcm-s32be': return 'in32';\n            case 'pcm-f32': return 'fl32';\n            case 'pcm-f32be': return 'fl32';\n            case 'pcm-f64': return 'fl64';\n            case 'pcm-f64be': return 'fl64';\n        }\n    }\n    else {\n        switch (codec) {\n            case 'pcm-s16': return 'ipcm';\n            case 'pcm-s16be': return 'ipcm';\n            case 'pcm-s24': return 'ipcm';\n            case 'pcm-s24be': return 'ipcm';\n            case 'pcm-s32': return 'ipcm';\n            case 'pcm-s32be': return 'ipcm';\n            case 'pcm-f32': return 'fpcm';\n            case 'pcm-f32be': return 'fpcm';\n            case 'pcm-f64': return 'fpcm';\n            case 'pcm-f64be': return 'fpcm';\n        }\n    }\n};\nconst audioCodecToConfigurationBox = (codec, isQuickTime) => {\n    switch (codec) {\n        case 'aac': return esds;\n        case 'mp3': return esds;\n        case 'opus': return dOps;\n        case 'vorbis': return esds;\n        case 'flac': return dfLa;\n    }\n    // Logic diverges here\n    if (isQuickTime) {\n        switch (codec) {\n            case 'pcm-s24': return wave;\n            case 'pcm-s24be': return wave;\n            case 'pcm-s32': return wave;\n            case 'pcm-s32be': return wave;\n            case 'pcm-f32': return wave;\n            case 'pcm-f32be': return wave;\n            case 'pcm-f64': return wave;\n            case 'pcm-f64be': return wave;\n        }\n    }\n    else {\n        switch (codec) {\n            case 'pcm-s16': return pcmC;\n            case 'pcm-s16be': return pcmC;\n            case 'pcm-s24': return pcmC;\n            case 'pcm-s24be': return pcmC;\n            case 'pcm-s32': return pcmC;\n            case 'pcm-s32be': return pcmC;\n            case 'pcm-f32': return pcmC;\n            case 'pcm-f32be': return pcmC;\n            case 'pcm-f64': return pcmC;\n            case 'pcm-f64be': return pcmC;\n        }\n    }\n    return null;\n};\nconst SUBTITLE_CODEC_TO_BOX_NAME = {\n    webvtt: 'wvtt',\n};\nconst SUBTITLE_CODEC_TO_CONFIGURATION_BOX = {\n    webvtt: vttC,\n};\nconst getLanguageCodeInt = (code) => {\n    assert(code.length === 3);\n    ;\n    let language = 0;\n    for (let i = 0; i < 3; i++) {\n        language <<= 5;\n        language += code.charCodeAt(i) - 0x60;\n    }\n    return language;\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert } from './misc.js';\nexport class Writer {\n    constructor() {\n        /** Setting this to true will cause the writer to ensure data is written in a strictly monotonic, streamable way. */\n        this.ensureMonotonicity = false;\n        this.trackedWrites = null;\n        this.trackedStart = -1;\n        this.trackedEnd = -1;\n    }\n    start() { }\n    maybeTrackWrites(data) {\n        if (!this.trackedWrites) {\n            return;\n        }\n        // Handle negative relative write positions\n        let pos = this.getPos();\n        if (pos < this.trackedStart) {\n            if (pos + data.byteLength <= this.trackedStart) {\n                return;\n            }\n            data = data.subarray(this.trackedStart - pos);\n            pos = 0;\n        }\n        const neededSize = pos + data.byteLength - this.trackedStart;\n        let newLength = this.trackedWrites.byteLength;\n        while (newLength < neededSize) {\n            newLength *= 2;\n        }\n        // Check if we need to resize the buffer\n        if (newLength !== this.trackedWrites.byteLength) {\n            const copy = new Uint8Array(newLength);\n            copy.set(this.trackedWrites, 0);\n            this.trackedWrites = copy;\n        }\n        this.trackedWrites.set(data, pos - this.trackedStart);\n        this.trackedEnd = Math.max(this.trackedEnd, pos + data.byteLength);\n    }\n    startTrackingWrites() {\n        this.trackedWrites = new Uint8Array(2 ** 10);\n        this.trackedStart = this.getPos();\n        this.trackedEnd = this.trackedStart;\n    }\n    stopTrackingWrites() {\n        if (!this.trackedWrites) {\n            throw new Error('Internal error: Can\\'t get tracked writes since nothing was tracked.');\n        }\n        const slice = this.trackedWrites.subarray(0, this.trackedEnd - this.trackedStart);\n        const result = {\n            data: slice,\n            start: this.trackedStart,\n            end: this.trackedEnd,\n        };\n        this.trackedWrites = null;\n        return result;\n    }\n}\nconst ARRAY_BUFFER_INITIAL_SIZE = 2 ** 16;\nconst ARRAY_BUFFER_MAX_SIZE = 2 ** 32;\nexport class BufferTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.pos = 0;\n        this.maxPos = 0;\n        this.target = target;\n        this.supportsResize = 'resize' in new ArrayBuffer(0);\n        if (this.supportsResize) {\n            try {\n                // @ts-expect-error Don't want to bump \"lib\" in tsconfig\n                this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE, { maxByteLength: ARRAY_BUFFER_MAX_SIZE });\n            }\n            catch {\n                this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE);\n                this.supportsResize = false;\n            }\n        }\n        else {\n            this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE);\n        }\n        this.bytes = new Uint8Array(this.buffer);\n    }\n    ensureSize(size) {\n        let newLength = this.buffer.byteLength;\n        while (newLength < size)\n            newLength *= 2;\n        if (newLength === this.buffer.byteLength)\n            return;\n        if (newLength > ARRAY_BUFFER_MAX_SIZE) {\n            throw new Error(`ArrayBuffer exceeded maximum size of ${ARRAY_BUFFER_MAX_SIZE} bytes. Please consider using another`\n                + ` target.`);\n        }\n        if (this.supportsResize) {\n            // Use resize if it exists\n            // @ts-expect-error Don't want to bump \"lib\" in tsconfig\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            this.buffer.resize(newLength);\n            // The Uint8Array scales automatically\n        }\n        else {\n            const newBuffer = new ArrayBuffer(newLength);\n            const newBytes = new Uint8Array(newBuffer);\n            newBytes.set(this.bytes, 0);\n            this.buffer = newBuffer;\n            this.bytes = newBytes;\n        }\n    }\n    write(data) {\n        this.maybeTrackWrites(data);\n        this.ensureSize(this.pos + data.byteLength);\n        this.bytes.set(data, this.pos);\n        this.target.onwrite?.(this.pos, this.pos + data.byteLength);\n        this.pos += data.byteLength;\n        this.maxPos = Math.max(this.maxPos, this.pos);\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    getPos() {\n        return this.pos;\n    }\n    async flush() { }\n    async finalize() {\n        this.ensureSize(this.pos);\n        this.target.buffer = this.buffer.slice(0, Math.max(this.maxPos, this.pos));\n    }\n    async close() { }\n    getSlice(start, end) {\n        return this.bytes.slice(start, end);\n    }\n}\nconst DEFAULT_CHUNK_SIZE = 2 ** 24;\nconst MAX_CHUNKS_AT_ONCE = 2;\n/**\n * Writes to a StreamTarget every time it is flushed, sending out all of the new data written since the\n * last flush. This is useful for streaming applications, like piping the output to disk. When using the chunked mode,\n * data will first be accumulated in larger chunks, and then the entire chunk will be flushed out at once when ready.\n */\nexport class StreamTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.pos = 0;\n        this.sections = [];\n        this.lastWriteEnd = 0;\n        this.lastFlushEnd = 0;\n        this.writer = null;\n        /**\n         * The data is divided up into fixed-size chunks, whose contents are first filled in RAM and then flushed out.\n         * A chunk is flushed if all of its contents have been written.\n         */\n        this.chunks = [];\n        this.target = target;\n        this.chunked = target._options.chunked ?? false;\n        this.chunkSize = target._options.chunkSize ?? DEFAULT_CHUNK_SIZE;\n    }\n    start() {\n        this.writer = this.target._writable.getWriter();\n    }\n    write(data) {\n        if (this.pos > this.lastWriteEnd) {\n            const paddingBytesNeeded = this.pos - this.lastWriteEnd;\n            this.pos = this.lastWriteEnd;\n            this.write(new Uint8Array(paddingBytesNeeded));\n        }\n        this.maybeTrackWrites(data);\n        this.sections.push({\n            data: data.slice(),\n            start: this.pos,\n        });\n        this.target.onwrite?.(this.pos, this.pos + data.byteLength);\n        this.pos += data.byteLength;\n        this.lastWriteEnd = Math.max(this.lastWriteEnd, this.pos);\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    getPos() {\n        return this.pos;\n    }\n    async flush() {\n        if (this.pos > this.lastWriteEnd) {\n            // There's a \"void\" between the last written byte and the next byte we're about to write. Let's pad that\n            // void with zeroes explicitly.\n            const paddingBytesNeeded = this.pos - this.lastWriteEnd;\n            this.pos = this.lastWriteEnd;\n            this.write(new Uint8Array(paddingBytesNeeded));\n        }\n        assert(this.writer);\n        if (this.sections.length === 0)\n            return;\n        const chunks = [];\n        const sorted = [...this.sections].sort((a, b) => a.start - b.start);\n        chunks.push({\n            start: sorted[0].start,\n            size: sorted[0].data.byteLength,\n        });\n        // Figure out how many contiguous chunks we have\n        for (let i = 1; i < sorted.length; i++) {\n            const lastChunk = chunks[chunks.length - 1];\n            const section = sorted[i];\n            if (section.start <= lastChunk.start + lastChunk.size) {\n                lastChunk.size = Math.max(lastChunk.size, section.start + section.data.byteLength - lastChunk.start);\n            }\n            else {\n                chunks.push({\n                    start: section.start,\n                    size: section.data.byteLength,\n                });\n            }\n        }\n        for (const chunk of chunks) {\n            chunk.data = new Uint8Array(chunk.size);\n            // Make sure to write the data in the correct order for correct overwriting\n            for (const section of this.sections) {\n                // Check if the section is in the chunk\n                if (chunk.start <= section.start && section.start < chunk.start + chunk.size) {\n                    chunk.data.set(section.data, section.start - chunk.start);\n                }\n            }\n            if (this.writer.desiredSize !== null && this.writer.desiredSize <= 0) {\n                await this.writer.ready; // Allow the writer to apply backpressure\n            }\n            if (this.chunked) {\n                // Let's first gather the data into bigger chunks before writing it\n                this.writeDataIntoChunks(chunk.data, chunk.start);\n                this.tryToFlushChunks();\n            }\n            else {\n                if (this.ensureMonotonicity && chunk.start !== this.lastFlushEnd) {\n                    throw new Error('Internal error: Monotonicity violation.');\n                }\n                // Write out the data immediately\n                void this.writer.write({\n                    type: 'write',\n                    data: chunk.data,\n                    position: chunk.start,\n                });\n                this.lastFlushEnd = chunk.start + chunk.data.byteLength;\n            }\n        }\n        this.sections.length = 0;\n    }\n    writeDataIntoChunks(data, position) {\n        // First, find the chunk to write the data into, or create one if none exists\n        let chunkIndex = this.chunks.findIndex(x => x.start <= position && position < x.start + this.chunkSize);\n        if (chunkIndex === -1)\n            chunkIndex = this.createChunk(position);\n        const chunk = this.chunks[chunkIndex];\n        // Figure out how much to write to the chunk, and then write to the chunk\n        const relativePosition = position - chunk.start;\n        const toWrite = data.subarray(0, Math.min(this.chunkSize - relativePosition, data.byteLength));\n        chunk.data.set(toWrite, relativePosition);\n        // Create a section describing the region of data that was just written to\n        const section = {\n            start: relativePosition,\n            end: relativePosition + toWrite.byteLength,\n        };\n        this.insertSectionIntoChunk(chunk, section);\n        // Queue chunk for flushing to target if it has been fully written to\n        if (chunk.written[0].start === 0 && chunk.written[0].end === this.chunkSize) {\n            chunk.shouldFlush = true;\n        }\n        // Make sure we don't hold too many chunks in memory at once to keep memory usage down\n        if (this.chunks.length > MAX_CHUNKS_AT_ONCE) {\n            // Flush all but the last chunk\n            for (let i = 0; i < this.chunks.length - 1; i++) {\n                this.chunks[i].shouldFlush = true;\n            }\n            this.tryToFlushChunks();\n        }\n        // If the data didn't fit in one chunk, recurse with the remaining data\n        if (toWrite.byteLength < data.byteLength) {\n            this.writeDataIntoChunks(data.subarray(toWrite.byteLength), position + toWrite.byteLength);\n        }\n    }\n    insertSectionIntoChunk(chunk, section) {\n        let low = 0;\n        let high = chunk.written.length - 1;\n        let index = -1;\n        // Do a binary search to find the last section with a start not larger than `section`'s start\n        while (low <= high) {\n            const mid = Math.floor(low + (high - low + 1) / 2);\n            if (chunk.written[mid].start <= section.start) {\n                low = mid + 1;\n                index = mid;\n            }\n            else {\n                high = mid - 1;\n            }\n        }\n        // Insert the new section\n        chunk.written.splice(index + 1, 0, section);\n        if (index === -1 || chunk.written[index].end < section.start)\n            index++;\n        // Merge overlapping sections\n        while (index < chunk.written.length - 1 && chunk.written[index].end >= chunk.written[index + 1].start) {\n            chunk.written[index].end = Math.max(chunk.written[index].end, chunk.written[index + 1].end);\n            chunk.written.splice(index + 1, 1);\n        }\n    }\n    createChunk(includesPosition) {\n        const start = Math.floor(includesPosition / this.chunkSize) * this.chunkSize;\n        const chunk = {\n            start,\n            data: new Uint8Array(this.chunkSize),\n            written: [],\n            shouldFlush: false,\n        };\n        this.chunks.push(chunk);\n        this.chunks.sort((a, b) => a.start - b.start);\n        return this.chunks.indexOf(chunk);\n    }\n    tryToFlushChunks(force = false) {\n        assert(this.writer);\n        for (let i = 0; i < this.chunks.length; i++) {\n            const chunk = this.chunks[i];\n            if (!chunk.shouldFlush && !force)\n                continue;\n            for (const section of chunk.written) {\n                const position = chunk.start + section.start;\n                if (this.ensureMonotonicity && position !== this.lastFlushEnd) {\n                    throw new Error('Internal error: Monotonicity violation.');\n                }\n                void this.writer.write({\n                    type: 'write',\n                    data: chunk.data.subarray(section.start, section.end),\n                    position,\n                });\n                this.lastFlushEnd = chunk.start + section.end;\n            }\n            this.chunks.splice(i--, 1);\n        }\n    }\n    finalize() {\n        if (this.chunked) {\n            this.tryToFlushChunks(true);\n        }\n        assert(this.writer);\n        return this.writer.close();\n    }\n    async close() {\n        return this.writer?.close();\n    }\n}\nexport class NullTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.target = target;\n        this.pos = 0;\n    }\n    write(data) {\n        this.maybeTrackWrites(data);\n        this.target.onwrite?.(this.pos, this.pos + data.byteLength);\n        this.pos += data.byteLength;\n    }\n    getPos() {\n        return this.pos;\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    async flush() { }\n    async finalize() { }\n    async close() { }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { BufferTargetWriter, NullTargetWriter, StreamTargetWriter } from './writer.js';\nimport * as nodeAlias from './node.js';\nimport { assert } from './misc.js';\nconst node = typeof nodeAlias !== 'undefined'\n    ? nodeAlias // Aliasing it prevents some bundler warnings\n    : undefined;\n/**\n * Base class for targets, specifying where output files are written.\n * @group Output targets\n * @public\n */\nexport class Target {\n    constructor() {\n        /** @internal */\n        this._output = null;\n        /**\n         * Called each time data is written to the target. Will be called with the byte range into which data was written.\n         *\n         * Use this callback to track the size of the output file as it grows. But be warned, this function is chatty and\n         * gets called *extremely* often.\n         */\n        this.onwrite = null;\n    }\n}\n/**\n * A target that writes data directly into an ArrayBuffer in memory. Great for performance, but not suitable for very\n * large files. The buffer will be available once the output has been finalized.\n * @group Output targets\n * @public\n */\nexport class BufferTarget extends Target {\n    constructor() {\n        super(...arguments);\n        /** Stores the final output buffer. Until the output is finalized, this will be `null`. */\n        this.buffer = null;\n    }\n    /** @internal */\n    _createWriter() {\n        return new BufferTargetWriter(this);\n    }\n}\n/**\n * This target writes data to a [`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream),\n * making it a general-purpose target for writing data anywhere. It is also compatible with\n * [`FileSystemWritableFileStream`](https://developer.mozilla.org/en-US/docs/Web/API/FileSystemWritableFileStream) for\n * use with the [File System Access API](https://developer.mozilla.org/en-US/docs/Web/API/File_System_API). The\n * `WritableStream` can also apply backpressure, which will propagate to the output and throttle the encoders.\n * @group Output targets\n * @public\n */\nexport class StreamTarget extends Target {\n    /** Creates a new {@link StreamTarget} which writes to the specified `writable`. */\n    constructor(writable, options = {}) {\n        super();\n        if (!(writable instanceof WritableStream)) {\n            throw new TypeError('StreamTarget requires a WritableStream instance.');\n        }\n        if (options != null && typeof options !== 'object') {\n            throw new TypeError('StreamTarget options, when provided, must be an object.');\n        }\n        if (options.chunked !== undefined && typeof options.chunked !== 'boolean') {\n            throw new TypeError('options.chunked, when provided, must be a boolean.');\n        }\n        if (options.chunkSize !== undefined && (!Number.isInteger(options.chunkSize) || options.chunkSize < 1024)) {\n            throw new TypeError('options.chunkSize, when provided, must be an integer and not smaller than 1024.');\n        }\n        this._writable = writable;\n        this._options = options;\n    }\n    /** @internal */\n    _createWriter() {\n        return new StreamTargetWriter(this);\n    }\n}\n/**\n * A target that writes to a file at the specified path. Intended for server-side usage in Node, Bun, or Deno.\n *\n * Writing is chunked by default. The internally held file handle will be closed when `.finalize()` or `.cancel()` are\n * called on the corresponding {@link Output}.\n * @group Output targets\n * @public\n */\nexport class FilePathTarget extends Target {\n    /** Creates a new {@link FilePathTarget} that writes to the file at the specified file path. */\n    constructor(filePath, options = {}) {\n        if (typeof filePath !== 'string') {\n            throw new TypeError('filePath must be a string.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        super();\n        /** @internal */\n        this._fileHandle = null;\n        // Let's back this target with a StreamTarget, makes the implementation very simple\n        const writable = new WritableStream({\n            start: async () => {\n                this._fileHandle = await node.fs.open(filePath, 'w');\n            },\n            write: async (chunk) => {\n                assert(this._fileHandle);\n                await this._fileHandle.write(chunk.data, 0, chunk.data.byteLength, chunk.position);\n            },\n            close: async () => {\n                if (this._fileHandle) {\n                    await this._fileHandle.close();\n                    this._fileHandle = null;\n                }\n            },\n        });\n        this._streamTarget = new StreamTarget(writable, {\n            chunked: true,\n            ...options,\n        });\n        this._streamTarget._output = this._output;\n    }\n    /** @internal */\n    _createWriter() {\n        return this._streamTarget._createWriter();\n    }\n}\n/**\n * This target just discards all incoming data. It is useful for when you need an {@link Output} but extract data from\n * it differently, for example through format-specific callbacks (`onMoof`, `onMdat`, ...) or encoder events.\n * @group Output targets\n * @public\n */\nexport class NullTarget extends Target {\n    /** @internal */\n    _createWriter() {\n        return new NullTargetWriter(this);\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { free, ftyp, IsobmffBoxWriter, mdat, mfra, moof, moov, vtta, vttc, vtte } from './isobmff-boxes.js';\nimport { Muxer } from '../muxer.js';\nimport { BufferTargetWriter } from '../writer.js';\nimport { assert, computeRationalApproximation, last, promiseWithResolvers } from '../misc.js';\nimport { MovOutputFormat } from '../output-format.js';\nimport { inlineTimestampRegex } from '../subtitles.js';\nimport { parsePcmCodec, PCM_AUDIO_CODECS, validateAudioChunkMetadata, validateSubtitleMetadata, validateVideoChunkMetadata, } from '../codec.js';\nimport { BufferTarget } from '../target.js';\nimport { concatNalUnitsInLengthPrefixed, extractAvcDecoderConfigurationRecord, extractHevcDecoderConfigurationRecord, findNalUnitsInAnnexB, serializeAvcDecoderConfigurationRecord, serializeHevcDecoderConfigurationRecord, } from '../codec-data.js';\nimport { buildIsobmffMimeType } from './isobmff-misc.js';\nimport { MAX_BOX_HEADER_SIZE, MIN_BOX_HEADER_SIZE } from './isobmff-reader.js';\nexport const GLOBAL_TIMESCALE = 1000;\nconst TIMESTAMP_OFFSET = 2_082_844_800; // Seconds between Jan 1 1904 and Jan 1 1970\nexport const getTrackMetadata = (trackData) => {\n    const metadata = {};\n    const track = trackData.track;\n    if (track.metadata.name !== undefined) {\n        metadata.name = track.metadata.name;\n    }\n    return metadata;\n};\nexport const intoTimescale = (timeInSeconds, timescale, round = true) => {\n    const value = timeInSeconds * timescale;\n    return round ? Math.round(value) : value;\n};\nexport class IsobmffMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.auxTarget = new BufferTarget();\n        this.auxWriter = this.auxTarget._createWriter();\n        this.auxBoxWriter = new IsobmffBoxWriter(this.auxWriter);\n        this.mdat = null;\n        this.ftypSize = null;\n        this.trackDatas = [];\n        this.allTracksKnown = promiseWithResolvers();\n        this.creationTime = Math.floor(Date.now() / 1000) + TIMESTAMP_OFFSET;\n        this.finalizedChunks = [];\n        this.nextFragmentNumber = 1;\n        // Only relevant for fragmented files, to make sure new fragments start with the highest timestamp seen so far\n        this.maxWrittenTimestamp = -Infinity;\n        this.format = format;\n        this.writer = output._writer;\n        this.boxWriter = new IsobmffBoxWriter(this.writer);\n        this.isQuickTime = format instanceof MovOutputFormat;\n        // If the fastStart option isn't defined, enable in-memory fast start if the target is an ArrayBuffer, as the\n        // memory usage remains identical\n        const fastStartDefault = this.writer instanceof BufferTargetWriter ? 'in-memory' : false;\n        this.fastStart = format._options.fastStart ?? fastStartDefault;\n        this.isFragmented = this.fastStart === 'fragmented';\n        if (this.fastStart === 'in-memory' || this.isFragmented) {\n            this.writer.ensureMonotonicity = true;\n        }\n        this.minimumFragmentDuration = format._options.minimumFragmentDuration ?? 1;\n    }\n    async start() {\n        const release = await this.mutex.acquire();\n        const holdsAvc = this.output._tracks.some(x => x.type === 'video' && x.source._codec === 'avc');\n        // Write the header\n        {\n            if (this.format._options.onFtyp) {\n                this.writer.startTrackingWrites();\n            }\n            this.boxWriter.writeBox(ftyp({\n                isQuickTime: this.isQuickTime,\n                holdsAvc: holdsAvc,\n                fragmented: this.isFragmented,\n            }));\n            if (this.format._options.onFtyp) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onFtyp(data, start);\n            }\n        }\n        this.ftypSize = this.writer.getPos();\n        if (this.fastStart === 'in-memory') {\n            // We're write at finalization\n        }\n        else if (this.fastStart === 'reserve') {\n            // Validate that all tracks have set maximumPacketCount\n            for (const track of this.output._tracks) {\n                if (track.metadata.maximumPacketCount === undefined) {\n                    throw new Error('All tracks must specify maximumPacketCount in their metadata when using'\n                        + ' fastStart: \\'reserve\\'.');\n                }\n            }\n            // We'll start writing once we know all tracks\n        }\n        else if (this.isFragmented) {\n            // We write the moov box once we write out the first fragment to make sure we get the decoder configs\n        }\n        else {\n            if (this.format._options.onMdat) {\n                this.writer.startTrackingWrites();\n            }\n            this.mdat = mdat(true); // Reserve large size by default, can refine this when finalizing.\n            this.boxWriter.writeBox(this.mdat);\n        }\n        await this.writer.flush();\n        release();\n    }\n    allTracksAreKnown() {\n        for (const track of this.output._tracks) {\n            if (!track.source._closed && !this.trackDatas.some(x => x.track === track)) {\n                return false; // We haven't seen a sample from this open track yet\n            }\n        }\n        return true;\n    }\n    async getMimeType() {\n        await this.allTracksKnown.promise;\n        const codecStrings = this.trackDatas.map((trackData) => {\n            if (trackData.type === 'video') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else if (trackData.type === 'audio') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else {\n                const map = {\n                    webvtt: 'wvtt',\n                };\n                return map[trackData.track.source._codec];\n            }\n        });\n        return buildIsobmffMimeType({\n            isQuickTime: this.isQuickTime,\n            hasVideo: this.trackDatas.some(x => x.type === 'video'),\n            hasAudio: this.trackDatas.some(x => x.type === 'audio'),\n            codecStrings,\n        });\n    }\n    getVideoTrackData(track, packet, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateVideoChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const decoderConfig = { ...meta.decoderConfig };\n        assert(decoderConfig.codedWidth !== undefined);\n        assert(decoderConfig.codedHeight !== undefined);\n        let requiresAnnexBTransformation = false;\n        if (track.source._codec === 'avc' && !decoderConfig.description) {\n            // ISOBMFF can only hold AVC in the AVCC format, not in Annex B, but the missing description indicates\n            // Annex B. This means we'll need to do some converterino.\n            const decoderConfigurationRecord = extractAvcDecoderConfigurationRecord(packet.data);\n            if (!decoderConfigurationRecord) {\n                throw new Error('Couldn\\'t extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are'\n                    + ' in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or'\n                    + ' provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15)'\n                    + ' and ensure the packets are in AVCC format.');\n            }\n            decoderConfig.description = serializeAvcDecoderConfigurationRecord(decoderConfigurationRecord);\n            requiresAnnexBTransformation = true;\n        }\n        else if (track.source._codec === 'hevc' && !decoderConfig.description) {\n            // ISOBMFF can only hold HEVC in the HEVC format, not in Annex B, but the missing description indicates\n            // Annex B. This means we'll need to do some converterino.\n            const decoderConfigurationRecord = extractHevcDecoderConfigurationRecord(packet.data);\n            if (!decoderConfigurationRecord) {\n                throw new Error('Couldn\\'t extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets'\n                    + ' are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or'\n                    + ' provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15)'\n                    + ' and ensure the packets are in HEVC format.');\n            }\n            decoderConfig.description = serializeHevcDecoderConfigurationRecord(decoderConfigurationRecord);\n            requiresAnnexBTransformation = true;\n        }\n        // The frame rate set by the user may not be an integer. Since timescale is an integer, we'll approximate the\n        // frame time (inverse of frame rate) with a rational number, then use that approximation's denominator\n        // as the timescale.\n        const timescale = computeRationalApproximation(1 / (track.metadata.frameRate ?? 57600), 1e6).denominator;\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'video',\n            info: {\n                width: decoderConfig.codedWidth,\n                height: decoderConfig.codedHeight,\n                decoderConfig: decoderConfig,\n                requiresAnnexBTransformation,\n            },\n            timescale,\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getAudioTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateAudioChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'audio',\n            info: {\n                numberOfChannels: meta.decoderConfig.numberOfChannels,\n                sampleRate: meta.decoderConfig.sampleRate,\n                decoderConfig: meta.decoderConfig,\n                requiresPcmTransformation: !this.isFragmented\n                    && PCM_AUDIO_CODECS.includes(track.source._codec),\n            },\n            timescale: meta.decoderConfig.sampleRate,\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getSubtitleTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateSubtitleMetadata(meta);\n        assert(meta);\n        assert(meta.config);\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'subtitle',\n            info: {\n                config: meta.config,\n            },\n            timescale: 1000, // Reasonable\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n            lastCueEndTimestamp: 0,\n            cueQueue: [],\n            nextSourceId: 0,\n            cueToSourceId: new WeakMap(),\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    async addEncodedVideoPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getVideoTrackData(track, packet, meta);\n            let packetData = packet.data;\n            if (trackData.info.requiresAnnexBTransformation) {\n                const nalUnits = findNalUnitsInAnnexB(packetData);\n                if (nalUnits.length === 0) {\n                    // It's not valid Annex B data\n                    throw new Error('Failed to transform packet data. Make sure all packets are provided in Annex B format, as'\n                        + ' specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.');\n                }\n                // We don't strip things like SPS or PPS NALUs here, mainly because they can also appear in the middle\n                // of a stream and potentially modify the parameters of it. So, let's just leave them in to be sure.\n                packetData = concatNalUnitsInLengthPrefixed(nalUnits, 4);\n            }\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');\n            const internalSample = this.createSampleForTrack(trackData, packetData, timestamp, packet.duration, packet.type);\n            await this.registerSample(trackData, internalSample);\n        }\n        finally {\n            release();\n        }\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getAudioTrackData(track, meta);\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');\n            const internalSample = this.createSampleForTrack(trackData, packet.data, timestamp, packet.duration, packet.type);\n            if (trackData.info.requiresPcmTransformation) {\n                await this.maybePadWithSilence(trackData, timestamp);\n            }\n            await this.registerSample(trackData, internalSample);\n        }\n        finally {\n            release();\n        }\n    }\n    async maybePadWithSilence(trackData, untilTimestamp) {\n        // The PCM transformation assumes that all samples are contiguous. This is not something that is enforced, so\n        // we need to pad the \"holes\" in between samples (and before the first sample) with additional\n        // \"silence samples\".\n        const lastSample = last(trackData.samples);\n        const lastEndTimestamp = lastSample\n            ? lastSample.timestamp + lastSample.duration\n            : 0;\n        const delta = untilTimestamp - lastEndTimestamp;\n        const deltaInTimescale = intoTimescale(delta, trackData.timescale);\n        if (deltaInTimescale > 0) {\n            const { sampleSize, silentValue } = parsePcmCodec(trackData.info.decoderConfig.codec);\n            const samplesNeeded = deltaInTimescale * trackData.info.numberOfChannels;\n            const data = new Uint8Array(sampleSize * samplesNeeded).fill(silentValue);\n            const paddingSample = this.createSampleForTrack(trackData, new Uint8Array(data.buffer), lastEndTimestamp, delta, 'key');\n            await this.registerSample(trackData, paddingSample);\n        }\n    }\n    async addSubtitleCue(track, cue, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getSubtitleTrackData(track, meta);\n            this.validateAndNormalizeTimestamp(trackData.track, cue.timestamp, true);\n            if (track.source._codec === 'webvtt') {\n                trackData.cueQueue.push(cue);\n                await this.processWebVTTCues(trackData, cue.timestamp);\n            }\n            else {\n                // TODO\n            }\n        }\n        finally {\n            release();\n        }\n    }\n    async processWebVTTCues(trackData, until) {\n        // WebVTT cues need to undergo special processing as empty sections need to be padded out with samples, and\n        // overlapping samples require special logic. The algorithm produces the format specified in ISO 14496-30.\n        while (trackData.cueQueue.length > 0) {\n            const timestamps = new Set([]);\n            for (const cue of trackData.cueQueue) {\n                assert(cue.timestamp <= until);\n                assert(trackData.lastCueEndTimestamp <= cue.timestamp + cue.duration);\n                timestamps.add(Math.max(cue.timestamp, trackData.lastCueEndTimestamp)); // Start timestamp\n                timestamps.add(cue.timestamp + cue.duration); // End timestamp\n            }\n            const sortedTimestamps = [...timestamps].sort((a, b) => a - b);\n            // These are the timestamps of the next sample we'll create:\n            const sampleStart = sortedTimestamps[0];\n            const sampleEnd = sortedTimestamps[1] ?? sampleStart;\n            if (until < sampleEnd) {\n                break;\n            }\n            // We may need to pad out empty space with an vtte box\n            if (trackData.lastCueEndTimestamp < sampleStart) {\n                this.auxWriter.seek(0);\n                const box = vtte();\n                this.auxBoxWriter.writeBox(box);\n                const body = this.auxWriter.getSlice(0, this.auxWriter.getPos());\n                const sample = this.createSampleForTrack(trackData, body, trackData.lastCueEndTimestamp, sampleStart - trackData.lastCueEndTimestamp, 'key');\n                await this.registerSample(trackData, sample);\n                trackData.lastCueEndTimestamp = sampleStart;\n            }\n            this.auxWriter.seek(0);\n            for (let i = 0; i < trackData.cueQueue.length; i++) {\n                const cue = trackData.cueQueue[i];\n                if (cue.timestamp >= sampleEnd) {\n                    break;\n                }\n                inlineTimestampRegex.lastIndex = 0;\n                const containsTimestamp = inlineTimestampRegex.test(cue.text);\n                const endTimestamp = cue.timestamp + cue.duration;\n                let sourceId = trackData.cueToSourceId.get(cue);\n                if (sourceId === undefined && sampleEnd < endTimestamp) {\n                    // We know this cue will appear in more than one sample, therefore we need to mark it with a\n                    // unique ID\n                    sourceId = trackData.nextSourceId++;\n                    trackData.cueToSourceId.set(cue, sourceId);\n                }\n                if (cue.notes) {\n                    // Any notes/comments are included in a special vtta box\n                    const box = vtta(cue.notes);\n                    this.auxBoxWriter.writeBox(box);\n                }\n                const box = vttc(cue.text, containsTimestamp ? sampleStart : null, cue.identifier ?? null, cue.settings ?? null, sourceId ?? null);\n                this.auxBoxWriter.writeBox(box);\n                if (endTimestamp === sampleEnd) {\n                    // The cue won't appear in any future sample, so we're done with it\n                    trackData.cueQueue.splice(i--, 1);\n                }\n            }\n            const body = this.auxWriter.getSlice(0, this.auxWriter.getPos());\n            const sample = this.createSampleForTrack(trackData, body, sampleStart, sampleEnd - sampleStart, 'key');\n            await this.registerSample(trackData, sample);\n            trackData.lastCueEndTimestamp = sampleEnd;\n        }\n    }\n    createSampleForTrack(trackData, data, timestamp, duration, type) {\n        const sample = {\n            timestamp,\n            decodeTimestamp: timestamp, // This may be refined later\n            duration,\n            data,\n            size: data.byteLength,\n            type,\n            timescaleUnitsToNextSample: intoTimescale(duration, trackData.timescale), // Will be refined\n        };\n        return sample;\n    }\n    processTimestamps(trackData, nextSample) {\n        if (trackData.timestampProcessingQueue.length === 0) {\n            return;\n        }\n        if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n            let totalDuration = 0;\n            // Compute the total duration in the track timescale (which is equal to the amount of PCM audio samples)\n            // and simply say that's how many new samples there are.\n            for (let i = 0; i < trackData.timestampProcessingQueue.length; i++) {\n                const sample = trackData.timestampProcessingQueue[i];\n                const duration = intoTimescale(sample.duration, trackData.timescale);\n                totalDuration += duration;\n            }\n            if (trackData.timeToSampleTable.length === 0) {\n                trackData.timeToSampleTable.push({\n                    sampleCount: totalDuration,\n                    sampleDelta: 1,\n                });\n            }\n            else {\n                const lastEntry = last(trackData.timeToSampleTable);\n                lastEntry.sampleCount += totalDuration;\n            }\n            trackData.timestampProcessingQueue.length = 0;\n            return;\n        }\n        const sortedTimestamps = trackData.timestampProcessingQueue.map(x => x.timestamp).sort((a, b) => a - b);\n        for (let i = 0; i < trackData.timestampProcessingQueue.length; i++) {\n            const sample = trackData.timestampProcessingQueue[i];\n            // Since the user only supplies presentation time, but these may be out of order, we reverse-engineer from\n            // that a sensible decode timestamp. The notion of a decode timestamp doesn't really make sense\n            // (presentation timestamp & decode order are all you need), but it is a concept in ISOBMFF so we need to\n            // model it.\n            sample.decodeTimestamp = sortedTimestamps[i];\n            if (!this.isFragmented && trackData.lastTimescaleUnits === null) {\n                // In non-fragmented files, the first decode timestamp is always zero. If the first presentation\n                // timestamp isn't zero, we'll simply use the composition time offset to achieve it.\n                sample.decodeTimestamp = 0;\n            }\n            const sampleCompositionTimeOffset = intoTimescale(sample.timestamp - sample.decodeTimestamp, trackData.timescale);\n            const durationInTimescale = intoTimescale(sample.duration, trackData.timescale);\n            if (trackData.lastTimescaleUnits !== null) {\n                assert(trackData.lastSample);\n                const timescaleUnits = intoTimescale(sample.decodeTimestamp, trackData.timescale, false);\n                const delta = Math.round(timescaleUnits - trackData.lastTimescaleUnits);\n                assert(delta >= 0);\n                trackData.lastTimescaleUnits += delta;\n                trackData.lastSample.timescaleUnitsToNextSample = delta;\n                if (!this.isFragmented) {\n                    let lastTableEntry = last(trackData.timeToSampleTable);\n                    assert(lastTableEntry);\n                    if (lastTableEntry.sampleCount === 1) {\n                        lastTableEntry.sampleDelta = delta;\n                        const entryBefore = trackData.timeToSampleTable[trackData.timeToSampleTable.length - 2];\n                        if (entryBefore && entryBefore.sampleDelta === delta) {\n                            // If the delta is the same as the previous one, merge the two entries\n                            entryBefore.sampleCount++;\n                            trackData.timeToSampleTable.pop();\n                            lastTableEntry = entryBefore;\n                        }\n                    }\n                    else if (lastTableEntry.sampleDelta !== delta) {\n                        // The delta has changed, so we need a new entry to reach the current sample\n                        lastTableEntry.sampleCount--;\n                        trackData.timeToSampleTable.push(lastTableEntry = {\n                            sampleCount: 1,\n                            sampleDelta: delta,\n                        });\n                    }\n                    if (lastTableEntry.sampleDelta === durationInTimescale) {\n                        // The sample's duration matches the delta, so we can increment the count\n                        lastTableEntry.sampleCount++;\n                    }\n                    else {\n                        // Add a new entry in order to maintain the last sample's true duration\n                        trackData.timeToSampleTable.push({\n                            sampleCount: 1,\n                            sampleDelta: durationInTimescale,\n                        });\n                    }\n                    const lastCompositionTimeOffsetTableEntry = last(trackData.compositionTimeOffsetTable);\n                    assert(lastCompositionTimeOffsetTableEntry);\n                    if (lastCompositionTimeOffsetTableEntry.sampleCompositionTimeOffset === sampleCompositionTimeOffset) {\n                        // Simply increment the count\n                        lastCompositionTimeOffsetTableEntry.sampleCount++;\n                    }\n                    else {\n                        // The composition time offset has changed, so create a new entry with the new composition time\n                        // offset\n                        trackData.compositionTimeOffsetTable.push({\n                            sampleCount: 1,\n                            sampleCompositionTimeOffset: sampleCompositionTimeOffset,\n                        });\n                    }\n                }\n            }\n            else {\n                // Decode timestamp of the first sample\n                trackData.lastTimescaleUnits = intoTimescale(sample.decodeTimestamp, trackData.timescale, false);\n                if (!this.isFragmented) {\n                    trackData.timeToSampleTable.push({\n                        sampleCount: 1,\n                        sampleDelta: durationInTimescale,\n                    });\n                    trackData.compositionTimeOffsetTable.push({\n                        sampleCount: 1,\n                        sampleCompositionTimeOffset: sampleCompositionTimeOffset,\n                    });\n                }\n            }\n            trackData.lastSample = sample;\n        }\n        trackData.timestampProcessingQueue.length = 0;\n        assert(trackData.lastSample);\n        assert(trackData.lastTimescaleUnits !== null);\n        if (nextSample !== undefined && trackData.lastSample.timescaleUnitsToNextSample === 0) {\n            assert(nextSample.type === 'key');\n            // Given the next sample, we can make a guess about the duration of the last sample. This avoids having\n            // the last sample's duration in each fragment be \"0\" for fragmented files. The guess we make here is\n            // actually correct most of the time, since typically, no delta frame with a lower timestamp follows the key\n            // frame (although it can happen).\n            const timescaleUnits = intoTimescale(nextSample.timestamp, trackData.timescale, false);\n            const delta = Math.round(timescaleUnits - trackData.lastTimescaleUnits);\n            trackData.lastSample.timescaleUnitsToNextSample = delta;\n        }\n    }\n    async registerSample(trackData, sample) {\n        if (sample.type === 'key') {\n            this.processTimestamps(trackData, sample);\n        }\n        trackData.timestampProcessingQueue.push(sample);\n        if (this.isFragmented) {\n            trackData.sampleQueue.push(sample);\n            await this.interleaveSamples();\n        }\n        else if (this.fastStart === 'reserve') {\n            await this.registerSampleFastStartReserve(trackData, sample);\n        }\n        else {\n            await this.addSampleToTrack(trackData, sample);\n        }\n    }\n    async addSampleToTrack(trackData, sample) {\n        if (!this.isFragmented) {\n            trackData.samples.push(sample);\n            if (this.fastStart === 'reserve') {\n                const maximumPacketCount = trackData.track.metadata.maximumPacketCount;\n                assert(maximumPacketCount !== undefined);\n                if (trackData.samples.length > maximumPacketCount) {\n                    throw new Error(`Track #${trackData.track.id} has already reached the maximum packet count`\n                        + ` (${maximumPacketCount}). Either add less packets or increase the maximum packet count.`);\n                }\n            }\n        }\n        let beginNewChunk = false;\n        if (!trackData.currentChunk) {\n            beginNewChunk = true;\n        }\n        else {\n            // Timestamp don't need to be monotonic (think B-frames), so we may need to update the start timestamp of\n            // the chunk\n            trackData.currentChunk.startTimestamp = Math.min(trackData.currentChunk.startTimestamp, sample.timestamp);\n            const currentChunkDuration = sample.timestamp - trackData.currentChunk.startTimestamp;\n            if (this.isFragmented) {\n                // We can only finalize this fragment (and begin a new one) if we know that each track will be able to\n                // start the new one with a key frame.\n                const keyFrameQueuedEverywhere = this.trackDatas.every((otherTrackData) => {\n                    if (trackData === otherTrackData) {\n                        return sample.type === 'key';\n                    }\n                    const firstQueuedSample = otherTrackData.sampleQueue[0];\n                    if (firstQueuedSample) {\n                        return firstQueuedSample.type === 'key';\n                    }\n                    return otherTrackData.track.source._closed;\n                });\n                if (currentChunkDuration >= this.minimumFragmentDuration\n                    && keyFrameQueuedEverywhere\n                    && sample.timestamp > this.maxWrittenTimestamp) {\n                    beginNewChunk = true;\n                    await this.finalizeFragment();\n                }\n            }\n            else {\n                beginNewChunk = currentChunkDuration >= 0.5; // Chunk is long enough, we need a new one\n            }\n        }\n        if (beginNewChunk) {\n            if (trackData.currentChunk) {\n                await this.finalizeCurrentChunk(trackData);\n            }\n            trackData.currentChunk = {\n                startTimestamp: sample.timestamp,\n                samples: [],\n                offset: null,\n                moofOffset: null,\n            };\n        }\n        assert(trackData.currentChunk);\n        trackData.currentChunk.samples.push(sample);\n        if (this.isFragmented) {\n            this.maxWrittenTimestamp = Math.max(this.maxWrittenTimestamp, sample.timestamp);\n        }\n    }\n    async finalizeCurrentChunk(trackData) {\n        assert(!this.isFragmented);\n        if (!trackData.currentChunk)\n            return;\n        trackData.finalizedChunks.push(trackData.currentChunk);\n        this.finalizedChunks.push(trackData.currentChunk);\n        let sampleCount = trackData.currentChunk.samples.length;\n        if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n            sampleCount = trackData.currentChunk.samples\n                .reduce((acc, sample) => acc + intoTimescale(sample.duration, trackData.timescale), 0);\n        }\n        if (trackData.compactlyCodedChunkTable.length === 0\n            || last(trackData.compactlyCodedChunkTable).samplesPerChunk !== sampleCount) {\n            trackData.compactlyCodedChunkTable.push({\n                firstChunk: trackData.finalizedChunks.length, // 1-indexed\n                samplesPerChunk: sampleCount,\n            });\n        }\n        if (this.fastStart === 'in-memory') {\n            trackData.currentChunk.offset = 0; // We'll compute the proper offset when finalizing\n            return;\n        }\n        // Write out the data\n        trackData.currentChunk.offset = this.writer.getPos();\n        for (const sample of trackData.currentChunk.samples) {\n            assert(sample.data);\n            this.writer.write(sample.data);\n            sample.data = null; // Can be GC'd\n        }\n        await this.writer.flush();\n    }\n    async interleaveSamples(isFinalCall = false) {\n        assert(this.isFragmented);\n        if (!isFinalCall && !this.allTracksAreKnown()) {\n            return; // We can't interleave yet as we don't yet know how many tracks we'll truly have\n        }\n        outer: while (true) {\n            let trackWithMinTimestamp = null;\n            let minTimestamp = Infinity;\n            for (const trackData of this.trackDatas) {\n                if (!isFinalCall && trackData.sampleQueue.length === 0 && !trackData.track.source._closed) {\n                    break outer;\n                }\n                if (trackData.sampleQueue.length > 0 && trackData.sampleQueue[0].timestamp < minTimestamp) {\n                    trackWithMinTimestamp = trackData;\n                    minTimestamp = trackData.sampleQueue[0].timestamp;\n                }\n            }\n            if (!trackWithMinTimestamp) {\n                break;\n            }\n            const sample = trackWithMinTimestamp.sampleQueue.shift();\n            await this.addSampleToTrack(trackWithMinTimestamp, sample);\n        }\n    }\n    async finalizeFragment(flushWriter = true) {\n        assert(this.isFragmented);\n        const fragmentNumber = this.nextFragmentNumber++;\n        if (fragmentNumber === 1) {\n            if (this.format._options.onMoov) {\n                this.writer.startTrackingWrites();\n            }\n            // Write the moov box now that we have all decoder configs\n            const movieBox = moov(this);\n            this.boxWriter.writeBox(movieBox);\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n        }\n        // Not all tracks need to be present in every fragment\n        const tracksInFragment = this.trackDatas.filter(x => x.currentChunk);\n        // Create an initial moof box and measure it; we need this to know where the following mdat box will begin\n        const moofBox = moof(fragmentNumber, tracksInFragment);\n        const moofOffset = this.writer.getPos();\n        const mdatStartPos = moofOffset + this.boxWriter.measureBox(moofBox);\n        let currentPos = mdatStartPos + MIN_BOX_HEADER_SIZE;\n        let fragmentStartTimestamp = Infinity;\n        for (const trackData of tracksInFragment) {\n            trackData.currentChunk.offset = currentPos;\n            trackData.currentChunk.moofOffset = moofOffset;\n            for (const sample of trackData.currentChunk.samples) {\n                currentPos += sample.size;\n            }\n            fragmentStartTimestamp = Math.min(fragmentStartTimestamp, trackData.currentChunk.startTimestamp);\n        }\n        const mdatSize = currentPos - mdatStartPos;\n        const needsLargeMdatSize = mdatSize >= 2 ** 32;\n        if (needsLargeMdatSize) {\n            // Shift all offsets by 8. Previously, all chunks were shifted assuming the large box size, but due to what\n            // I suspect is a bug in WebKit, it failed in Safari (when livestreaming with MSE, not for static playback).\n            for (const trackData of tracksInFragment) {\n                trackData.currentChunk.offset += MAX_BOX_HEADER_SIZE - MIN_BOX_HEADER_SIZE;\n            }\n        }\n        if (this.format._options.onMoof) {\n            this.writer.startTrackingWrites();\n        }\n        const newMoofBox = moof(fragmentNumber, tracksInFragment);\n        this.boxWriter.writeBox(newMoofBox);\n        if (this.format._options.onMoof) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onMoof(data, start, fragmentStartTimestamp);\n        }\n        assert(this.writer.getPos() === mdatStartPos);\n        if (this.format._options.onMdat) {\n            this.writer.startTrackingWrites();\n        }\n        const mdatBox = mdat(needsLargeMdatSize);\n        mdatBox.size = mdatSize;\n        this.boxWriter.writeBox(mdatBox);\n        this.writer.seek(mdatStartPos + (needsLargeMdatSize ? MAX_BOX_HEADER_SIZE : MIN_BOX_HEADER_SIZE));\n        // Write sample data\n        for (const trackData of tracksInFragment) {\n            for (const sample of trackData.currentChunk.samples) {\n                this.writer.write(sample.data);\n                sample.data = null; // Can be GC'd\n            }\n        }\n        if (this.format._options.onMdat) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onMdat(data, start);\n        }\n        for (const trackData of tracksInFragment) {\n            trackData.finalizedChunks.push(trackData.currentChunk);\n            this.finalizedChunks.push(trackData.currentChunk);\n            trackData.currentChunk = null;\n        }\n        if (flushWriter) {\n            await this.writer.flush();\n        }\n    }\n    async registerSampleFastStartReserve(trackData, sample) {\n        if (this.allTracksAreKnown()) {\n            if (!this.mdat) {\n                // We finally know all tracks, let's reserve space for the moov box\n                const moovBox = moov(this);\n                const moovSize = this.boxWriter.measureBox(moovBox);\n                const reservedSize = moovSize\n                    + this.computeSampleTableSizeUpperBound()\n                    + 4096; // Just a little extra headroom\n                assert(this.ftypSize !== null);\n                this.writer.seek(this.ftypSize + reservedSize);\n                if (this.format._options.onMdat) {\n                    this.writer.startTrackingWrites();\n                }\n                this.mdat = mdat(true);\n                this.boxWriter.writeBox(this.mdat);\n                // Now write everything that was queued\n                for (const trackData of this.trackDatas) {\n                    for (const sample of trackData.sampleQueue) {\n                        await this.addSampleToTrack(trackData, sample);\n                    }\n                    trackData.sampleQueue.length = 0;\n                }\n            }\n            await this.addSampleToTrack(trackData, sample);\n        }\n        else {\n            // Queue it for when we know all tracks\n            trackData.sampleQueue.push(sample);\n        }\n    }\n    computeSampleTableSizeUpperBound() {\n        assert(this.fastStart === 'reserve');\n        let upperBound = 0;\n        for (const trackData of this.trackDatas) {\n            const n = trackData.track.metadata.maximumPacketCount;\n            assert(n !== undefined); // We validated this earlier\n            // Given the max allowed packet count, compute the space they'll take up in the Sample Table Box, assuming\n            // the worst case for each individual box:\n            // stts box - since it is compactly coded, the maximum length of this table will be 2/3n\n            upperBound += (4 + 4) * Math.ceil(2 / 3 * n);\n            // stss box - 1 entry per sample\n            upperBound += 4 * n;\n            // ctts box - since it is compactly coded, the maximum length of this table will be 2/3n\n            upperBound += (4 + 4) * Math.ceil(2 / 3 * n);\n            // stsc box - since it is compactly coded, the maximum length of this table will be 2/3n\n            upperBound += (4 + 4 + 4) * Math.ceil(2 / 3 * n);\n            // stsz box - 1 entry per sample\n            upperBound += 4 * n;\n            // co64 box - we assume 1 sample per chunk and 64-bit chunk offsets (co64 instead of stco)\n            upperBound += 8 * n;\n        }\n        return upperBound;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    async onTrackClose(track) {\n        const release = await this.mutex.acquire();\n        if (track.type === 'subtitle' && track.source._codec === 'webvtt') {\n            const trackData = this.trackDatas.find(x => x.track === track);\n            if (trackData) {\n                await this.processWebVTTCues(trackData, Infinity);\n            }\n        }\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        if (this.isFragmented) {\n            // Since a track is now closed, we may be able to write out chunks that were previously waiting\n            await this.interleaveSamples();\n        }\n        release();\n    }\n    /** Finalizes the file, making it ready for use. Must be called after all video and audio chunks have been added. */\n    async finalize() {\n        const release = await this.mutex.acquire();\n        this.allTracksKnown.resolve();\n        for (const trackData of this.trackDatas) {\n            if (trackData.type === 'subtitle' && trackData.track.source._codec === 'webvtt') {\n                await this.processWebVTTCues(trackData, Infinity);\n            }\n        }\n        if (this.isFragmented) {\n            await this.interleaveSamples(true);\n            for (const trackData of this.trackDatas) {\n                this.processTimestamps(trackData);\n            }\n            await this.finalizeFragment(false); // Don't flush the last fragment as we will flush it with the mfra box\n        }\n        else {\n            for (const trackData of this.trackDatas) {\n                this.processTimestamps(trackData);\n                await this.finalizeCurrentChunk(trackData);\n            }\n        }\n        if (this.fastStart === 'in-memory') {\n            this.mdat = mdat(false);\n            let mdatSize;\n            // We know how many chunks there are, but computing the chunk positions requires an iterative approach:\n            // In order to know where the first chunk should go, we first need to know the size of the moov box. But we\n            // cannot write a proper moov box without first knowing all chunk positions. So, we generate a tentative\n            // moov box with placeholder values (0) for the chunk offsets to be able to compute its size. If it then\n            // turns out that appending all chunks exceeds 4 GiB, we need to repeat this process, now with the co64 box\n            // being used in the moov box instead, which will make it larger. After that, we definitely know the final\n            // size of the moov box and can compute the proper chunk positions.\n            for (let i = 0; i < 2; i++) {\n                const movieBox = moov(this);\n                const movieBoxSize = this.boxWriter.measureBox(movieBox);\n                mdatSize = this.boxWriter.measureBox(this.mdat);\n                let currentChunkPos = this.writer.getPos() + movieBoxSize + mdatSize;\n                for (const chunk of this.finalizedChunks) {\n                    chunk.offset = currentChunkPos;\n                    for (const { data } of chunk.samples) {\n                        assert(data);\n                        currentChunkPos += data.byteLength;\n                        mdatSize += data.byteLength;\n                    }\n                }\n                if (currentChunkPos < 2 ** 32)\n                    break;\n                if (mdatSize >= 2 ** 32)\n                    this.mdat.largeSize = true;\n            }\n            if (this.format._options.onMoov) {\n                this.writer.startTrackingWrites();\n            }\n            const movieBox = moov(this);\n            this.boxWriter.writeBox(movieBox);\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n            if (this.format._options.onMdat) {\n                this.writer.startTrackingWrites();\n            }\n            this.mdat.size = mdatSize;\n            this.boxWriter.writeBox(this.mdat);\n            for (const chunk of this.finalizedChunks) {\n                for (const sample of chunk.samples) {\n                    assert(sample.data);\n                    this.writer.write(sample.data);\n                    sample.data = null;\n                }\n            }\n            if (this.format._options.onMdat) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMdat(data, start);\n            }\n        }\n        else if (this.isFragmented) {\n            // Append the mfra box to the end of the file for better random access\n            const startPos = this.writer.getPos();\n            const mfraBox = mfra(this.trackDatas);\n            this.boxWriter.writeBox(mfraBox);\n            // Patch the 'size' field of the mfro box at the end of the mfra box now that we know its actual size\n            const mfraBoxSize = this.writer.getPos() - startPos;\n            this.writer.seek(this.writer.getPos() - 4);\n            this.boxWriter.writeU32(mfraBoxSize);\n        }\n        else {\n            assert(this.mdat);\n            const mdatPos = this.boxWriter.offsets.get(this.mdat);\n            assert(mdatPos !== undefined);\n            const mdatSize = this.writer.getPos() - mdatPos;\n            this.mdat.size = mdatSize;\n            this.mdat.largeSize = mdatSize >= 2 ** 32; // Only use the large size if we need it\n            this.boxWriter.patchBox(this.mdat);\n            if (this.format._options.onMdat) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMdat(data, start);\n            }\n            const movieBox = moov(this);\n            if (this.fastStart === 'reserve') {\n                assert(this.ftypSize !== null);\n                this.writer.seek(this.ftypSize);\n                if (this.format._options.onMoov) {\n                    this.writer.startTrackingWrites();\n                }\n                this.boxWriter.writeBox(movieBox);\n                // Fill the remaining space with a free box. If there are less than 8 bytes left, sucks I guess\n                const remainingSpace = this.boxWriter.offsets.get(this.mdat) - this.writer.getPos();\n                this.boxWriter.writeBox(free(remainingSpace));\n            }\n            else {\n                if (this.format._options.onMoov) {\n                    this.writer.startTrackingWrites();\n                }\n                this.boxWriter.writeBox(movieBox);\n            }\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n        }\n        release();\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Bitstream, COLOR_PRIMARIES_MAP, MATRIX_COEFFICIENTS_MAP, TRANSFER_CHARACTERISTICS_MAP, UNDETERMINED_LANGUAGE, assert, assertNever, colorSpaceIsComplete, imageMimeTypeToExtension, keyValueIterator, normalizeRotation, promiseWithResolvers, roundToMultiple, textEncoder, toUint8Array, uint8ArraysAreEqual, writeBits, } from '../misc.js';\nimport { CODEC_STRING_MAP, EBMLFloat32, EBMLFloat64, EBMLId, EBMLSignedInt, EBMLUnicodeString, EBMLWriter, } from './ebml.js';\nimport { buildMatroskaMimeType } from './matroska-misc.js';\nimport { WebMOutputFormat } from '../output-format.js';\nimport { formatSubtitleTimestamp, inlineTimestampRegex, parseSubtitleTimestamp, } from '../subtitles.js';\nimport { OPUS_SAMPLE_RATE, PCM_AUDIO_CODECS, generateAv1CodecConfigurationFromCodecString, generateVp9CodecConfigurationFromCodecString, parsePcmCodec, validateAudioChunkMetadata, validateSubtitleMetadata, validateVideoChunkMetadata, } from '../codec.js';\nimport { Muxer } from '../muxer.js';\nimport { parseOpusIdentificationHeader } from '../codec-data.js';\nimport { AttachedFile } from '../metadata.js';\nconst MIN_CLUSTER_TIMESTAMP_MS = -(2 ** 15);\nconst MAX_CLUSTER_TIMESTAMP_MS = 2 ** 15 - 1;\nconst APP_NAME = 'Mediabunny';\nconst SEGMENT_SIZE_BYTES = 6;\nconst CLUSTER_SIZE_BYTES = 5;\nconst TRACK_TYPE_MAP = {\n    video: 1,\n    audio: 2,\n    subtitle: 17,\n};\nexport class MatroskaMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.trackDatas = [];\n        this.allTracksKnown = promiseWithResolvers();\n        this.segment = null;\n        this.segmentInfo = null;\n        this.seekHead = null;\n        this.tracksElement = null;\n        this.tagsElement = null;\n        this.attachmentsElement = null;\n        this.segmentDuration = null;\n        this.cues = null;\n        this.currentCluster = null;\n        this.currentClusterStartMsTimestamp = null;\n        this.currentClusterMaxMsTimestamp = null;\n        this.trackDatasInCurrentCluster = new Map();\n        this.duration = 0;\n        this.writer = output._writer;\n        this.format = format;\n        this.ebmlWriter = new EBMLWriter(this.writer);\n        if (this.format._options.appendOnly) {\n            this.writer.ensureMonotonicity = true;\n        }\n    }\n    async start() {\n        const release = await this.mutex.acquire();\n        this.writeEBMLHeader();\n        this.createSegmentInfo();\n        this.createCues();\n        await this.writer.flush();\n        release();\n    }\n    writeEBMLHeader() {\n        if (this.format._options.onEbmlHeader) {\n            this.writer.startTrackingWrites();\n        }\n        const ebmlHeader = { id: EBMLId.EBML, data: [\n                { id: EBMLId.EBMLVersion, data: 1 },\n                { id: EBMLId.EBMLReadVersion, data: 1 },\n                { id: EBMLId.EBMLMaxIDLength, data: 4 },\n                { id: EBMLId.EBMLMaxSizeLength, data: 8 },\n                { id: EBMLId.DocType, data: this.format instanceof WebMOutputFormat ? 'webm' : 'matroska' },\n                { id: EBMLId.DocTypeVersion, data: 2 },\n                { id: EBMLId.DocTypeReadVersion, data: 2 },\n            ] };\n        this.ebmlWriter.writeEBML(ebmlHeader);\n        if (this.format._options.onEbmlHeader) {\n            const { data, start } = this.writer.stopTrackingWrites(); // start should be 0\n            this.format._options.onEbmlHeader(data, start);\n        }\n    }\n    /**\n     * Creates a SeekHead element which is positioned near the start of the file and allows the media player to seek to\n     * relevant sections more easily. Since we don't know the positions of those sections yet, we'll set them later.\n     */\n    maybeCreateSeekHead(writeOffsets) {\n        if (this.format._options.appendOnly) {\n            return;\n        }\n        const kaxCues = new Uint8Array([0x1c, 0x53, 0xbb, 0x6b]);\n        const kaxInfo = new Uint8Array([0x15, 0x49, 0xa9, 0x66]);\n        const kaxTracks = new Uint8Array([0x16, 0x54, 0xae, 0x6b]);\n        const kaxAttachments = new Uint8Array([0x19, 0x41, 0xa4, 0x69]);\n        const kaxTags = new Uint8Array([0x12, 0x54, 0xc3, 0x67]);\n        const seekHead = { id: EBMLId.SeekHead, data: [\n                { id: EBMLId.Seek, data: [\n                        { id: EBMLId.SeekID, data: kaxCues },\n                        {\n                            id: EBMLId.SeekPosition,\n                            size: 5,\n                            data: writeOffsets\n                                ? this.ebmlWriter.offsets.get(this.cues) - this.segmentDataOffset\n                                : 0,\n                        },\n                    ] },\n                { id: EBMLId.Seek, data: [\n                        { id: EBMLId.SeekID, data: kaxInfo },\n                        {\n                            id: EBMLId.SeekPosition,\n                            size: 5,\n                            data: writeOffsets\n                                ? this.ebmlWriter.offsets.get(this.segmentInfo) - this.segmentDataOffset\n                                : 0,\n                        },\n                    ] },\n                { id: EBMLId.Seek, data: [\n                        { id: EBMLId.SeekID, data: kaxTracks },\n                        {\n                            id: EBMLId.SeekPosition,\n                            size: 5,\n                            data: writeOffsets\n                                ? this.ebmlWriter.offsets.get(this.tracksElement) - this.segmentDataOffset\n                                : 0,\n                        },\n                    ] },\n                this.attachmentsElement\n                    ? { id: EBMLId.Seek, data: [\n                            { id: EBMLId.SeekID, data: kaxAttachments },\n                            {\n                                id: EBMLId.SeekPosition,\n                                size: 5,\n                                data: writeOffsets\n                                    ? this.ebmlWriter.offsets.get(this.attachmentsElement) - this.segmentDataOffset\n                                    : 0,\n                            },\n                        ] }\n                    : null,\n                this.tagsElement\n                    ? { id: EBMLId.Seek, data: [\n                            { id: EBMLId.SeekID, data: kaxTags },\n                            {\n                                id: EBMLId.SeekPosition,\n                                size: 5,\n                                data: writeOffsets\n                                    ? this.ebmlWriter.offsets.get(this.tagsElement) - this.segmentDataOffset\n                                    : 0,\n                            },\n                        ] }\n                    : null,\n            ] };\n        this.seekHead = seekHead;\n    }\n    createSegmentInfo() {\n        const segmentDuration = { id: EBMLId.Duration, data: new EBMLFloat64(0) };\n        this.segmentDuration = segmentDuration;\n        const segmentInfo = { id: EBMLId.Info, data: [\n                { id: EBMLId.TimestampScale, data: 1e6 },\n                { id: EBMLId.MuxingApp, data: APP_NAME },\n                { id: EBMLId.WritingApp, data: APP_NAME },\n                !this.format._options.appendOnly ? segmentDuration : null,\n            ] };\n        this.segmentInfo = segmentInfo;\n    }\n    createTracks() {\n        const tracksElement = { id: EBMLId.Tracks, data: [] };\n        this.tracksElement = tracksElement;\n        for (const trackData of this.trackDatas) {\n            const codecId = CODEC_STRING_MAP[trackData.track.source._codec];\n            assert(codecId);\n            let seekPreRollNs = 0;\n            if (trackData.type === 'audio' && trackData.track.source._codec === 'opus') {\n                seekPreRollNs = 1e6 * 80; // In \"Matroska ticks\" (nanoseconds)\n                const description = trackData.info.decoderConfig.description;\n                if (description) {\n                    const bytes = toUint8Array(description);\n                    const header = parseOpusIdentificationHeader(bytes);\n                    // Use the preSkip value from the header\n                    seekPreRollNs = Math.round(1e9 * (header.preSkip / OPUS_SAMPLE_RATE));\n                }\n            }\n            tracksElement.data.push({ id: EBMLId.TrackEntry, data: [\n                    { id: EBMLId.TrackNumber, data: trackData.track.id },\n                    { id: EBMLId.TrackUID, data: trackData.track.id },\n                    { id: EBMLId.TrackType, data: TRACK_TYPE_MAP[trackData.type] },\n                    trackData.track.metadata.disposition?.default === false\n                        ? { id: EBMLId.FlagDefault, data: 0 }\n                        : null,\n                    trackData.track.metadata.disposition?.forced\n                        ? { id: EBMLId.FlagForced, data: 1 }\n                        : null,\n                    trackData.track.metadata.disposition?.hearingImpaired\n                        ? { id: EBMLId.FlagHearingImpaired, data: 1 }\n                        : null,\n                    trackData.track.metadata.disposition?.visuallyImpaired\n                        ? { id: EBMLId.FlagVisualImpaired, data: 1 }\n                        : null,\n                    trackData.track.metadata.disposition?.original\n                        ? { id: EBMLId.FlagOriginal, data: 1 }\n                        : null,\n                    trackData.track.metadata.disposition?.commentary\n                        ? { id: EBMLId.FlagCommentary, data: 1 }\n                        : null,\n                    { id: EBMLId.FlagLacing, data: 0 },\n                    { id: EBMLId.Language, data: trackData.track.metadata.languageCode ?? UNDETERMINED_LANGUAGE },\n                    { id: EBMLId.CodecID, data: codecId },\n                    { id: EBMLId.CodecDelay, data: 0 },\n                    { id: EBMLId.SeekPreRoll, data: seekPreRollNs },\n                    trackData.track.metadata.name !== undefined\n                        ? { id: EBMLId.Name, data: new EBMLUnicodeString(trackData.track.metadata.name) }\n                        : null,\n                    (trackData.type === 'video' ? this.videoSpecificTrackInfo(trackData) : null),\n                    (trackData.type === 'audio' ? this.audioSpecificTrackInfo(trackData) : null),\n                    (trackData.type === 'subtitle' ? this.subtitleSpecificTrackInfo(trackData) : null),\n                ] });\n        }\n    }\n    videoSpecificTrackInfo(trackData) {\n        const { frameRate, rotation } = trackData.track.metadata;\n        const elements = [\n            (trackData.info.decoderConfig.description\n                ? {\n                    id: EBMLId.CodecPrivate,\n                    data: toUint8Array(trackData.info.decoderConfig.description),\n                }\n                : null),\n            (frameRate\n                ? {\n                    id: EBMLId.DefaultDuration,\n                    data: 1e9 / frameRate,\n                }\n                : null),\n        ];\n        // Convert from clockwise to counter-clockwise\n        const flippedRotation = rotation ? normalizeRotation(-rotation) : 0;\n        const colorSpace = trackData.info.decoderConfig.colorSpace;\n        const videoElement = { id: EBMLId.Video, data: [\n                { id: EBMLId.PixelWidth, data: trackData.info.width },\n                { id: EBMLId.PixelHeight, data: trackData.info.height },\n                trackData.info.alphaMode ? { id: EBMLId.AlphaMode, data: 1 } : null,\n                (colorSpaceIsComplete(colorSpace)\n                    ? {\n                        id: EBMLId.Colour,\n                        data: [\n                            {\n                                id: EBMLId.MatrixCoefficients,\n                                data: MATRIX_COEFFICIENTS_MAP[colorSpace.matrix],\n                            },\n                            {\n                                id: EBMLId.TransferCharacteristics,\n                                data: TRANSFER_CHARACTERISTICS_MAP[colorSpace.transfer],\n                            },\n                            {\n                                id: EBMLId.Primaries,\n                                data: COLOR_PRIMARIES_MAP[colorSpace.primaries],\n                            },\n                            {\n                                id: EBMLId.Range,\n                                data: colorSpace.fullRange ? 2 : 1,\n                            },\n                        ],\n                    }\n                    : null),\n                (flippedRotation\n                    ? {\n                        id: EBMLId.Projection,\n                        data: [\n                            {\n                                id: EBMLId.ProjectionType,\n                                data: 0, // rectangular\n                            },\n                            {\n                                id: EBMLId.ProjectionPoseRoll,\n                                data: new EBMLFloat32((flippedRotation + 180) % 360 - 180), // [0, 270] -> [-180, 90]\n                            },\n                        ],\n                    }\n                    : null),\n            ] };\n        elements.push(videoElement);\n        return elements;\n    }\n    audioSpecificTrackInfo(trackData) {\n        const pcmInfo = PCM_AUDIO_CODECS.includes(trackData.track.source._codec)\n            ? parsePcmCodec(trackData.track.source._codec)\n            : null;\n        return [\n            (trackData.info.decoderConfig.description\n                ? {\n                    id: EBMLId.CodecPrivate,\n                    data: toUint8Array(trackData.info.decoderConfig.description),\n                }\n                : null),\n            { id: EBMLId.Audio, data: [\n                    { id: EBMLId.SamplingFrequency, data: new EBMLFloat32(trackData.info.sampleRate) },\n                    { id: EBMLId.Channels, data: trackData.info.numberOfChannels },\n                    pcmInfo ? { id: EBMLId.BitDepth, data: 8 * pcmInfo.sampleSize } : null,\n                ] },\n        ];\n    }\n    subtitleSpecificTrackInfo(trackData) {\n        return [\n            { id: EBMLId.CodecPrivate, data: textEncoder.encode(trackData.info.config.description) },\n        ];\n    }\n    maybeCreateTags() {\n        const simpleTags = [];\n        const addSimpleTag = (key, value) => {\n            simpleTags.push({ id: EBMLId.SimpleTag, data: [\n                    { id: EBMLId.TagName, data: new EBMLUnicodeString(key) },\n                    typeof value === 'string'\n                        ? { id: EBMLId.TagString, data: new EBMLUnicodeString(value) }\n                        : { id: EBMLId.TagBinary, data: value },\n                ] });\n        };\n        const metadataTags = this.output._metadataTags;\n        const writtenTags = new Set();\n        for (const { key, value } of keyValueIterator(metadataTags)) {\n            switch (key) {\n                case 'title':\n                    {\n                        addSimpleTag('TITLE', value);\n                        writtenTags.add('TITLE');\n                    }\n                    ;\n                    break;\n                case 'description':\n                    {\n                        addSimpleTag('DESCRIPTION', value);\n                        writtenTags.add('DESCRIPTION');\n                    }\n                    ;\n                    break;\n                case 'artist':\n                    {\n                        addSimpleTag('ARTIST', value);\n                        writtenTags.add('ARTIST');\n                    }\n                    ;\n                    break;\n                case 'album':\n                    {\n                        addSimpleTag('ALBUM', value);\n                        writtenTags.add('ALBUM');\n                    }\n                    ;\n                    break;\n                case 'albumArtist':\n                    {\n                        addSimpleTag('ALBUM_ARTIST', value);\n                        writtenTags.add('ALBUM_ARTIST');\n                    }\n                    ;\n                    break;\n                case 'genre':\n                    {\n                        addSimpleTag('GENRE', value);\n                        writtenTags.add('GENRE');\n                    }\n                    ;\n                    break;\n                case 'comment':\n                    {\n                        addSimpleTag('COMMENT', value);\n                        writtenTags.add('COMMENT');\n                    }\n                    ;\n                    break;\n                case 'lyrics':\n                    {\n                        addSimpleTag('LYRICS', value);\n                        writtenTags.add('LYRICS');\n                    }\n                    ;\n                    break;\n                case 'date':\n                    {\n                        addSimpleTag('DATE', value.toISOString().slice(0, 10));\n                        writtenTags.add('DATE');\n                    }\n                    ;\n                    break;\n                case 'trackNumber':\n                    {\n                        const string = metadataTags.tracksTotal !== undefined\n                            ? `${value}/${metadataTags.tracksTotal}`\n                            : value.toString();\n                        addSimpleTag('PART_NUMBER', string);\n                        writtenTags.add('PART_NUMBER');\n                    }\n                    ;\n                    break;\n                case 'discNumber':\n                    {\n                        const string = metadataTags.discsTotal !== undefined\n                            ? `${value}/${metadataTags.discsTotal}`\n                            : value.toString();\n                        addSimpleTag('DISC', string);\n                        writtenTags.add('DISC');\n                    }\n                    ;\n                    break;\n                case 'tracksTotal':\n                case 'discsTotal':\n                    {\n                        // Handled with trackNumber and discNumber respectively\n                    }\n                    ;\n                    break;\n                case 'images':\n                case 'raw':\n                    {\n                        // Handled elsewhere\n                    }\n                    ;\n                    break;\n                default: assertNever(key);\n            }\n        }\n        if (metadataTags.raw) {\n            for (const key in metadataTags.raw) {\n                const value = metadataTags.raw[key];\n                if (value == null || writtenTags.has(key)) {\n                    continue;\n                }\n                if (typeof value === 'string' || value instanceof Uint8Array) {\n                    addSimpleTag(key, value);\n                }\n            }\n        }\n        if (simpleTags.length === 0) {\n            return;\n        }\n        this.tagsElement = {\n            id: EBMLId.Tags,\n            data: [{ id: EBMLId.Tag, data: [\n                        { id: EBMLId.Targets, data: [\n                                { id: EBMLId.TargetTypeValue, data: 50 },\n                                { id: EBMLId.TargetType, data: 'MOVIE' },\n                            ] },\n                        ...simpleTags,\n                    ] }],\n        };\n    }\n    maybeCreateAttachments() {\n        const metadataTags = this.output._metadataTags;\n        const elements = [];\n        const existingFileUids = new Set();\n        const images = metadataTags.images ?? [];\n        for (const image of images) {\n            let imageName = image.name;\n            if (imageName === undefined) {\n                const baseName = image.kind === 'coverFront' ? 'cover' : image.kind === 'coverBack' ? 'back' : 'image';\n                imageName = baseName + (imageMimeTypeToExtension(image.mimeType) ?? '');\n            }\n            let fileUid;\n            while (true) {\n                // Generate a random 64-bit unsigned integer\n                fileUid = 0n;\n                for (let i = 0; i < 8; i++) {\n                    fileUid <<= 8n;\n                    fileUid |= BigInt(Math.floor(Math.random() * 256));\n                }\n                if (fileUid !== 0n && !existingFileUids.has(fileUid)) {\n                    break;\n                }\n            }\n            existingFileUids.add(fileUid);\n            elements.push({\n                id: EBMLId.AttachedFile,\n                data: [\n                    image.description !== undefined\n                        ? { id: EBMLId.FileDescription, data: new EBMLUnicodeString(image.description) }\n                        : null,\n                    { id: EBMLId.FileName, data: new EBMLUnicodeString(imageName) },\n                    { id: EBMLId.FileMediaType, data: image.mimeType },\n                    { id: EBMLId.FileData, data: image.data },\n                    { id: EBMLId.FileUID, data: fileUid },\n                ],\n            });\n        }\n        // Add all AttachedFiles from the raw metadata\n        for (const [key, value] of Object.entries(metadataTags.raw ?? {})) {\n            if (!(value instanceof AttachedFile)) {\n                continue;\n            }\n            const keyIsNumeric = /^\\d+$/.test(key);\n            if (!keyIsNumeric) {\n                continue;\n            }\n            if (images.find(x => x.mimeType === value.mimeType && uint8ArraysAreEqual(x.data, value.data))) {\n                // This attached file has very likely already been added as an image above\n                // (happens when remuxing Matroska)\n                continue;\n            }\n            elements.push({\n                id: EBMLId.AttachedFile,\n                data: [\n                    value.description !== undefined\n                        ? { id: EBMLId.FileDescription, data: new EBMLUnicodeString(value.description) }\n                        : null,\n                    { id: EBMLId.FileName, data: new EBMLUnicodeString(value.name ?? '') },\n                    { id: EBMLId.FileMediaType, data: value.mimeType ?? '' },\n                    { id: EBMLId.FileData, data: value.data },\n                    { id: EBMLId.FileUID, data: BigInt(key) },\n                ],\n            });\n        }\n        if (elements.length === 0) {\n            return;\n        }\n        this.attachmentsElement = { id: EBMLId.Attachments, data: elements };\n    }\n    createSegment() {\n        this.createTracks();\n        this.maybeCreateTags();\n        this.maybeCreateAttachments();\n        this.maybeCreateSeekHead(false);\n        const segment = {\n            id: EBMLId.Segment,\n            size: this.format._options.appendOnly ? -1 : SEGMENT_SIZE_BYTES,\n            data: [\n                this.seekHead, // null if append-only\n                this.segmentInfo,\n                this.tracksElement,\n                // Matroska spec says put this at the end of the file, but I think placing it before the first cluster\n                // makes more sense, and FFmpeg agrees (argumentum ad ffmpegum fallacy)\n                this.attachmentsElement,\n                this.tagsElement,\n            ],\n        };\n        this.segment = segment;\n        if (this.format._options.onSegmentHeader) {\n            this.writer.startTrackingWrites();\n        }\n        this.ebmlWriter.writeEBML(segment);\n        if (this.format._options.onSegmentHeader) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onSegmentHeader(data, start);\n        }\n    }\n    createCues() {\n        this.cues = { id: EBMLId.Cues, data: [] };\n    }\n    get segmentDataOffset() {\n        assert(this.segment);\n        return this.ebmlWriter.dataOffsets.get(this.segment);\n    }\n    allTracksAreKnown() {\n        for (const track of this.output._tracks) {\n            if (!track.source._closed && !this.trackDatas.some(x => x.track === track)) {\n                return false; // We haven't seen a sample from this open track yet\n            }\n        }\n        return true;\n    }\n    async getMimeType() {\n        await this.allTracksKnown.promise;\n        const codecStrings = this.trackDatas.map((trackData) => {\n            if (trackData.type === 'video') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else if (trackData.type === 'audio') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else {\n                const map = {\n                    webvtt: 'wvtt',\n                };\n                return map[trackData.track.source._codec];\n            }\n        });\n        return buildMatroskaMimeType({\n            isWebM: this.format instanceof WebMOutputFormat,\n            hasVideo: this.trackDatas.some(x => x.type === 'video'),\n            hasAudio: this.trackDatas.some(x => x.type === 'audio'),\n            codecStrings,\n        });\n    }\n    getVideoTrackData(track, packet, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateVideoChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        assert(meta.decoderConfig.codedWidth !== undefined);\n        assert(meta.decoderConfig.codedHeight !== undefined);\n        const newTrackData = {\n            track,\n            type: 'video',\n            info: {\n                width: meta.decoderConfig.codedWidth,\n                height: meta.decoderConfig.codedHeight,\n                decoderConfig: meta.decoderConfig,\n                alphaMode: !!packet.sideData.alpha, // The first packet determines if this track has alpha or not\n            },\n            chunkQueue: [],\n            lastWrittenMsTimestamp: null,\n        };\n        if (track.source._codec === 'vp9') {\n            // https://www.webmproject.org/docs/container specifies that VP9 \"SHOULD\" make use of the CodecPrivate\n            // field. Since WebCodecs makes no use of the description field for VP9, we need to derive it ourselves:\n            newTrackData.info.decoderConfig = {\n                ...newTrackData.info.decoderConfig,\n                description: new Uint8Array(generateVp9CodecConfigurationFromCodecString(newTrackData.info.decoderConfig.codec)),\n            };\n        }\n        else if (track.source._codec === 'av1') {\n            // Per https://github.com/ietf-wg-cellar/matroska-specification/blob/master/codec/av1.md, AV1 requires\n            // CodecPrivate to be set, but WebCodecs makes no use of the description field for AV1. Thus, let's derive\n            // it ourselves:\n            newTrackData.info.decoderConfig = {\n                ...newTrackData.info.decoderConfig,\n                description: new Uint8Array(generateAv1CodecConfigurationFromCodecString(newTrackData.info.decoderConfig.codec)),\n            };\n        }\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getAudioTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateAudioChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const newTrackData = {\n            track,\n            type: 'audio',\n            info: {\n                numberOfChannels: meta.decoderConfig.numberOfChannels,\n                sampleRate: meta.decoderConfig.sampleRate,\n                decoderConfig: meta.decoderConfig,\n            },\n            chunkQueue: [],\n            lastWrittenMsTimestamp: null,\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getSubtitleTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateSubtitleMetadata(meta);\n        assert(meta);\n        assert(meta.config);\n        const newTrackData = {\n            track,\n            type: 'subtitle',\n            info: {\n                config: meta.config,\n            },\n            chunkQueue: [],\n            lastWrittenMsTimestamp: null,\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    async addEncodedVideoPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getVideoTrackData(track, packet, meta);\n            const isKeyFrame = packet.type === 'key';\n            let timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, isKeyFrame);\n            let duration = packet.duration;\n            if (track.metadata.frameRate !== undefined) {\n                // Constrain the time values to the frame rate\n                timestamp = roundToMultiple(timestamp, 1 / track.metadata.frameRate);\n                duration = roundToMultiple(duration, 1 / track.metadata.frameRate);\n            }\n            const additions = trackData.info.alphaMode\n                ? packet.sideData.alpha ?? null\n                : null;\n            const videoChunk = this.createInternalChunk(packet.data, timestamp, duration, packet.type, additions);\n            if (track.source._codec === 'vp9')\n                this.fixVP9ColorSpace(trackData, videoChunk);\n            trackData.chunkQueue.push(videoChunk);\n            await this.interleaveChunks();\n        }\n        finally {\n            release();\n        }\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getAudioTrackData(track, meta);\n            const isKeyFrame = packet.type === 'key';\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, isKeyFrame);\n            const audioChunk = this.createInternalChunk(packet.data, timestamp, packet.duration, packet.type);\n            trackData.chunkQueue.push(audioChunk);\n            await this.interleaveChunks();\n        }\n        finally {\n            release();\n        }\n    }\n    async addSubtitleCue(track, cue, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getSubtitleTrackData(track, meta);\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, cue.timestamp, true);\n            let bodyText = cue.text;\n            const timestampMs = Math.round(timestamp * 1000);\n            // Replace in-body timestamps so that they're relative to the cue start time\n            inlineTimestampRegex.lastIndex = 0;\n            bodyText = bodyText.replace(inlineTimestampRegex, (match) => {\n                const time = parseSubtitleTimestamp(match.slice(1, -1));\n                const offsetTime = time - timestampMs;\n                return `<${formatSubtitleTimestamp(offsetTime)}>`;\n            });\n            const body = textEncoder.encode(bodyText);\n            const additions = `${cue.settings ?? ''}\\n${cue.identifier ?? ''}\\n${cue.notes ?? ''}`;\n            const subtitleChunk = this.createInternalChunk(body, timestamp, cue.duration, 'key', additions.trim() ? textEncoder.encode(additions) : null);\n            trackData.chunkQueue.push(subtitleChunk);\n            await this.interleaveChunks();\n        }\n        finally {\n            release();\n        }\n    }\n    async interleaveChunks(isFinalCall = false) {\n        if (!isFinalCall && !this.allTracksAreKnown()) {\n            return; // We can't interleave yet as we don't yet know how many tracks we'll truly have\n        }\n        outer: while (true) {\n            let trackWithMinTimestamp = null;\n            let minTimestamp = Infinity;\n            for (const trackData of this.trackDatas) {\n                if (!isFinalCall && trackData.chunkQueue.length === 0 && !trackData.track.source._closed) {\n                    break outer;\n                }\n                if (trackData.chunkQueue.length > 0 && trackData.chunkQueue[0].timestamp < minTimestamp) {\n                    trackWithMinTimestamp = trackData;\n                    minTimestamp = trackData.chunkQueue[0].timestamp;\n                }\n            }\n            if (!trackWithMinTimestamp) {\n                break;\n            }\n            const chunk = trackWithMinTimestamp.chunkQueue.shift();\n            this.writeBlock(trackWithMinTimestamp, chunk);\n        }\n        if (!isFinalCall) {\n            await this.writer.flush();\n        }\n    }\n    /**\n     * Due to [a bug in Chromium](https://bugs.chromium.org/p/chromium/issues/detail?id=1377842), VP9 streams often\n     * lack color space information. This method patches in that information.\n     */\n    fixVP9ColorSpace(trackData, chunk) {\n        // http://downloads.webmproject.org/docs/vp9/vp9-bitstream_superframe-and-uncompressed-header_v1.0.pdf\n        if (chunk.type !== 'key')\n            return;\n        if (!trackData.info.decoderConfig.colorSpace || !trackData.info.decoderConfig.colorSpace.matrix)\n            return;\n        const bitstream = new Bitstream(chunk.data);\n        bitstream.skipBits(2);\n        const profileLowBit = bitstream.readBits(1);\n        const profileHighBit = bitstream.readBits(1);\n        const profile = (profileHighBit << 1) + profileLowBit;\n        if (profile === 3)\n            bitstream.skipBits(1);\n        const showExistingFrame = bitstream.readBits(1);\n        if (showExistingFrame)\n            return;\n        const frameType = bitstream.readBits(1);\n        if (frameType !== 0)\n            return; // Just to be sure\n        bitstream.skipBits(2);\n        const syncCode = bitstream.readBits(24);\n        if (syncCode !== 0x498342)\n            return;\n        if (profile >= 2)\n            bitstream.skipBits(1);\n        const colorSpaceID = {\n            rgb: 7,\n            bt709: 2,\n            bt470bg: 1,\n            smpte170m: 3,\n        }[trackData.info.decoderConfig.colorSpace.matrix];\n        // The bitstream position is now at the start of the color space bits.\n        // We can use the global writeBits function here as requested.\n        writeBits(chunk.data, bitstream.pos, bitstream.pos + 3, colorSpaceID);\n    }\n    /** Converts a read-only external chunk into an internal one for easier use. */\n    createInternalChunk(data, timestamp, duration, type, additions = null) {\n        const internalChunk = {\n            data,\n            type,\n            timestamp,\n            duration,\n            additions,\n        };\n        return internalChunk;\n    }\n    /** Writes a block containing media data to the file. */\n    writeBlock(trackData, chunk) {\n        // Due to the interlacing algorithm, this code will be run once we've seen one chunk from every media track.\n        if (!this.segment) {\n            this.createSegment();\n        }\n        const msTimestamp = Math.round(1000 * chunk.timestamp);\n        // We wanna only finalize this cluster (and begin a new one) if we know that each track will be able to\n        // start the new one with a key frame.\n        const keyFrameQueuedEverywhere = this.trackDatas.every((otherTrackData) => {\n            if (trackData === otherTrackData) {\n                return chunk.type === 'key';\n            }\n            const firstQueuedSample = otherTrackData.chunkQueue[0];\n            if (firstQueuedSample) {\n                return firstQueuedSample.type === 'key';\n            }\n            return otherTrackData.track.source._closed;\n        });\n        let shouldCreateNewCluster = false;\n        if (!this.currentCluster) {\n            shouldCreateNewCluster = true;\n        }\n        else {\n            assert(this.currentClusterStartMsTimestamp !== null);\n            assert(this.currentClusterMaxMsTimestamp !== null);\n            const relativeTimestamp = msTimestamp - this.currentClusterStartMsTimestamp;\n            shouldCreateNewCluster = (keyFrameQueuedEverywhere\n                // This check is required because that means there is already a block with this timestamp in the\n                // CURRENT chunk, meaning that starting the next cluster at the same timestamp is forbidden (since\n                // the already-written block would belong into it instead).\n                && msTimestamp > this.currentClusterMaxMsTimestamp\n                && relativeTimestamp >= 1000 * (this.format._options.minimumClusterDuration ?? 1))\n                // The cluster would exceed its maximum allowed length. This puts us in an unfortunate position and forces\n                // us to begin the next cluster with a delta frame. Although this is undesirable, it is not forbidden by the\n                // spec and is supported by players.\n                || relativeTimestamp > MAX_CLUSTER_TIMESTAMP_MS;\n        }\n        if (shouldCreateNewCluster) {\n            this.createNewCluster(msTimestamp);\n        }\n        const relativeTimestamp = msTimestamp - this.currentClusterStartMsTimestamp;\n        if (relativeTimestamp < MIN_CLUSTER_TIMESTAMP_MS) {\n            // The block lies too far in the past, it's not representable within this cluster\n            return;\n        }\n        const prelude = new Uint8Array(4);\n        const view = new DataView(prelude.buffer);\n        // 0x80 to indicate it's the last byte of a multi-byte number\n        view.setUint8(0, 0x80 | trackData.track.id);\n        view.setInt16(1, relativeTimestamp, false);\n        const msDuration = Math.round(1000 * chunk.duration);\n        if (!chunk.additions) {\n            // No additions, we can write out a SimpleBlock\n            view.setUint8(3, Number(chunk.type === 'key') << 7); // Flags (keyframe flag only present for SimpleBlock)\n            const simpleBlock = { id: EBMLId.SimpleBlock, data: [\n                    prelude,\n                    chunk.data,\n                ] };\n            this.ebmlWriter.writeEBML(simpleBlock);\n        }\n        else {\n            const blockGroup = { id: EBMLId.BlockGroup, data: [\n                    { id: EBMLId.Block, data: [\n                            prelude,\n                            chunk.data,\n                        ] },\n                    chunk.type === 'delta'\n                        ? {\n                            id: EBMLId.ReferenceBlock,\n                            data: new EBMLSignedInt(trackData.lastWrittenMsTimestamp - msTimestamp),\n                        }\n                        : null,\n                    chunk.additions\n                        ? { id: EBMLId.BlockAdditions, data: [\n                                { id: EBMLId.BlockMore, data: [\n                                        { id: EBMLId.BlockAddID, data: 1 }, // Some players expect BlockAddID to come first\n                                        { id: EBMLId.BlockAdditional, data: chunk.additions },\n                                    ] },\n                            ] }\n                        : null,\n                    msDuration > 0 ? { id: EBMLId.BlockDuration, data: msDuration } : null,\n                ] };\n            this.ebmlWriter.writeEBML(blockGroup);\n        }\n        this.duration = Math.max(this.duration, msTimestamp + msDuration);\n        trackData.lastWrittenMsTimestamp = msTimestamp;\n        if (!this.trackDatasInCurrentCluster.has(trackData)) {\n            this.trackDatasInCurrentCluster.set(trackData, {\n                firstMsTimestamp: msTimestamp,\n            });\n        }\n        this.currentClusterMaxMsTimestamp = Math.max(this.currentClusterMaxMsTimestamp, msTimestamp);\n    }\n    /** Creates a new Cluster element to contain media chunks. */\n    createNewCluster(msTimestamp) {\n        if (this.currentCluster) {\n            this.finalizeCurrentCluster();\n        }\n        if (this.format._options.onCluster) {\n            this.writer.startTrackingWrites();\n        }\n        this.currentCluster = {\n            id: EBMLId.Cluster,\n            size: this.format._options.appendOnly ? -1 : CLUSTER_SIZE_BYTES,\n            data: [\n                { id: EBMLId.Timestamp, data: msTimestamp },\n            ],\n        };\n        this.ebmlWriter.writeEBML(this.currentCluster);\n        this.currentClusterStartMsTimestamp = msTimestamp;\n        this.currentClusterMaxMsTimestamp = msTimestamp;\n        this.trackDatasInCurrentCluster.clear();\n    }\n    finalizeCurrentCluster() {\n        assert(this.currentCluster);\n        if (!this.format._options.appendOnly) {\n            const clusterSize = this.writer.getPos() - this.ebmlWriter.dataOffsets.get(this.currentCluster);\n            const endPos = this.writer.getPos();\n            // Write the size now that we know it\n            this.writer.seek(this.ebmlWriter.offsets.get(this.currentCluster) + 4);\n            this.ebmlWriter.writeVarInt(clusterSize, CLUSTER_SIZE_BYTES);\n            this.writer.seek(endPos);\n        }\n        if (this.format._options.onCluster) {\n            assert(this.currentClusterStartMsTimestamp !== null);\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onCluster(data, start, this.currentClusterStartMsTimestamp / 1000);\n        }\n        const clusterOffsetFromSegment = this.ebmlWriter.offsets.get(this.currentCluster) - this.segmentDataOffset;\n        // Group tracks by their first timestamp and create a CuePoint for each unique timestamp\n        const groupedByTimestamp = new Map();\n        for (const [trackData, { firstMsTimestamp }] of this.trackDatasInCurrentCluster) {\n            if (!groupedByTimestamp.has(firstMsTimestamp)) {\n                groupedByTimestamp.set(firstMsTimestamp, []);\n            }\n            groupedByTimestamp.get(firstMsTimestamp).push(trackData);\n        }\n        const groupedAndSortedByTimestamp = [...groupedByTimestamp.entries()].sort((a, b) => a[0] - b[0]);\n        // Add CuePoints to the Cues element for better seeking\n        for (const [msTimestamp, trackDatas] of groupedAndSortedByTimestamp) {\n            assert(this.cues);\n            this.cues.data.push({ id: EBMLId.CuePoint, data: [\n                    { id: EBMLId.CueTime, data: msTimestamp },\n                    // Create CueTrackPositions for each track that starts at this timestamp\n                    ...trackDatas.map((trackData) => {\n                        return { id: EBMLId.CueTrackPositions, data: [\n                                { id: EBMLId.CueTrack, data: trackData.track.id },\n                                { id: EBMLId.CueClusterPosition, data: clusterOffsetFromSegment },\n                            ] };\n                    }),\n                ] });\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    async onTrackClose() {\n        const release = await this.mutex.acquire();\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        // Since a track is now closed, we may be able to write out chunks that were previously waiting\n        await this.interleaveChunks();\n        release();\n    }\n    /** Finalizes the file, making it ready for use. Must be called after all media chunks have been added. */\n    async finalize() {\n        const release = await this.mutex.acquire();\n        this.allTracksKnown.resolve();\n        if (!this.segment) {\n            this.createSegment();\n        }\n        // Flush any remaining queued chunks to the file\n        await this.interleaveChunks(true);\n        if (this.currentCluster) {\n            this.finalizeCurrentCluster();\n        }\n        assert(this.cues);\n        this.ebmlWriter.writeEBML(this.cues);\n        if (!this.format._options.appendOnly) {\n            const endPos = this.writer.getPos();\n            // Write the Segment size\n            const segmentSize = this.writer.getPos() - this.segmentDataOffset;\n            this.writer.seek(this.ebmlWriter.offsets.get(this.segment) + 4);\n            this.ebmlWriter.writeVarInt(segmentSize, SEGMENT_SIZE_BYTES);\n            // Write the duration of the media to the Segment\n            this.segmentDuration.data = new EBMLFloat64(this.duration);\n            this.writer.seek(this.ebmlWriter.offsets.get(this.segmentDuration));\n            this.ebmlWriter.writeEBML(this.segmentDuration);\n            // Fill in SeekHead position data and write it again\n            assert(this.seekHead);\n            this.writer.seek(this.ebmlWriter.offsets.get(this.seekHead));\n            this.maybeCreateSeekHead(true);\n            this.ebmlWriter.writeEBML(this.seekHead);\n            this.writer.seek(endPos);\n        }\n        release();\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { computeMp3FrameSize, getXingOffset, KILOBIT_RATES, XING, } from '../../shared/mp3-misc.js';\nexport class Mp3Writer {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n    }\n    writeU32(value) {\n        this.helperView.setUint32(0, value, false);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeXingFrame(data) {\n        const startPos = this.writer.getPos();\n        const firstByte = 0xff;\n        const secondByte = 0xe0 | (data.mpegVersionId << 3) | (data.layer << 1);\n        let lowSamplingFrequency;\n        if (data.mpegVersionId & 2) {\n            lowSamplingFrequency = (data.mpegVersionId & 1) ? 0 : 1;\n        }\n        else {\n            lowSamplingFrequency = 1;\n        }\n        const padding = 0;\n        const neededBytes = 155;\n        let bitrateIndex = -1;\n        const bitrateOffset = lowSamplingFrequency * 16 * 4 + data.layer * 16;\n        // Let's find the lowest bitrate for which the frame size is sufficiently large to fit all the data\n        for (let i = 0; i < 16; i++) {\n            const kbr = KILOBIT_RATES[bitrateOffset + i];\n            const size = computeMp3FrameSize(lowSamplingFrequency, data.layer, 1000 * kbr, data.sampleRate, padding);\n            if (size >= neededBytes) {\n                bitrateIndex = i;\n                break;\n            }\n        }\n        if (bitrateIndex === -1) {\n            throw new Error('No suitable bitrate found.');\n        }\n        const thirdByte = (bitrateIndex << 4) | (data.frequencyIndex << 2) | padding << 1;\n        const fourthByte = (data.channel << 6)\n            | (data.modeExtension << 4)\n            | (data.copyright << 3)\n            | (data.original << 2)\n            | data.emphasis;\n        this.helper[0] = firstByte;\n        this.helper[1] = secondByte;\n        this.helper[2] = thirdByte;\n        this.helper[3] = fourthByte;\n        this.writer.write(this.helper.subarray(0, 4));\n        const xingOffset = getXingOffset(data.mpegVersionId, data.channel);\n        this.writer.seek(startPos + xingOffset);\n        this.writeU32(XING);\n        let flags = 0;\n        if (data.frameCount !== null) {\n            flags |= 1;\n        }\n        if (data.fileSize !== null) {\n            flags |= 2;\n        }\n        if (data.toc !== null) {\n            flags |= 4;\n        }\n        this.writeU32(flags);\n        this.writeU32(data.frameCount ?? 0);\n        this.writeU32(data.fileSize ?? 0);\n        this.writer.write(data.toc ?? new Uint8Array(100));\n        const kilobitRate = KILOBIT_RATES[bitrateOffset + bitrateIndex];\n        const frameSize = computeMp3FrameSize(lowSamplingFrequency, data.layer, 1000 * kilobitRate, data.sampleRate, padding);\n        this.writer.seek(startPos + frameSize);\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert, toDataView } from '../misc.js';\nimport { metadataTagsAreEmpty } from '../metadata.js';\nimport { Muxer } from '../muxer.js';\nimport { getXingOffset, INFO, readFrameHeader, XING } from '../../shared/mp3-misc.js';\nimport { Mp3Writer } from './mp3-writer.js';\nimport { Id3V2Writer } from '../id3.js';\nexport class Mp3Muxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.xingFrameData = null;\n        this.frameCount = 0;\n        this.framePositions = [];\n        this.xingFramePos = null;\n        this.format = format;\n        this.writer = output._writer;\n        this.mp3Writer = new Mp3Writer(output._writer);\n    }\n    async start() {\n        if (!metadataTagsAreEmpty(this.output._metadataTags)) {\n            const id3Writer = new Id3V2Writer(this.writer);\n            id3Writer.writeId3V2Tag(this.output._metadataTags);\n        }\n    }\n    async getMimeType() {\n        return 'audio/mpeg';\n    }\n    async addEncodedVideoPacket() {\n        throw new Error('MP3 does not support video.');\n    }\n    async addEncodedAudioPacket(track, packet) {\n        const release = await this.mutex.acquire();\n        try {\n            const writeXingHeader = this.format._options.xingHeader !== false;\n            if (!this.xingFrameData && writeXingHeader) {\n                const view = toDataView(packet.data);\n                if (view.byteLength < 4) {\n                    throw new Error('Invalid MP3 header in sample.');\n                }\n                const word = view.getUint32(0, false);\n                const header = readFrameHeader(word, null).header;\n                if (!header) {\n                    throw new Error('Invalid MP3 header in sample.');\n                }\n                const xingOffset = getXingOffset(header.mpegVersionId, header.channel);\n                if (view.byteLength >= xingOffset + 4) {\n                    const word = view.getUint32(xingOffset, false);\n                    const isXing = word === XING || word === INFO;\n                    if (isXing) {\n                        // This is not a data frame, so let's completely ignore this sample\n                        return;\n                    }\n                }\n                this.xingFrameData = {\n                    mpegVersionId: header.mpegVersionId,\n                    layer: header.layer,\n                    frequencyIndex: header.frequencyIndex,\n                    sampleRate: header.sampleRate,\n                    channel: header.channel,\n                    modeExtension: header.modeExtension,\n                    copyright: header.copyright,\n                    original: header.original,\n                    emphasis: header.emphasis,\n                    frameCount: null,\n                    fileSize: null,\n                    toc: null,\n                };\n                // Write a Xing frame because this muxer doesn't make any bitrate constraints, meaning we don't know if\n                // this will be a constant or variable bitrate file. Therefore, always write the Xing frame.\n                this.xingFramePos = this.writer.getPos();\n                this.mp3Writer.writeXingFrame(this.xingFrameData);\n                this.frameCount++;\n            }\n            this.validateAndNormalizeTimestamp(track, packet.timestamp, packet.type === 'key');\n            this.writer.write(packet.data);\n            this.frameCount++;\n            await this.writer.flush();\n            if (writeXingHeader) {\n                this.framePositions.push(this.writer.getPos());\n            }\n        }\n        finally {\n            release();\n        }\n    }\n    async addSubtitleCue() {\n        throw new Error('MP3 does not support subtitles.');\n    }\n    async finalize() {\n        if (!this.xingFrameData || this.xingFramePos === null) {\n            return;\n        }\n        const release = await this.mutex.acquire();\n        const endPos = this.writer.getPos();\n        this.writer.seek(this.xingFramePos);\n        const toc = new Uint8Array(100);\n        for (let i = 0; i < 100; i++) {\n            const index = Math.floor(this.framePositions.length * (i / 100));\n            assert(index !== -1 && index < this.framePositions.length);\n            const byteOffset = this.framePositions[index];\n            toc[i] = 256 * (byteOffset / endPos);\n        }\n        this.xingFrameData.frameCount = this.frameCount;\n        this.xingFrameData.fileSize = endPos;\n        this.xingFrameData.toc = toc;\n        if (this.format._options.onXingFrame) {\n            this.writer.startTrackingWrites();\n        }\n        this.mp3Writer.writeXingFrame(this.xingFrameData);\n        if (this.format._options.onXingFrame) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onXingFrame(data, start);\n        }\n        this.writer.seek(endPos);\n        release();\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { OPUS_SAMPLE_RATE, validateAudioChunkMetadata } from '../codec.js';\nimport { createVorbisComments, parseModesFromVorbisSetupPacket, parseOpusIdentificationHeader } from '../codec-data.js';\nimport { assert, promiseWithResolvers, setInt64, toDataView, toUint8Array, } from '../misc.js';\nimport { Muxer } from '../muxer.js';\nimport { buildOggMimeType, computeOggPageCrc, extractSampleMetadata, OGGS, } from './ogg-misc.js';\nimport { MAX_PAGE_SIZE } from './ogg-reader.js';\nconst PAGE_SIZE_TARGET = 8192;\nexport class OggMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.trackDatas = [];\n        this.bosPagesWritten = false;\n        this.allTracksKnown = promiseWithResolvers();\n        this.pageBytes = new Uint8Array(MAX_PAGE_SIZE);\n        this.pageView = new DataView(this.pageBytes.buffer);\n        this.format = format;\n        this.writer = output._writer;\n        this.writer.ensureMonotonicity = true; // Ogg is always monotonically written!\n    }\n    async start() {\n        // Nothin'\n    }\n    async getMimeType() {\n        await this.allTracksKnown.promise;\n        return buildOggMimeType({\n            codecStrings: this.trackDatas.map(x => x.codecInfo.codec),\n        });\n    }\n    addEncodedVideoPacket() {\n        throw new Error('Video tracks are not supported.');\n    }\n    getTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(td => td.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        // Give the track a unique random serial number\n        let serialNumber;\n        do {\n            serialNumber = Math.floor(2 ** 32 * Math.random());\n        } while (this.trackDatas.some(td => td.serialNumber === serialNumber));\n        assert(track.source._codec === 'vorbis' || track.source._codec === 'opus');\n        validateAudioChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const newTrackData = {\n            track,\n            serialNumber,\n            internalSampleRate: track.source._codec === 'opus'\n                ? OPUS_SAMPLE_RATE\n                : meta.decoderConfig.sampleRate,\n            codecInfo: {\n                codec: track.source._codec,\n                vorbisInfo: null,\n                opusInfo: null,\n            },\n            vorbisLastBlocksize: null,\n            packetQueue: [],\n            currentTimestampInSamples: 0,\n            pagesWritten: 0,\n            currentGranulePosition: 0,\n            currentLacingValues: [],\n            currentPageData: [],\n            currentPageSize: 27,\n            currentPageStartsWithFreshPacket: true,\n        };\n        this.queueHeaderPackets(newTrackData, meta);\n        this.trackDatas.push(newTrackData);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    queueHeaderPackets(trackData, meta) {\n        assert(meta.decoderConfig);\n        if (trackData.track.source._codec === 'vorbis') {\n            assert(meta.decoderConfig.description);\n            const bytes = toUint8Array(meta.decoderConfig.description);\n            if (bytes[0] !== 2) {\n                throw new TypeError('First byte of Vorbis decoder description must be 2.');\n            }\n            let pos = 1;\n            const readPacketLength = () => {\n                let length = 0;\n                while (true) {\n                    const value = bytes[pos++];\n                    if (value === undefined) {\n                        throw new TypeError('Vorbis decoder description is too short.');\n                    }\n                    length += value;\n                    if (value < 255) {\n                        return length;\n                    }\n                }\n            };\n            const identificationHeaderLength = readPacketLength();\n            const commentHeaderLength = readPacketLength();\n            const setupHeaderLength = bytes.length - pos; // Setup header fills the remaining bytes\n            if (setupHeaderLength <= 0) {\n                throw new TypeError('Vorbis decoder description is too short.');\n            }\n            const identificationHeader = bytes.subarray(pos, pos += identificationHeaderLength);\n            pos += commentHeaderLength; // Skip the comment header, we'll build our own\n            const setupHeader = bytes.subarray(pos);\n            const commentHeaderHeader = new Uint8Array(7);\n            commentHeaderHeader[0] = 3; // Packet type\n            commentHeaderHeader[1] = 0x76; // 'v'\n            commentHeaderHeader[2] = 0x6f; // 'o'\n            commentHeaderHeader[3] = 0x72; // 'r'\n            commentHeaderHeader[4] = 0x62; // 'b'\n            commentHeaderHeader[5] = 0x69; // 'i'\n            commentHeaderHeader[6] = 0x73; // 's'\n            const commentHeader = createVorbisComments(commentHeaderHeader, this.output._metadataTags, true);\n            trackData.packetQueue.push({\n                data: identificationHeader,\n                endGranulePosition: 0,\n                timestamp: 0,\n                forcePageFlush: true,\n            }, {\n                data: commentHeader,\n                endGranulePosition: 0,\n                timestamp: 0,\n                forcePageFlush: false,\n            }, {\n                data: setupHeader,\n                endGranulePosition: 0,\n                timestamp: 0,\n                forcePageFlush: true, // The last header packet must flush the page\n            });\n            const view = toDataView(identificationHeader);\n            const blockSizeByte = view.getUint8(28);\n            trackData.codecInfo.vorbisInfo = {\n                blocksizes: [\n                    1 << (blockSizeByte & 0xf),\n                    1 << (blockSizeByte >> 4),\n                ],\n                modeBlockflags: parseModesFromVorbisSetupPacket(setupHeader).modeBlockflags,\n            };\n        }\n        else if (trackData.track.source._codec === 'opus') {\n            if (!meta.decoderConfig.description) {\n                throw new TypeError('For Ogg, Opus decoder description is required.');\n            }\n            const identificationHeader = toUint8Array(meta.decoderConfig.description);\n            const commentHeaderHeader = new Uint8Array(8);\n            const commentHeaderHeaderView = toDataView(commentHeaderHeader);\n            commentHeaderHeaderView.setUint32(0, 0x4f707573, false); // 'Opus'\n            commentHeaderHeaderView.setUint32(4, 0x54616773, false); // 'Tags'\n            const commentHeader = createVorbisComments(commentHeaderHeader, this.output._metadataTags, true);\n            trackData.packetQueue.push({\n                data: identificationHeader,\n                endGranulePosition: 0,\n                timestamp: 0,\n                forcePageFlush: true,\n            }, {\n                data: commentHeader,\n                endGranulePosition: 0,\n                timestamp: 0,\n                forcePageFlush: true, // The last header packet must flush the page\n            });\n            trackData.codecInfo.opusInfo = {\n                preSkip: parseOpusIdentificationHeader(identificationHeader).preSkip,\n            };\n        }\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getTrackData(track, meta);\n            this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');\n            const currentTimestampInSamples = trackData.currentTimestampInSamples;\n            const { durationInSamples, vorbisBlockSize } = extractSampleMetadata(packet.data, trackData.codecInfo, trackData.vorbisLastBlocksize);\n            trackData.currentTimestampInSamples += durationInSamples;\n            trackData.vorbisLastBlocksize = vorbisBlockSize;\n            trackData.packetQueue.push({\n                data: packet.data,\n                endGranulePosition: trackData.currentTimestampInSamples,\n                timestamp: currentTimestampInSamples / trackData.internalSampleRate,\n                forcePageFlush: false,\n            });\n            await this.interleavePages();\n        }\n        finally {\n            release();\n        }\n    }\n    addSubtitleCue() {\n        throw new Error('Subtitle tracks are not supported.');\n    }\n    allTracksAreKnown() {\n        for (const track of this.output._tracks) {\n            if (!track.source._closed && !this.trackDatas.some(x => x.track === track)) {\n                return false; // We haven't seen a sample from this open track yet\n            }\n        }\n        return true;\n    }\n    async interleavePages(isFinalCall = false) {\n        if (!this.bosPagesWritten) {\n            if (!this.allTracksAreKnown()) {\n                return; // We can't interleave yet as we don't yet know how many tracks we'll truly have\n            }\n            // Write the header page for all bitstreams\n            for (const trackData of this.trackDatas) {\n                while (trackData.packetQueue.length > 0) {\n                    const packet = trackData.packetQueue.shift();\n                    this.writePacket(trackData, packet, false);\n                    if (packet.forcePageFlush) {\n                        // We say the header page ends once the first packet is encountered that forces a page flush\n                        break;\n                    }\n                }\n            }\n            this.bosPagesWritten = true;\n        }\n        outer: while (true) {\n            let trackWithMinTimestamp = null;\n            let minTimestamp = Infinity;\n            for (const trackData of this.trackDatas) {\n                if (!isFinalCall\n                    && trackData.packetQueue.length <= 1 // Limit is 1, not 0, for correct EOS flag logic\n                    && !trackData.track.source._closed) {\n                    break outer;\n                }\n                if (trackData.packetQueue.length > 0\n                    && trackData.packetQueue[0].timestamp < minTimestamp) {\n                    trackWithMinTimestamp = trackData;\n                    minTimestamp = trackData.packetQueue[0].timestamp;\n                }\n            }\n            if (!trackWithMinTimestamp) {\n                break;\n            }\n            const packet = trackWithMinTimestamp.packetQueue.shift();\n            const isFinalPacket = trackWithMinTimestamp.packetQueue.length === 0;\n            this.writePacket(trackWithMinTimestamp, packet, isFinalPacket);\n        }\n        if (!isFinalCall) {\n            await this.writer.flush();\n        }\n    }\n    writePacket(trackData, packet, isFinalPacket) {\n        let remainingLength = packet.data.length;\n        let dataStartOffset = 0;\n        let dataOffset = 0;\n        while (true) {\n            if (trackData.currentLacingValues.length === 0 && dataStartOffset > 0) {\n                // This is a packet spanning multiple pages\n                trackData.currentPageStartsWithFreshPacket = false;\n            }\n            const segmentSize = Math.min(255, remainingLength);\n            trackData.currentLacingValues.push(segmentSize);\n            trackData.currentPageSize++;\n            dataOffset += segmentSize;\n            const segmentIsLastOfPacket = remainingLength < 255;\n            if (trackData.currentLacingValues.length === 255) {\n                // The page is full, we need to add part of the packet data and then flush the page\n                const slice = packet.data.subarray(dataStartOffset, dataOffset);\n                dataStartOffset = dataOffset;\n                trackData.currentPageData.push(slice);\n                trackData.currentPageSize += slice.length;\n                this.writePage(trackData, isFinalPacket && segmentIsLastOfPacket);\n                if (segmentIsLastOfPacket) {\n                    return;\n                }\n            }\n            if (segmentIsLastOfPacket) {\n                break;\n            }\n            remainingLength -= 255;\n        }\n        const slice = packet.data.subarray(dataStartOffset);\n        trackData.currentPageData.push(slice);\n        trackData.currentPageSize += slice.length;\n        trackData.currentGranulePosition = packet.endGranulePosition;\n        if (trackData.currentPageSize >= PAGE_SIZE_TARGET || packet.forcePageFlush) {\n            this.writePage(trackData, isFinalPacket);\n        }\n    }\n    writePage(trackData, isEos) {\n        this.pageView.setUint32(0, OGGS, true); // Capture pattern\n        this.pageView.setUint8(4, 0); // Version\n        let headerType = 0;\n        if (!trackData.currentPageStartsWithFreshPacket) {\n            headerType |= 1;\n        }\n        if (trackData.pagesWritten === 0) {\n            headerType |= 2; // Beginning of stream\n        }\n        if (isEos) {\n            headerType |= 4; // End of stream\n        }\n        this.pageView.setUint8(5, headerType); // Header type\n        const granulePosition = trackData.currentLacingValues.every(x => x === 255)\n            ? -1 // No packets end on this page\n            : trackData.currentGranulePosition;\n        setInt64(this.pageView, 6, granulePosition, true); // Granule position\n        this.pageView.setUint32(14, trackData.serialNumber, true); // Serial number\n        this.pageView.setUint32(18, trackData.pagesWritten, true); // Page sequence number\n        this.pageView.setUint32(22, 0, true); // Checksum placeholder\n        this.pageView.setUint8(26, trackData.currentLacingValues.length); // Number of page segments\n        this.pageBytes.set(trackData.currentLacingValues, 27);\n        let pos = 27 + trackData.currentLacingValues.length;\n        for (const data of trackData.currentPageData) {\n            this.pageBytes.set(data, pos);\n            pos += data.length;\n        }\n        const slice = this.pageBytes.subarray(0, pos);\n        const crc = computeOggPageCrc(slice);\n        this.pageView.setUint32(22, crc, true); // Checksum\n        trackData.pagesWritten++;\n        trackData.currentLacingValues.length = 0;\n        trackData.currentPageData.length = 0;\n        trackData.currentPageSize = 27;\n        trackData.currentPageStartsWithFreshPacket = true;\n        if (this.format._options.onPage) {\n            this.writer.startTrackingWrites();\n        }\n        this.writer.write(slice);\n        if (this.format._options.onPage) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onPage(data, start, trackData.track.source);\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    async onTrackClose() {\n        const release = await this.mutex.acquire();\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        // Since a track is now closed, we may be able to write out chunks that were previously waiting\n        await this.interleavePages();\n        release();\n    }\n    async finalize() {\n        const release = await this.mutex.acquire();\n        this.allTracksKnown.resolve();\n        await this.interleavePages(true);\n        for (const trackData of this.trackDatas) {\n            if (trackData.currentLacingValues.length > 0) {\n                this.writePage(trackData, true);\n            }\n        }\n        release();\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport class RiffWriter {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n    }\n    writeU16(value) {\n        this.helperView.setUint16(0, value, true);\n        this.writer.write(this.helper.subarray(0, 2));\n    }\n    writeU32(value) {\n        this.helperView.setUint32(0, value, true);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeU64(value) {\n        this.helperView.setUint32(0, value, true);\n        this.helperView.setUint32(4, Math.floor(value / 2 ** 32), true);\n        this.writer.write(this.helper);\n    }\n    writeAscii(text) {\n        this.writer.write(new TextEncoder().encode(text));\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Muxer } from '../muxer.js';\nimport { parsePcmCodec, validateAudioChunkMetadata } from '../codec.js';\nimport { WaveFormat } from './wave-demuxer.js';\nimport { RiffWriter } from './riff-writer.js';\nimport { assert, assertNever, isIso88591Compatible, keyValueIterator } from '../misc.js';\nimport { metadataTagsAreEmpty } from '../metadata.js';\nimport { Id3V2Writer } from '../id3.js';\nexport class WaveMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.headerWritten = false;\n        this.dataSize = 0;\n        this.sampleRate = null;\n        this.sampleCount = 0;\n        this.riffSizePos = null;\n        this.dataSizePos = null;\n        this.ds64RiffSizePos = null;\n        this.ds64DataSizePos = null;\n        this.ds64SampleCountPos = null;\n        this.format = format;\n        this.writer = output._writer;\n        this.riffWriter = new RiffWriter(output._writer);\n        this.isRf64 = !!format._options.large;\n    }\n    async start() {\n        // Nothing needed here - we'll write the header with the first sample\n    }\n    async getMimeType() {\n        return 'audio/wav';\n    }\n    async addEncodedVideoPacket() {\n        throw new Error('WAVE does not support video.');\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            if (!this.headerWritten) {\n                validateAudioChunkMetadata(meta);\n                assert(meta);\n                assert(meta.decoderConfig);\n                this.writeHeader(track, meta.decoderConfig);\n                this.sampleRate = meta.decoderConfig.sampleRate;\n                this.headerWritten = true;\n            }\n            this.validateAndNormalizeTimestamp(track, packet.timestamp, packet.type === 'key');\n            if (!this.isRf64 && this.writer.getPos() + packet.data.byteLength >= 2 ** 32) {\n                throw new Error('Adding more audio data would exceed the maximum RIFF size of 4 GiB. To write larger files, use'\n                    + ' RF64 by setting `large: true` in the WavOutputFormatOptions.');\n            }\n            this.writer.write(packet.data);\n            this.dataSize += packet.data.byteLength;\n            this.sampleCount += Math.round(packet.duration * this.sampleRate);\n            await this.writer.flush();\n        }\n        finally {\n            release();\n        }\n    }\n    async addSubtitleCue() {\n        throw new Error('WAVE does not support subtitles.');\n    }\n    writeHeader(track, config) {\n        if (this.format._options.onHeader) {\n            this.writer.startTrackingWrites();\n        }\n        let format;\n        const codec = track.source._codec;\n        const pcmInfo = parsePcmCodec(codec);\n        if (pcmInfo.dataType === 'ulaw') {\n            format = WaveFormat.MULAW;\n        }\n        else if (pcmInfo.dataType === 'alaw') {\n            format = WaveFormat.ALAW;\n        }\n        else if (pcmInfo.dataType === 'float') {\n            format = WaveFormat.IEEE_FLOAT;\n        }\n        else {\n            format = WaveFormat.PCM;\n        }\n        const channels = config.numberOfChannels;\n        const sampleRate = config.sampleRate;\n        const blockSize = pcmInfo.sampleSize * channels;\n        // RIFF header\n        this.riffWriter.writeAscii(this.isRf64 ? 'RF64' : 'RIFF');\n        if (this.isRf64) {\n            this.riffWriter.writeU32(0xffffffff); // Not used in RF64\n        }\n        else {\n            this.riffSizePos = this.writer.getPos();\n            this.riffWriter.writeU32(0); // File size placeholder\n        }\n        this.riffWriter.writeAscii('WAVE');\n        if (this.isRf64) {\n            this.riffWriter.writeAscii('ds64');\n            this.riffWriter.writeU32(28); // Chunk size\n            this.ds64RiffSizePos = this.writer.getPos();\n            this.riffWriter.writeU64(0); // RIFF size placeholder\n            this.ds64DataSizePos = this.writer.getPos();\n            this.riffWriter.writeU64(0); // Data size placeholder\n            this.ds64SampleCountPos = this.writer.getPos();\n            this.riffWriter.writeU64(0); // Sample count placeholder\n            this.riffWriter.writeU32(0); // Table length\n            // Empty table\n        }\n        // fmt chunk\n        this.riffWriter.writeAscii('fmt ');\n        this.riffWriter.writeU32(16); // Chunk size\n        this.riffWriter.writeU16(format);\n        this.riffWriter.writeU16(channels);\n        this.riffWriter.writeU32(sampleRate);\n        this.riffWriter.writeU32(sampleRate * blockSize); // Bytes per second\n        this.riffWriter.writeU16(blockSize);\n        this.riffWriter.writeU16(8 * pcmInfo.sampleSize);\n        // Metadata tags\n        if (!metadataTagsAreEmpty(this.output._metadataTags)) {\n            const metadataFormat = this.format._options.metadataFormat ?? 'info';\n            if (metadataFormat === 'info') {\n                this.writeInfoChunk(this.output._metadataTags);\n            }\n            else if (metadataFormat === 'id3') {\n                this.writeId3Chunk(this.output._metadataTags);\n            }\n            else {\n                assertNever(metadataFormat);\n            }\n        }\n        // data chunk\n        this.riffWriter.writeAscii('data');\n        if (this.isRf64) {\n            this.riffWriter.writeU32(0xffffffff); // Not used in RF64\n        }\n        else {\n            this.dataSizePos = this.writer.getPos();\n            this.riffWriter.writeU32(0); // Data size placeholder\n        }\n        if (this.format._options.onHeader) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onHeader(data, start);\n        }\n    }\n    writeInfoChunk(metadata) {\n        const startPos = this.writer.getPos();\n        this.riffWriter.writeAscii('LIST');\n        this.riffWriter.writeU32(0); // Size placeholder\n        this.riffWriter.writeAscii('INFO');\n        const writtenTags = new Set();\n        const writeInfoTag = (tag, value) => {\n            if (!isIso88591Compatible(value)) {\n                // No Unicode supported here\n                console.warn(`Didn't write tag '${tag}' because '${value}' is not ISO 8859-1-compatible.`);\n                return;\n            }\n            const size = value.length + 1; // +1 for null terminator\n            const bytes = new Uint8Array(size);\n            for (let i = 0; i < value.length; i++) {\n                bytes[i] = value.charCodeAt(i);\n            }\n            this.riffWriter.writeAscii(tag);\n            this.riffWriter.writeU32(size);\n            this.writer.write(bytes);\n            // Add padding byte if size is odd\n            if (size & 1) {\n                this.writer.write(new Uint8Array(1));\n            }\n            writtenTags.add(tag);\n        };\n        for (const { key, value } of keyValueIterator(metadata)) {\n            switch (key) {\n                case 'title':\n                    {\n                        writeInfoTag('INAM', value);\n                        writtenTags.add('INAM');\n                    }\n                    ;\n                    break;\n                case 'artist':\n                    {\n                        writeInfoTag('IART', value);\n                        writtenTags.add('IART');\n                    }\n                    ;\n                    break;\n                case 'album':\n                    {\n                        writeInfoTag('IPRD', value);\n                        writtenTags.add('IPRD');\n                    }\n                    ;\n                    break;\n                case 'trackNumber':\n                    {\n                        const string = metadata.tracksTotal !== undefined\n                            ? `${value}/${metadata.tracksTotal}`\n                            : value.toString();\n                        writeInfoTag('ITRK', string);\n                        writtenTags.add('ITRK');\n                    }\n                    ;\n                    break;\n                case 'genre':\n                    {\n                        writeInfoTag('IGNR', value);\n                        writtenTags.add('IGNR');\n                    }\n                    ;\n                    break;\n                case 'date':\n                    {\n                        writeInfoTag('ICRD', value.toISOString().slice(0, 10));\n                        writtenTags.add('ICRD');\n                    }\n                    ;\n                    break;\n                case 'comment':\n                    {\n                        writeInfoTag('ICMT', value);\n                        writtenTags.add('ICMT');\n                    }\n                    ;\n                    break;\n                case 'albumArtist':\n                case 'discNumber':\n                case 'tracksTotal':\n                case 'discsTotal':\n                case 'description':\n                case 'lyrics':\n                case 'images':\n                    {\n                        // Not supported in RIFF INFO\n                    }\n                    ;\n                    break;\n                case 'raw':\n                    {\n                        // Handled later\n                    }\n                    ;\n                    break;\n                default: assertNever(key);\n            }\n        }\n        if (metadata.raw) {\n            for (const key in metadata.raw) {\n                const value = metadata.raw[key];\n                if (value == null || key.length !== 4 || writtenTags.has(key)) {\n                    continue;\n                }\n                if (typeof value === 'string') {\n                    writeInfoTag(key, value);\n                }\n            }\n        }\n        const endPos = this.writer.getPos();\n        const chunkSize = endPos - startPos - 8;\n        this.writer.seek(startPos + 4);\n        this.riffWriter.writeU32(chunkSize);\n        this.writer.seek(endPos);\n        // Add padding byte if chunk size is odd\n        if (chunkSize & 1) {\n            this.writer.write(new Uint8Array(1));\n        }\n    }\n    writeId3Chunk(metadata) {\n        const startPos = this.writer.getPos();\n        // Write RIFF chunk header\n        this.riffWriter.writeAscii('ID3 ');\n        this.riffWriter.writeU32(0); // Size placeholder\n        const id3Writer = new Id3V2Writer(this.writer);\n        const id3TagSize = id3Writer.writeId3V2Tag(metadata);\n        const endPos = this.writer.getPos();\n        // Update RIFF chunk size\n        this.writer.seek(startPos + 4);\n        this.riffWriter.writeU32(id3TagSize);\n        this.writer.seek(endPos);\n        // Add padding byte if chunk size is odd\n        if (id3TagSize & 1) {\n            this.writer.write(new Uint8Array(1));\n        }\n    }\n    async finalize() {\n        const release = await this.mutex.acquire();\n        const endPos = this.writer.getPos();\n        if (this.isRf64) {\n            // Write riff size\n            assert(this.ds64RiffSizePos !== null);\n            this.writer.seek(this.ds64RiffSizePos);\n            this.riffWriter.writeU64(endPos - 8);\n            // Write data size\n            assert(this.ds64DataSizePos !== null);\n            this.writer.seek(this.ds64DataSizePos);\n            this.riffWriter.writeU64(this.dataSize);\n            // Write sample count\n            assert(this.ds64SampleCountPos !== null);\n            this.writer.seek(this.ds64SampleCountPos);\n            this.riffWriter.writeU64(this.sampleCount);\n        }\n        else {\n            // Write file size\n            assert(this.riffSizePos !== null);\n            this.writer.seek(this.riffSizePos);\n            this.riffWriter.writeU32(endPos - 8);\n            // Write data chunk size\n            assert(this.dataSizePos !== null);\n            this.writer.seek(this.dataSizePos);\n            this.riffWriter.writeU32(this.dataSize);\n        }\n        this.writer.seek(endPos);\n        release();\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AdtsMuxer } from './adts/adts-muxer.js';\nimport { AUDIO_CODECS, NON_PCM_AUDIO_CODECS, PCM_AUDIO_CODECS, SUBTITLE_CODECS, VIDEO_CODECS, } from './codec.js';\nimport { FlacMuxer } from './flac/flac-muxer.js';\nimport { IsobmffMuxer } from './isobmff/isobmff-muxer.js';\nimport { MatroskaMuxer } from './matroska/matroska-muxer.js';\nimport { Mp3Muxer } from './mp3/mp3-muxer.js';\nimport { OggMuxer } from './ogg/ogg-muxer.js';\nimport { WaveMuxer } from './wave/wave-muxer.js';\n/**\n * Base class representing an output media file format.\n * @group Output formats\n * @public\n */\nexport class OutputFormat {\n    /** Returns a list of video codecs that this output format can contain. */\n    getSupportedVideoCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => VIDEO_CODECS.includes(codec));\n    }\n    /** Returns a list of audio codecs that this output format can contain. */\n    getSupportedAudioCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => AUDIO_CODECS.includes(codec));\n    }\n    /** Returns a list of subtitle codecs that this output format can contain. */\n    getSupportedSubtitleCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => SUBTITLE_CODECS.includes(codec));\n    }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _codecUnsupportedHint(codec) {\n        return '';\n    }\n}\n/**\n * Format representing files compatible with the ISO base media file format (ISOBMFF), like MP4 or MOV files.\n * @group Output formats\n * @public\n */\nexport class IsobmffOutputFormat extends OutputFormat {\n    /** Internal constructor. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.fastStart !== undefined\n            && ![false, 'in-memory', 'reserve', 'fragmented'].includes(options.fastStart)) {\n            throw new TypeError('options.fastStart, when provided, must be false, \\'in-memory\\', \\'reserve\\', or \\'fragmented\\'.');\n        }\n        if (options.minimumFragmentDuration !== undefined\n            && (!Number.isFinite(options.minimumFragmentDuration) || options.minimumFragmentDuration < 0)) {\n            throw new TypeError('options.minimumFragmentDuration, when provided, must be a non-negative number.');\n        }\n        if (options.onFtyp !== undefined && typeof options.onFtyp !== 'function') {\n            throw new TypeError('options.onFtyp, when provided, must be a function.');\n        }\n        if (options.onMoov !== undefined && typeof options.onMoov !== 'function') {\n            throw new TypeError('options.onMoov, when provided, must be a function.');\n        }\n        if (options.onMdat !== undefined && typeof options.onMdat !== 'function') {\n            throw new TypeError('options.onMdat, when provided, must be a function.');\n        }\n        if (options.onMoof !== undefined && typeof options.onMoof !== 'function') {\n            throw new TypeError('options.onMoof, when provided, must be a function.');\n        }\n        if (options.metadataFormat !== undefined\n            && !['mdir', 'mdta', 'udta', 'auto'].includes(options.metadataFormat)) {\n            throw new TypeError('options.metadataFormat, when provided, must be either \\'auto\\', \\'mdir\\', \\'mdta\\', or \\'udta\\'.');\n        }\n        super();\n        this._options = options;\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: Infinity },\n            audio: { min: 0, max: Infinity },\n            subtitle: { min: 0, max: Infinity },\n            total: { min: 1, max: 2 ** 32 - 1 }, // Have fun reaching this one\n        };\n    }\n    get supportsVideoRotationMetadata() {\n        return true;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new IsobmffMuxer(output, this);\n    }\n}\n/**\n * MPEG-4 Part 14 (MP4) file format. Supports most codecs.\n * @group Output formats\n * @public\n */\nexport class Mp4OutputFormat extends IsobmffOutputFormat {\n    /** Creates a new {@link Mp4OutputFormat} configured with the specified `options`. */\n    constructor(options) {\n        super(options);\n    }\n    /** @internal */\n    get _name() {\n        return 'MP4';\n    }\n    get fileExtension() {\n        return '.mp4';\n    }\n    get mimeType() {\n        return 'video/mp4';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS,\n            ...NON_PCM_AUDIO_CODECS,\n            // These are supported via ISO/IEC 23003-5\n            'pcm-s16',\n            'pcm-s16be',\n            'pcm-s24',\n            'pcm-s24be',\n            'pcm-s32',\n            'pcm-s32be',\n            'pcm-f32',\n            'pcm-f32be',\n            'pcm-f64',\n            'pcm-f64be',\n            ...SUBTITLE_CODECS,\n        ];\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new MovOutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MOV will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * QuickTime File Format (QTFF), often called MOV. Supports all video and audio codecs, but not subtitle codecs.\n * @group Output formats\n * @public\n */\nexport class MovOutputFormat extends IsobmffOutputFormat {\n    /** Creates a new {@link MovOutputFormat} configured with the specified `options`. */\n    constructor(options) {\n        super(options);\n    }\n    /** @internal */\n    get _name() {\n        return 'MOV';\n    }\n    get fileExtension() {\n        return '.mov';\n    }\n    get mimeType() {\n        return 'video/quicktime';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS,\n            ...AUDIO_CODECS,\n        ];\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new Mp4OutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MP4 will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * Matroska file format.\n *\n * Supports writing transparent video. For a video track to be marked as transparent, the first packet added must\n * contain alpha side data.\n *\n * @group Output formats\n * @public\n */\nexport class MkvOutputFormat extends OutputFormat {\n    /** Creates a new {@link MkvOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.appendOnly !== undefined && typeof options.appendOnly !== 'boolean') {\n            throw new TypeError('options.appendOnly, when provided, must be a boolean.');\n        }\n        if (options.minimumClusterDuration !== undefined\n            && (!Number.isFinite(options.minimumClusterDuration) || options.minimumClusterDuration < 0)) {\n            throw new TypeError('options.minimumClusterDuration, when provided, must be a non-negative number.');\n        }\n        if (options.onEbmlHeader !== undefined && typeof options.onEbmlHeader !== 'function') {\n            throw new TypeError('options.onEbmlHeader, when provided, must be a function.');\n        }\n        if (options.onSegmentHeader !== undefined && typeof options.onSegmentHeader !== 'function') {\n            throw new TypeError('options.onHeader, when provided, must be a function.');\n        }\n        if (options.onCluster !== undefined && typeof options.onCluster !== 'function') {\n            throw new TypeError('options.onCluster, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new MatroskaMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'Matroska';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: Infinity },\n            audio: { min: 0, max: Infinity },\n            subtitle: { min: 0, max: Infinity },\n            total: { min: 1, max: 127 },\n        };\n    }\n    get fileExtension() {\n        return '.mkv';\n    }\n    get mimeType() {\n        return 'video/x-matroska';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS,\n            ...NON_PCM_AUDIO_CODECS,\n            ...PCM_AUDIO_CODECS.filter(codec => !['pcm-s8', 'pcm-f32be', 'pcm-f64be', 'ulaw', 'alaw'].includes(codec)),\n            ...SUBTITLE_CODECS,\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        // While it technically does support it with ProjectionPoseRoll, many players appear to ignore this value\n        return false;\n    }\n}\n/**\n * WebM file format, based on Matroska.\n *\n * Supports writing transparent video. For a video track to be marked as transparent, the first packet added must\n * contain alpha side data.\n *\n * @group Output formats\n * @public\n */\nexport class WebMOutputFormat extends MkvOutputFormat {\n    /** Creates a new {@link WebMOutputFormat} configured with the specified `options`. */\n    constructor(options) {\n        super(options);\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS.filter(codec => ['vp8', 'vp9', 'av1'].includes(codec)),\n            ...AUDIO_CODECS.filter(codec => ['opus', 'vorbis'].includes(codec)),\n            ...SUBTITLE_CODECS,\n        ];\n    }\n    /** @internal */\n    get _name() {\n        return 'WebM';\n    }\n    get fileExtension() {\n        return '.webm';\n    }\n    get mimeType() {\n        return 'video/webm';\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new MkvOutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MKV will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * MP3 file format.\n * @group Output formats\n * @public\n */\nexport class Mp3OutputFormat extends OutputFormat {\n    /** Creates a new {@link Mp3OutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.xingHeader !== undefined && typeof options.xingHeader !== 'boolean') {\n            throw new TypeError('options.xingHeader, when provided, must be a boolean.');\n        }\n        if (options.onXingFrame !== undefined && typeof options.onXingFrame !== 'function') {\n            throw new TypeError('options.onXingFrame, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new Mp3Muxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'MP3';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.mp3';\n    }\n    get mimeType() {\n        return 'audio/mpeg';\n    }\n    getSupportedCodecs() {\n        return ['mp3'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * WAVE file format, based on RIFF.\n * @group Output formats\n * @public\n */\nexport class WavOutputFormat extends OutputFormat {\n    /** Creates a new {@link WavOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.large !== undefined && typeof options.large !== 'boolean') {\n            throw new TypeError('options.large, when provided, must be a boolean.');\n        }\n        if (options.metadataFormat !== undefined && !['info', 'id3'].includes(options.metadataFormat)) {\n            throw new TypeError('options.metadataFormat, when provided, must be either \\'info\\' or \\'id3\\'.');\n        }\n        if (options.onHeader !== undefined && typeof options.onHeader !== 'function') {\n            throw new TypeError('options.onHeader, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new WaveMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'WAVE';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.wav';\n    }\n    get mimeType() {\n        return 'audio/wav';\n    }\n    getSupportedCodecs() {\n        return [\n            ...PCM_AUDIO_CODECS.filter(codec => ['pcm-s16', 'pcm-s24', 'pcm-s32', 'pcm-f32', 'pcm-u8', 'ulaw', 'alaw'].includes(codec)),\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * Ogg file format.\n * @group Output formats\n * @public\n */\nexport class OggOutputFormat extends OutputFormat {\n    /** Creates a new {@link OggOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.onPage !== undefined && typeof options.onPage !== 'function') {\n            throw new TypeError('options.onPage, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new OggMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'Ogg';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 0, max: Infinity },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 2 ** 32 },\n        };\n    }\n    get fileExtension() {\n        return '.ogg';\n    }\n    get mimeType() {\n        return 'application/ogg';\n    }\n    getSupportedCodecs() {\n        return [\n            ...AUDIO_CODECS.filter(codec => ['vorbis', 'opus'].includes(codec)),\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * ADTS file format.\n * @group Output formats\n * @public\n */\nexport class AdtsOutputFormat extends OutputFormat {\n    /** Creates a new {@link AdtsOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.onFrame !== undefined && typeof options.onFrame !== 'function') {\n            throw new TypeError('options.onFrame, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new AdtsMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'ADTS';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.aac';\n    }\n    get mimeType() {\n        return 'audio/aac';\n    }\n    getSupportedCodecs() {\n        return ['aac'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * FLAC file format.\n * @group Output formats\n * @public\n */\nexport class FlacOutputFormat extends OutputFormat {\n    /** Creates a new {@link FlacOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new FlacMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'FLAC';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.flac';\n    }\n    get mimeType() {\n        return 'audio/flac';\n    }\n    getSupportedCodecs() {\n        return ['flac'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AUDIO_CODECS, buildAudioCodecString, buildVideoCodecString, getAudioEncoderConfigExtension, getVideoEncoderConfigExtension, inferCodecFromCodecString, PCM_AUDIO_CODECS, SUBTITLE_CODECS, VIDEO_CODECS, } from './codec.js';\nimport { customAudioEncoders, customVideoEncoders } from './custom-coder.js';\nimport { isFirefox } from './misc.js';\nexport const validateVideoEncodingConfig = (config) => {\n    if (!config || typeof config !== 'object') {\n        throw new TypeError('Encoding config must be an object.');\n    }\n    if (!VIDEO_CODECS.includes(config.codec)) {\n        throw new TypeError(`Invalid video codec '${config.codec}'. Must be one of: ${VIDEO_CODECS.join(', ')}.`);\n    }\n    if (!(config.bitrate instanceof Quality) && (!Number.isInteger(config.bitrate) || config.bitrate <= 0)) {\n        throw new TypeError('config.bitrate must be a positive integer or a quality.');\n    }\n    if (config.keyFrameInterval !== undefined\n        && (!Number.isFinite(config.keyFrameInterval) || config.keyFrameInterval < 0)) {\n        throw new TypeError('config.keyFrameInterval, when provided, must be a non-negative number.');\n    }\n    if (config.sizeChangeBehavior !== undefined\n        && !['deny', 'passThrough', 'fill', 'contain', 'cover'].includes(config.sizeChangeBehavior)) {\n        throw new TypeError('config.sizeChangeBehavior, when provided, must be \\'deny\\', \\'passThrough\\', \\'fill\\', \\'contain\\''\n            + ' or \\'cover\\'.');\n    }\n    if (config.onEncodedPacket !== undefined && typeof config.onEncodedPacket !== 'function') {\n        throw new TypeError('config.onEncodedChunk, when provided, must be a function.');\n    }\n    if (config.onEncoderConfig !== undefined && typeof config.onEncoderConfig !== 'function') {\n        throw new TypeError('config.onEncoderConfig, when provided, must be a function.');\n    }\n    validateVideoEncodingAdditionalOptions(config.codec, config);\n};\nexport const validateVideoEncodingAdditionalOptions = (codec, options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('Encoding options must be an object.');\n    }\n    if (options.alpha !== undefined && !['discard', 'keep'].includes(options.alpha)) {\n        throw new TypeError('options.alpha, when provided, must be \\'discard\\' or \\'keep\\'.');\n    }\n    if (options.bitrateMode !== undefined && !['constant', 'variable'].includes(options.bitrateMode)) {\n        throw new TypeError('bitrateMode, when provided, must be \\'constant\\' or \\'variable\\'.');\n    }\n    if (options.latencyMode !== undefined && !['quality', 'realtime'].includes(options.latencyMode)) {\n        throw new TypeError('latencyMode, when provided, must be \\'quality\\' or \\'realtime\\'.');\n    }\n    if (options.fullCodecString !== undefined && typeof options.fullCodecString !== 'string') {\n        throw new TypeError('fullCodecString, when provided, must be a string.');\n    }\n    if (options.fullCodecString !== undefined && inferCodecFromCodecString(options.fullCodecString) !== codec) {\n        throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${codec}).`);\n    }\n    if (options.hardwareAcceleration !== undefined\n        && !['no-preference', 'prefer-hardware', 'prefer-software'].includes(options.hardwareAcceleration)) {\n        throw new TypeError('hardwareAcceleration, when provided, must be \\'no-preference\\', \\'prefer-hardware\\' or'\n            + ' \\'prefer-software\\'.');\n    }\n    if (options.scalabilityMode !== undefined && typeof options.scalabilityMode !== 'string') {\n        throw new TypeError('scalabilityMode, when provided, must be a string.');\n    }\n    if (options.contentHint !== undefined && typeof options.contentHint !== 'string') {\n        throw new TypeError('contentHint, when provided, must be a string.');\n    }\n};\nexport const buildVideoEncoderConfig = (options) => {\n    const resolvedBitrate = options.bitrate instanceof Quality\n        ? options.bitrate._toVideoBitrate(options.codec, options.width, options.height)\n        : options.bitrate;\n    return {\n        codec: options.fullCodecString ?? buildVideoCodecString(options.codec, options.width, options.height, resolvedBitrate),\n        width: options.width,\n        height: options.height,\n        bitrate: resolvedBitrate,\n        bitrateMode: options.bitrateMode,\n        alpha: options.alpha ?? 'discard',\n        framerate: options.framerate,\n        latencyMode: options.latencyMode,\n        hardwareAcceleration: options.hardwareAcceleration,\n        scalabilityMode: options.scalabilityMode,\n        contentHint: options.contentHint,\n        ...getVideoEncoderConfigExtension(options.codec),\n    };\n};\nexport const validateAudioEncodingConfig = (config) => {\n    if (!config || typeof config !== 'object') {\n        throw new TypeError('Encoding config must be an object.');\n    }\n    if (!AUDIO_CODECS.includes(config.codec)) {\n        throw new TypeError(`Invalid audio codec '${config.codec}'. Must be one of: ${AUDIO_CODECS.join(', ')}.`);\n    }\n    if (config.bitrate === undefined\n        && (!PCM_AUDIO_CODECS.includes(config.codec) || config.codec === 'flac')) {\n        throw new TypeError('config.bitrate must be provided for compressed audio codecs.');\n    }\n    if (config.bitrate !== undefined\n        && !(config.bitrate instanceof Quality)\n        && (!Number.isInteger(config.bitrate) || config.bitrate <= 0)) {\n        throw new TypeError('config.bitrate, when provided, must be a positive integer or a quality.');\n    }\n    if (config.onEncodedPacket !== undefined && typeof config.onEncodedPacket !== 'function') {\n        throw new TypeError('config.onEncodedChunk, when provided, must be a function.');\n    }\n    if (config.onEncoderConfig !== undefined && typeof config.onEncoderConfig !== 'function') {\n        throw new TypeError('config.onEncoderConfig, when provided, must be a function.');\n    }\n    validateAudioEncodingAdditionalOptions(config.codec, config);\n};\nexport const validateAudioEncodingAdditionalOptions = (codec, options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('Encoding options must be an object.');\n    }\n    if (options.bitrateMode !== undefined && !['constant', 'variable'].includes(options.bitrateMode)) {\n        throw new TypeError('bitrateMode, when provided, must be \\'constant\\' or \\'variable\\'.');\n    }\n    if (options.fullCodecString !== undefined && typeof options.fullCodecString !== 'string') {\n        throw new TypeError('fullCodecString, when provided, must be a string.');\n    }\n    if (options.fullCodecString !== undefined && inferCodecFromCodecString(options.fullCodecString) !== codec) {\n        throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${codec}).`);\n    }\n};\nexport const buildAudioEncoderConfig = (options) => {\n    const resolvedBitrate = options.bitrate instanceof Quality\n        ? options.bitrate._toAudioBitrate(options.codec)\n        : options.bitrate;\n    return {\n        codec: options.fullCodecString ?? buildAudioCodecString(options.codec, options.numberOfChannels, options.sampleRate),\n        numberOfChannels: options.numberOfChannels,\n        sampleRate: options.sampleRate,\n        bitrate: resolvedBitrate,\n        bitrateMode: options.bitrateMode,\n        ...getAudioEncoderConfigExtension(options.codec),\n    };\n};\n/**\n * Represents a subjective media quality level.\n * @group Encoding\n * @public\n */\nexport class Quality {\n    /** @internal */\n    constructor(factor) {\n        this._factor = factor;\n    }\n    /** @internal */\n    _toVideoBitrate(codec, width, height) {\n        const pixels = width * height;\n        const codecEfficiencyFactors = {\n            avc: 1.0, // H.264/AVC (baseline)\n            hevc: 0.6, // H.265/HEVC (~40% more efficient than AVC)\n            vp9: 0.6, // Similar to HEVC\n            av1: 0.4, // ~60% more efficient than AVC\n            vp8: 1.2, // Slightly less efficient than AVC\n        };\n        const referencePixels = 1920 * 1080;\n        const referenceBitrate = 3000000;\n        const scaleFactor = Math.pow(pixels / referencePixels, 0.95); // Slight non-linear scaling\n        const baseBitrate = referenceBitrate * scaleFactor;\n        const codecAdjustedBitrate = baseBitrate * codecEfficiencyFactors[codec];\n        const finalBitrate = codecAdjustedBitrate * this._factor;\n        return Math.ceil(finalBitrate / 1000) * 1000;\n    }\n    /** @internal */\n    _toAudioBitrate(codec) {\n        if (PCM_AUDIO_CODECS.includes(codec) || codec === 'flac') {\n            return undefined;\n        }\n        const baseRates = {\n            aac: 128000, // 128kbps base for AAC\n            opus: 64000, // 64kbps base for Opus\n            mp3: 160000, // 160kbps base for MP3\n            vorbis: 64000, // 64kbps base for Vorbis\n        };\n        const baseBitrate = baseRates[codec];\n        if (!baseBitrate) {\n            throw new Error(`Unhandled codec: ${codec}`);\n        }\n        let finalBitrate = baseBitrate * this._factor;\n        if (codec === 'aac') {\n            // AAC only works with specific bitrates, let's find the closest\n            const validRates = [96000, 128000, 160000, 192000];\n            finalBitrate = validRates.reduce((prev, curr) => Math.abs(curr - finalBitrate) < Math.abs(prev - finalBitrate) ? curr : prev);\n        }\n        else if (codec === 'opus' || codec === 'vorbis') {\n            finalBitrate = Math.max(6000, finalBitrate);\n        }\n        else if (codec === 'mp3') {\n            const validRates = [\n                8000, 16000, 24000, 32000, 40000, 48000, 64000, 80000,\n                96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000,\n            ];\n            finalBitrate = validRates.reduce((prev, curr) => Math.abs(curr - finalBitrate) < Math.abs(prev - finalBitrate) ? curr : prev);\n        }\n        return Math.round(finalBitrate / 1000) * 1000;\n    }\n}\n/**\n * Represents a very low media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_VERY_LOW = /* #__PURE__ */ new Quality(0.3);\n/**\n * Represents a low media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_LOW = /* #__PURE__ */ new Quality(0.6);\n/**\n * Represents a medium media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_MEDIUM = /* #__PURE__ */ new Quality(1);\n/**\n * Represents a high media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_HIGH = /* #__PURE__ */ new Quality(2);\n/**\n * Represents a very high media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_VERY_HIGH = /* #__PURE__ */ new Quality(4);\n/**\n * Checks if the browser is able to encode the given codec.\n * @group Encoding\n * @public\n */\nexport const canEncode = (codec) => {\n    if (VIDEO_CODECS.includes(codec)) {\n        return canEncodeVideo(codec);\n    }\n    else if (AUDIO_CODECS.includes(codec)) {\n        return canEncodeAudio(codec);\n    }\n    else if (SUBTITLE_CODECS.includes(codec)) {\n        return canEncodeSubtitles(codec);\n    }\n    throw new TypeError(`Unknown codec '${codec}'.`);\n};\n/**\n * Checks if the browser is able to encode the given video codec with the given parameters.\n * @group Encoding\n * @public\n */\nexport const canEncodeVideo = async (codec, options = {}) => {\n    const { width = 1280, height = 720, bitrate = 1e6, ...restOptions } = options;\n    if (!VIDEO_CODECS.includes(codec)) {\n        return false;\n    }\n    if (!Number.isInteger(width) || width <= 0) {\n        throw new TypeError('width must be a positive integer.');\n    }\n    if (!Number.isInteger(height) || height <= 0) {\n        throw new TypeError('height must be a positive integer.');\n    }\n    if (!(bitrate instanceof Quality) && (!Number.isInteger(bitrate) || bitrate <= 0)) {\n        throw new TypeError('bitrate must be a positive integer or a quality.');\n    }\n    validateVideoEncodingAdditionalOptions(codec, restOptions);\n    let encoderConfig = null;\n    if (customVideoEncoders.length > 0) {\n        encoderConfig ??= buildVideoEncoderConfig({\n            codec,\n            width,\n            height,\n            bitrate,\n            framerate: undefined,\n            ...restOptions,\n        });\n        if (customVideoEncoders.some(x => x.supports(codec, encoderConfig))) {\n            // There's a custom encoder\n            return true;\n        }\n    }\n    if (typeof VideoEncoder === 'undefined') {\n        return false;\n    }\n    const hasOddDimension = width % 2 === 1 || height % 2 === 1;\n    if (hasOddDimension\n        && (codec === 'avc' || codec === 'hevc')) {\n        // Disallow odd dimensions for certain codecs\n        return false;\n    }\n    encoderConfig ??= buildVideoEncoderConfig({\n        codec,\n        width,\n        height,\n        bitrate,\n        framerate: undefined,\n        ...restOptions,\n        alpha: 'discard', // Since we handle alpha ourselves\n    });\n    const support = await VideoEncoder.isConfigSupported(encoderConfig);\n    if (!support.supported) {\n        return false;\n    }\n    if (isFirefox()) {\n        // isConfigSupported on Firefox appears to unreliably indicate if encoding will actually succeed. Therefore, we\n        // just try encoding a frame to see if it actually works.\n        // https://github.com/Vanilagy/mediabunny/issues/222\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor\n        return new Promise(async (resolve) => {\n            try {\n                const encoder = new VideoEncoder({\n                    output: () => { },\n                    error: () => resolve(false),\n                });\n                encoder.configure(encoderConfig);\n                const frameData = new Uint8Array(width * height * 4);\n                const frame = new VideoFrame(frameData, {\n                    format: 'RGBA',\n                    codedWidth: width,\n                    codedHeight: height,\n                    timestamp: 0,\n                });\n                encoder.encode(frame);\n                frame.close();\n                await encoder.flush();\n                resolve(true);\n            }\n            catch {\n                resolve(false);\n            }\n        });\n    }\n    else {\n        return true;\n    }\n};\n/**\n * Checks if the browser is able to encode the given audio codec with the given parameters.\n * @group Encoding\n * @public\n */\nexport const canEncodeAudio = async (codec, options = {}) => {\n    const { numberOfChannels = 2, sampleRate = 48000, bitrate = 128e3, ...restOptions } = options;\n    if (!AUDIO_CODECS.includes(codec)) {\n        return false;\n    }\n    if (!Number.isInteger(numberOfChannels) || numberOfChannels <= 0) {\n        throw new TypeError('numberOfChannels must be a positive integer.');\n    }\n    if (!Number.isInteger(sampleRate) || sampleRate <= 0) {\n        throw new TypeError('sampleRate must be a positive integer.');\n    }\n    if (!(bitrate instanceof Quality) && (!Number.isInteger(bitrate) || bitrate <= 0)) {\n        throw new TypeError('bitrate must be a positive integer.');\n    }\n    validateAudioEncodingAdditionalOptions(codec, restOptions);\n    let encoderConfig = null;\n    if (customAudioEncoders.length > 0) {\n        encoderConfig ??= buildAudioEncoderConfig({\n            codec,\n            numberOfChannels,\n            sampleRate,\n            bitrate,\n            ...restOptions,\n        });\n        if (customAudioEncoders.some(x => x.supports(codec, encoderConfig))) {\n            // There's a custom encoder\n            return true;\n        }\n    }\n    if (PCM_AUDIO_CODECS.includes(codec)) {\n        return true; // Because we encode these ourselves\n    }\n    if (typeof AudioEncoder === 'undefined') {\n        return false;\n    }\n    encoderConfig ??= buildAudioEncoderConfig({\n        codec,\n        numberOfChannels,\n        sampleRate,\n        bitrate,\n        ...restOptions,\n    });\n    const support = await AudioEncoder.isConfigSupported(encoderConfig);\n    return support.supported === true;\n};\n/**\n * Checks if the browser is able to encode the given subtitle codec.\n * @group Encoding\n * @public\n */\nexport const canEncodeSubtitles = async (codec) => {\n    if (!SUBTITLE_CODECS.includes(codec)) {\n        return false;\n    }\n    return true;\n};\n/**\n * Returns the list of all media codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableCodecs = async () => {\n    const [videoCodecs, audioCodecs, subtitleCodecs] = await Promise.all([\n        getEncodableVideoCodecs(),\n        getEncodableAudioCodecs(),\n        getEncodableSubtitleCodecs(),\n    ]);\n    return [...videoCodecs, ...audioCodecs, ...subtitleCodecs];\n};\n/**\n * Returns the list of all video codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableVideoCodecs = async (checkedCodecs = VIDEO_CODECS, options) => {\n    const bools = await Promise.all(checkedCodecs.map(codec => canEncodeVideo(codec, options)));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the list of all audio codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableAudioCodecs = async (checkedCodecs = AUDIO_CODECS, options) => {\n    const bools = await Promise.all(checkedCodecs.map(codec => canEncodeAudio(codec, options)));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the list of all subtitle codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableSubtitleCodecs = async (checkedCodecs = SUBTITLE_CODECS) => {\n    const bools = await Promise.all(checkedCodecs.map(canEncodeSubtitles));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the first video codec from the given list that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getFirstEncodableVideoCodec = async (checkedCodecs, options) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeVideo(codec, options)) {\n            return codec;\n        }\n    }\n    return null;\n};\n/**\n * Returns the first audio codec from the given list that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getFirstEncodableAudioCodec = async (checkedCodecs, options) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeAudio(codec, options)) {\n            return codec;\n        }\n    }\n    return null;\n};\n/**\n * Returns the first subtitle codec from the given list that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getFirstEncodableSubtitleCodec = async (checkedCodecs) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeSubtitles(codec)) {\n            return codec;\n        }\n    }\n    return null;\n};\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AUDIO_CODECS, buildAacAudioSpecificConfig, parseAacAudioSpecificConfig, parsePcmCodec, PCM_AUDIO_CODECS, SUBTITLE_CODECS, VIDEO_CODECS, } from './codec.js';\nimport { assert, assertNever, CallSerializer, clamp, isFirefox, last, promiseWithResolvers, setInt24, setUint24, toUint8Array, } from './misc.js';\nimport { SubtitleParser } from './subtitles.js';\nimport { toAlaw, toUlaw } from './pcm.js';\nimport { customVideoEncoders, customAudioEncoders, } from './custom-coder.js';\nimport { EncodedPacket } from './packet.js';\nimport { AudioSample, VideoSample } from './sample.js';\nimport { buildAudioEncoderConfig, buildVideoEncoderConfig, validateAudioEncodingConfig, validateVideoEncodingConfig, } from './encode.js';\n/**\n * Base class for media sources. Media sources are used to add media samples to an output file.\n * @group Media sources\n * @public\n */\nexport class MediaSource {\n    constructor() {\n        /** @internal */\n        this._connectedTrack = null;\n        /** @internal */\n        this._closingPromise = null;\n        /** @internal */\n        this._closed = false;\n        /**\n         * @internal\n         * A time offset in seconds that is added to all timestamps generated by this source.\n         */\n        this._timestampOffset = 0;\n    }\n    /** @internal */\n    _ensureValidAdd() {\n        if (!this._connectedTrack) {\n            throw new Error('Source is not connected to an output track.');\n        }\n        if (this._connectedTrack.output.state === 'canceled') {\n            throw new Error('Output has been canceled.');\n        }\n        if (this._connectedTrack.output.state === 'finalizing' || this._connectedTrack.output.state === 'finalized') {\n            throw new Error('Output has been finalized.');\n        }\n        if (this._connectedTrack.output.state === 'pending') {\n            throw new Error('Output has not started.');\n        }\n        if (this._closed) {\n            throw new Error('Source is closed.');\n        }\n    }\n    /** @internal */\n    async _start() { }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async _flushAndClose(forceClose) { }\n    /**\n     * Closes this source. This prevents future samples from being added and signals to the output file that no further\n     * samples will come in for this track. Calling `.close()` is optional but recommended after adding the\n     * last sample - for improved performance and reduced memory usage.\n     */\n    close() {\n        if (this._closingPromise) {\n            return;\n        }\n        const connectedTrack = this._connectedTrack;\n        if (!connectedTrack) {\n            throw new Error('Cannot call close without connecting the source to an output track.');\n        }\n        if (connectedTrack.output.state === 'pending') {\n            throw new Error('Cannot call close before output has been started.');\n        }\n        this._closingPromise = (async () => {\n            await this._flushAndClose(false);\n            this._closed = true;\n            if (connectedTrack.output.state === 'finalizing' || connectedTrack.output.state === 'finalized') {\n                return;\n            }\n            connectedTrack.output._muxer.onTrackClose(connectedTrack);\n        })();\n    }\n    /** @internal */\n    async _flushOrWaitForOngoingClose(forceClose) {\n        if (this._closingPromise) {\n            // Since closing also flushes, we don't want to do it twice\n            return this._closingPromise;\n        }\n        else {\n            return this._flushAndClose(forceClose);\n        }\n    }\n}\n/**\n * Base class for video sources - sources for video tracks.\n * @group Media sources\n * @public\n */\nexport class VideoSource extends MediaSource {\n    /** Internal constructor. */\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!VIDEO_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid video codec '${codec}'. Must be one of: ${VIDEO_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * The most basic video source; can be used to directly pipe encoded packets into the output file.\n * @group Media sources\n * @public\n */\nexport class EncodedVideoPacketSource extends VideoSource {\n    /** Creates a new {@link EncodedVideoPacketSource} whose packets are encoded using `codec`. */\n    constructor(codec) {\n        super(codec);\n    }\n    /**\n     * Adds an encoded packet to the output video track. Packets must be added in *decode order*, while a packet's\n     * timestamp must be its *presentation timestamp*. B-frames are handled automatically.\n     *\n     * @param meta - Additional metadata from the encoder. You should pass this for the first call, including a valid\n     * decoder config.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(packet, meta) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (packet.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be added.');\n        }\n        if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n            throw new TypeError('meta, when provided, must be an object.');\n        }\n        this._ensureValidAdd();\n        return this._connectedTrack.output._muxer.addEncodedVideoPacket(this._connectedTrack, packet, meta);\n    }\n}\nclass VideoEncoderWrapper {\n    constructor(source, encodingConfig) {\n        this.source = source;\n        this.encodingConfig = encodingConfig;\n        this.ensureEncoderPromise = null;\n        this.encoderInitialized = false;\n        this.encoder = null;\n        this.muxer = null;\n        this.lastMultipleOfKeyFrameInterval = -1;\n        this.codedWidth = null;\n        this.codedHeight = null;\n        this.resizeCanvas = null;\n        this.customEncoder = null;\n        this.customEncoderCallSerializer = new CallSerializer();\n        this.customEncoderQueueSize = 0;\n        // Alpha stuff\n        this.alphaEncoder = null;\n        this.splitter = null;\n        this.splitterCreationFailed = false;\n        this.alphaFrameQueue = [];\n        /**\n         * Encoders typically throw their errors \"out of band\", meaning asynchronously in some other execution context.\n         * However, we want to surface these errors to the user within the normal control flow, so they don't go uncaught.\n         * So, we keep track of the encoder error and throw it as soon as we get the chance.\n         */\n        this.error = null;\n        this.errorNeedsNewStack = true;\n    }\n    async add(videoSample, shouldClose, encodeOptions) {\n        try {\n            this.checkForEncoderError();\n            this.source._ensureValidAdd();\n            // Ensure video sample size remains constant\n            if (this.codedWidth !== null && this.codedHeight !== null) {\n                if (videoSample.codedWidth !== this.codedWidth || videoSample.codedHeight !== this.codedHeight) {\n                    const sizeChangeBehavior = this.encodingConfig.sizeChangeBehavior ?? 'deny';\n                    if (sizeChangeBehavior === 'passThrough') {\n                        // Do nada\n                    }\n                    else if (sizeChangeBehavior === 'deny') {\n                        throw new Error(`Video sample size must remain constant. Expected ${this.codedWidth}x${this.codedHeight},`\n                            + ` got ${videoSample.codedWidth}x${videoSample.codedHeight}. To allow the sample size to`\n                            + ` change over time, set \\`sizeChangeBehavior\\` to a value other than 'strict' in the`\n                            + ` encoding options.`);\n                    }\n                    else {\n                        let canvasIsNew = false;\n                        if (!this.resizeCanvas) {\n                            if (typeof document !== 'undefined') {\n                                // Prefer an HTMLCanvasElement\n                                this.resizeCanvas = document.createElement('canvas');\n                                this.resizeCanvas.width = this.codedWidth;\n                                this.resizeCanvas.height = this.codedHeight;\n                            }\n                            else {\n                                this.resizeCanvas = new OffscreenCanvas(this.codedWidth, this.codedHeight);\n                            }\n                            canvasIsNew = true;\n                        }\n                        const context = this.resizeCanvas.getContext('2d', {\n                            alpha: isFirefox(), // Firefox has VideoFrame glitches with opaque canvases\n                        });\n                        assert(context);\n                        if (!canvasIsNew) {\n                            if (isFirefox()) {\n                                context.fillStyle = 'black';\n                                context.fillRect(0, 0, this.codedWidth, this.codedHeight);\n                            }\n                            else {\n                                context.clearRect(0, 0, this.codedWidth, this.codedHeight);\n                            }\n                        }\n                        videoSample.drawWithFit(context, { fit: sizeChangeBehavior });\n                        if (shouldClose) {\n                            videoSample.close();\n                        }\n                        videoSample = new VideoSample(this.resizeCanvas, {\n                            timestamp: videoSample.timestamp,\n                            duration: videoSample.duration,\n                            rotation: videoSample.rotation,\n                        });\n                        shouldClose = true;\n                    }\n                }\n            }\n            else {\n                this.codedWidth = videoSample.codedWidth;\n                this.codedHeight = videoSample.codedHeight;\n            }\n            if (!this.encoderInitialized) {\n                if (!this.ensureEncoderPromise) {\n                    this.ensureEncoder(videoSample);\n                }\n                // No, this \"if\" statement is not useless. Sometimes, the above call to `ensureEncoder` might have\n                // synchronously completed and the encoder is already initialized. In this case, we don't need to await\n                // the promise anymore. This also fixes nasty async race condition bugs when multiple code paths are\n                // calling this method: It's important that the call that initialized the encoder go through this\n                // code first.\n                if (!this.encoderInitialized) {\n                    await this.ensureEncoderPromise;\n                }\n            }\n            assert(this.encoderInitialized);\n            const keyFrameInterval = this.encodingConfig.keyFrameInterval ?? 5;\n            const multipleOfKeyFrameInterval = Math.floor(videoSample.timestamp / keyFrameInterval);\n            // Ensure a key frame every keyFrameInterval seconds. It is important that all video tracks follow the same\n            // \"key frame\" rhythm, because aligned key frames are required to start new fragments in ISOBMFF or clusters\n            // in Matroska (or at least desirable).\n            const finalEncodeOptions = {\n                ...encodeOptions,\n                keyFrame: encodeOptions?.keyFrame\n                    || keyFrameInterval === 0\n                    || multipleOfKeyFrameInterval !== this.lastMultipleOfKeyFrameInterval,\n            };\n            this.lastMultipleOfKeyFrameInterval = multipleOfKeyFrameInterval;\n            if (this.customEncoder) {\n                this.customEncoderQueueSize++;\n                // We clone the sample so it cannot be closed on us from the outside before it reaches the encoder\n                const clonedSample = videoSample.clone();\n                const promise = this.customEncoderCallSerializer\n                    .call(() => this.customEncoder.encode(clonedSample, finalEncodeOptions))\n                    .then(() => this.customEncoderQueueSize--)\n                    .catch((error) => this.error ??= error)\n                    .finally(() => {\n                    clonedSample.close();\n                    // `videoSample` gets closed in the finally block at the end of the method\n                });\n                if (this.customEncoderQueueSize >= 4) {\n                    await promise;\n                }\n            }\n            else {\n                assert(this.encoder);\n                const videoFrame = videoSample.toVideoFrame();\n                if (!this.alphaEncoder) {\n                    // No alpha encoder, simple case\n                    this.encoder.encode(videoFrame, finalEncodeOptions);\n                    videoFrame.close();\n                }\n                else {\n                    // We're expected to encode alpha as well\n                    const frameDefinitelyHasNoAlpha = !!videoFrame.format && !videoFrame.format.includes('A');\n                    if (frameDefinitelyHasNoAlpha || this.splitterCreationFailed) {\n                        this.alphaFrameQueue.push(null);\n                        this.encoder.encode(videoFrame, finalEncodeOptions);\n                        videoFrame.close();\n                    }\n                    else {\n                        const width = videoFrame.displayWidth;\n                        const height = videoFrame.displayHeight;\n                        if (!this.splitter) {\n                            try {\n                                this.splitter = new ColorAlphaSplitter(width, height);\n                            }\n                            catch (error) {\n                                console.error('Due to an error, only color data will be encoded.', error);\n                                this.splitterCreationFailed = true;\n                                this.alphaFrameQueue.push(null);\n                                this.encoder.encode(videoFrame, finalEncodeOptions);\n                                videoFrame.close();\n                            }\n                        }\n                        if (this.splitter) {\n                            const colorFrame = this.splitter.extractColor(videoFrame);\n                            const alphaFrame = this.splitter.extractAlpha(videoFrame);\n                            this.alphaFrameQueue.push(alphaFrame);\n                            this.encoder.encode(colorFrame, finalEncodeOptions);\n                            colorFrame.close();\n                            videoFrame.close();\n                        }\n                    }\n                }\n                if (shouldClose) {\n                    videoSample.close();\n                }\n                // We need to do this after sending the frame to the encoder as the frame otherwise might be closed\n                if (this.encoder.encodeQueueSize >= 4) {\n                    await new Promise(resolve => this.encoder.addEventListener('dequeue', resolve, { once: true }));\n                }\n            }\n            await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n        }\n        finally {\n            if (shouldClose) {\n                // Make sure it's always closed, even if there was an error\n                videoSample.close();\n            }\n        }\n    }\n    ensureEncoder(videoSample) {\n        const encoderError = new Error();\n        this.ensureEncoderPromise = (async () => {\n            const encoderConfig = buildVideoEncoderConfig({\n                width: videoSample.codedWidth,\n                height: videoSample.codedHeight,\n                ...this.encodingConfig,\n                framerate: this.source._connectedTrack?.metadata.frameRate,\n            });\n            this.encodingConfig.onEncoderConfig?.(encoderConfig);\n            const MatchingCustomEncoder = customVideoEncoders.find(x => x.supports(this.encodingConfig.codec, encoderConfig));\n            if (MatchingCustomEncoder) {\n                // @ts-expect-error \"Can't create instance of abstract class \"\n                this.customEncoder = new MatchingCustomEncoder();\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.codec = this.encodingConfig.codec;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.config = encoderConfig;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.onPacket = (packet, meta) => {\n                    if (!(packet instanceof EncodedPacket)) {\n                        throw new TypeError('The first argument passed to onPacket must be an EncodedPacket.');\n                    }\n                    if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n                        throw new TypeError('The second argument passed to onPacket must be an object or undefined.');\n                    }\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedVideoPacket(this.source._connectedTrack, packet, meta)\n                        .catch((error) => {\n                        this.error ??= error;\n                        this.errorNeedsNewStack = false;\n                    });\n                };\n                await this.customEncoder.init();\n            }\n            else {\n                if (typeof VideoEncoder === 'undefined') {\n                    throw new Error('VideoEncoder is not supported by this browser.');\n                }\n                encoderConfig.alpha = 'discard'; // Since we handle alpha ourselves\n                if (this.encodingConfig.alpha === 'keep') {\n                    // Encoding alpha requires using two parallel encoders, so we need to make sure they stay in sync\n                    // and that neither of them drops frames. Setting latencyMode to 'quality' achieves this, because\n                    // \"User Agents MUST not drop frames to achieve the target bitrate and/or framerate.\"\n                    encoderConfig.latencyMode = 'quality';\n                }\n                const hasOddDimension = encoderConfig.width % 2 === 1 || encoderConfig.height % 2 === 1;\n                if (hasOddDimension\n                    && (this.encodingConfig.codec === 'avc' || this.encodingConfig.codec === 'hevc')) {\n                    // Throw a special error for this case as it gets hit often\n                    throw new Error(`The dimensions ${encoderConfig.width}x${encoderConfig.height} are not supported for codec`\n                        + ` '${this.encodingConfig.codec}'; both width and height must be even numbers. Make sure to`\n                        + ` round your dimensions to the nearest even number.`);\n                }\n                const support = await VideoEncoder.isConfigSupported(encoderConfig);\n                if (!support.supported) {\n                    throw new Error(`This specific encoder configuration (${encoderConfig.codec}, ${encoderConfig.bitrate} bps,`\n                        + ` ${encoderConfig.width}x${encoderConfig.height}, hardware acceleration:`\n                        + ` ${encoderConfig.hardwareAcceleration ?? 'no-preference'}) is not supported by this browser.`\n                        + ` Consider using another codec or changing your video parameters.`);\n                }\n                /** Queue of color chunks waiting for their alpha counterpart. */\n                const colorChunkQueue = [];\n                /** Each value is the number of encoded alpha chunks at which a null alpha chunk should be added. */\n                const nullAlphaChunkQueue = [];\n                let encodedAlphaChunkCount = 0;\n                let alphaEncoderQueue = 0;\n                const addPacket = (colorChunk, alphaChunk, meta) => {\n                    const sideData = {};\n                    if (alphaChunk) {\n                        const alphaData = new Uint8Array(alphaChunk.byteLength);\n                        alphaChunk.copyTo(alphaData);\n                        sideData.alpha = alphaData;\n                    }\n                    const packet = EncodedPacket.fromEncodedChunk(colorChunk, sideData);\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedVideoPacket(this.source._connectedTrack, packet, meta)\n                        .catch((error) => {\n                        this.error ??= error;\n                        this.errorNeedsNewStack = false;\n                    });\n                };\n                this.encoder = new VideoEncoder({\n                    output: (chunk, meta) => {\n                        if (!this.alphaEncoder) {\n                            // We're done\n                            addPacket(chunk, null, meta);\n                            return;\n                        }\n                        const alphaFrame = this.alphaFrameQueue.shift();\n                        assert(alphaFrame !== undefined);\n                        if (alphaFrame) {\n                            this.alphaEncoder.encode(alphaFrame, {\n                                // Crucial: The alpha frame is forced to be a key frame whenever the color frame\n                                // also is. Without this, playback can glitch and even crash in some browsers.\n                                // This is the reason why the two encoders are wired in series and not in parallel.\n                                keyFrame: chunk.type === 'key',\n                            });\n                            alphaEncoderQueue++;\n                            alphaFrame.close();\n                            colorChunkQueue.push({ chunk, meta });\n                        }\n                        else {\n                            // There was no alpha component for this frame\n                            if (alphaEncoderQueue === 0) {\n                                // No pending alpha encodes either, so we're done\n                                addPacket(chunk, null, meta);\n                            }\n                            else {\n                                // There are still alpha encodes pending, so we can't add the packet immediately since\n                                // we'd end up with out-of-order packets. Instead, let's queue a null alpha chunk to be\n                                // added in the future, after the current encoder workload has completed:\n                                nullAlphaChunkQueue.push(encodedAlphaChunkCount + alphaEncoderQueue);\n                                colorChunkQueue.push({ chunk, meta });\n                            }\n                        }\n                    },\n                    error: (error) => {\n                        error.stack = encoderError.stack; // Provide a more useful stack trace\n                        this.error ??= error;\n                    },\n                });\n                this.encoder.configure(encoderConfig);\n                if (this.encodingConfig.alpha === 'keep') {\n                    // We need to encode alpha as well, which we do with a separate encoder\n                    this.alphaEncoder = new VideoEncoder({\n                        // We ignore the alpha chunk's metadata\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                        output: (chunk, meta) => {\n                            alphaEncoderQueue--;\n                            // There has to be a color chunk because the encoders are wired in series\n                            const colorChunk = colorChunkQueue.shift();\n                            assert(colorChunk !== undefined);\n                            addPacket(colorChunk.chunk, chunk, colorChunk.meta);\n                            // See if there are any null alpha chunks queued up\n                            encodedAlphaChunkCount++;\n                            while (nullAlphaChunkQueue.length > 0\n                                && nullAlphaChunkQueue[0] === encodedAlphaChunkCount) {\n                                nullAlphaChunkQueue.shift();\n                                const colorChunk = colorChunkQueue.shift();\n                                assert(colorChunk !== undefined);\n                                addPacket(colorChunk.chunk, null, colorChunk.meta);\n                            }\n                        },\n                        error: (error) => {\n                            error.stack = encoderError.stack; // Provide a more useful stack trace\n                            this.error ??= error;\n                        },\n                    });\n                    this.alphaEncoder.configure(encoderConfig);\n                }\n            }\n            assert(this.source._connectedTrack);\n            this.muxer = this.source._connectedTrack.output._muxer;\n            this.encoderInitialized = true;\n        })();\n    }\n    async flushAndClose(forceClose) {\n        if (!forceClose)\n            this.checkForEncoderError();\n        if (this.customEncoder) {\n            if (!forceClose) {\n                void this.customEncoderCallSerializer.call(() => this.customEncoder.flush());\n            }\n            await this.customEncoderCallSerializer.call(() => this.customEncoder.close());\n        }\n        else if (this.encoder) {\n            if (!forceClose) {\n                // These are wired in series, therefore they must also be flushed in series\n                await this.encoder.flush();\n                await this.alphaEncoder?.flush();\n            }\n            if (this.encoder.state !== 'closed') {\n                this.encoder.close();\n            }\n            if (this.alphaEncoder && this.alphaEncoder.state !== 'closed') {\n                this.alphaEncoder.close();\n            }\n            this.alphaFrameQueue.forEach(x => x?.close());\n            this.splitter?.close();\n        }\n        if (!forceClose)\n            this.checkForEncoderError();\n    }\n    getQueueSize() {\n        if (this.customEncoder) {\n            return this.customEncoderQueueSize;\n        }\n        else {\n            // Because the color and alpha encoders are wired in series, there's no need to also include the alpha\n            // encoder's queue size here\n            return this.encoder?.encodeQueueSize ?? 0;\n        }\n    }\n    checkForEncoderError() {\n        if (this.error) {\n            if (this.errorNeedsNewStack) {\n                this.error.stack = new Error().stack; // Provide an even more useful stack trace\n            }\n            throw this.error;\n        }\n    }\n}\n/** Utility class for splitting a composite frame into separate color and alpha components. */\nclass ColorAlphaSplitter {\n    constructor(initialWidth, initialHeight) {\n        this.lastFrame = null;\n        if (typeof OffscreenCanvas !== 'undefined') {\n            this.canvas = new OffscreenCanvas(initialWidth, initialHeight);\n        }\n        else {\n            this.canvas = document.createElement('canvas');\n            this.canvas.width = initialWidth;\n            this.canvas.height = initialHeight;\n        }\n        const gl = this.canvas.getContext('webgl2', {\n            alpha: true, // Needed due to the YUV thing we do for alpha\n        }); // Casting because of some TypeScript weirdness\n        if (!gl) {\n            throw new Error('Couldn\\'t acquire WebGL 2 context.');\n        }\n        this.gl = gl;\n        this.colorProgram = this.createColorProgram();\n        this.alphaProgram = this.createAlphaProgram();\n        this.vao = this.createVAO();\n        this.sourceTexture = this.createTexture();\n        this.alphaResolutionLocation = this.gl.getUniformLocation(this.alphaProgram, 'u_resolution');\n        this.gl.useProgram(this.colorProgram);\n        this.gl.uniform1i(this.gl.getUniformLocation(this.colorProgram, 'u_sourceTexture'), 0);\n        this.gl.useProgram(this.alphaProgram);\n        this.gl.uniform1i(this.gl.getUniformLocation(this.alphaProgram, 'u_sourceTexture'), 0);\n    }\n    createVertexShader() {\n        return this.createShader(this.gl.VERTEX_SHADER, `#version 300 es\n\t\t\tin vec2 a_position;\n\t\t\tin vec2 a_texCoord;\n\t\t\tout vec2 v_texCoord;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tgl_Position = vec4(a_position, 0.0, 1.0);\n\t\t\t\tv_texCoord = a_texCoord;\n\t\t\t}\n\t\t`);\n    }\n    createColorProgram() {\n        const vertexShader = this.createVertexShader();\n        // This shader is simple, simply copy the color information while setting alpha to 1\n        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, `#version 300 es\n\t\t\tprecision highp float;\n\t\t\t\n\t\t\tuniform sampler2D u_sourceTexture;\n\t\t\tin vec2 v_texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tvec4 source = texture(u_sourceTexture, v_texCoord);\n\t\t\t\tfragColor = vec4(source.rgb, 1.0);\n\t\t\t}\n\t\t`);\n        const program = this.gl.createProgram();\n        this.gl.attachShader(program, vertexShader);\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.linkProgram(program);\n        return program;\n    }\n    createAlphaProgram() {\n        const vertexShader = this.createVertexShader();\n        // This shader's more complex. The main reason is that this shader writes data in I420 (yuv420) pixel format\n        // instead of regular RGBA. In other words, we use the shader to write out I420 data into an RGBA canvas, which\n        // we then later read out with JavaScript. The reason being that browsers weirdly encode canvases and mess up\n        // the color spaces, and the only way to have full control over the color space is by outputting YUV data\n        // directly (avoiding the RGB conversion). Doing this conversion in JS is painfully slow, so let's utlize the\n        // GPU since we're already calling it anyway.\n        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, `#version 300 es\n\t\t\tprecision highp float;\n\t\t\t\n\t\t\tuniform sampler2D u_sourceTexture;\n\t\t\tuniform vec2 u_resolution; // The width and height of the canvas\n\t\t\tin vec2 v_texCoord;\n\t\t\tout vec4 fragColor;\n\n\t\t\t// This function determines the value for a single byte in the YUV stream\n\t\t\tfloat getByteValue(float byteOffset) {\n\t\t\t\tfloat width = u_resolution.x;\n\t\t\t\tfloat height = u_resolution.y;\n\n\t\t\t\tfloat yPlaneSize = width * height;\n\n\t\t\t\tif (byteOffset < yPlaneSize) {\n\t\t\t\t\t// This byte is in the luma plane. Find the corresponding pixel coordinates to sample from\n\t\t\t\t\tfloat y = floor(byteOffset / width);\n\t\t\t\t\tfloat x = mod(byteOffset, width);\n\t\t\t\t\t\n\t\t\t\t\t// Add 0.5 to sample the center of the texel\n\t\t\t\t\tvec2 sampleCoord = (vec2(x, y) + 0.5) / u_resolution;\n\t\t\t\t\t\n\t\t\t\t\t// The luma value is the alpha from the source texture\n\t\t\t\t\treturn texture(u_sourceTexture, sampleCoord).a;\n\t\t\t\t} else {\n\t\t\t\t\t// Write a fixed value for chroma and beyond\n\t\t\t\t\treturn 128.0 / 255.0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\t// Each fragment writes 4 bytes (R, G, B, A)\n\t\t\t\tfloat pixelIndex = floor(gl_FragCoord.y) * u_resolution.x + floor(gl_FragCoord.x);\n\t\t\t\tfloat baseByteOffset = pixelIndex * 4.0;\n\n\t\t\t\tvec4 result;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tfloat currentByteOffset = baseByteOffset + float(i);\n\t\t\t\t\tresult[i] = getByteValue(currentByteOffset);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfragColor = result;\n\t\t\t}\n\t\t`);\n        const program = this.gl.createProgram();\n        this.gl.attachShader(program, vertexShader);\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.linkProgram(program);\n        return program;\n    }\n    createShader(type, source) {\n        const shader = this.gl.createShader(type);\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n            console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));\n        }\n        return shader;\n    }\n    createVAO() {\n        const vao = this.gl.createVertexArray();\n        this.gl.bindVertexArray(vao);\n        const vertices = new Float32Array([\n            -1, -1, 0, 1,\n            1, -1, 1, 1,\n            -1, 1, 0, 0,\n            1, 1, 1, 0,\n        ]);\n        const buffer = this.gl.createBuffer();\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);\n        const positionLocation = this.gl.getAttribLocation(this.colorProgram, 'a_position');\n        const texCoordLocation = this.gl.getAttribLocation(this.colorProgram, 'a_texCoord');\n        this.gl.enableVertexAttribArray(positionLocation);\n        this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 16, 0);\n        this.gl.enableVertexAttribArray(texCoordLocation);\n        this.gl.vertexAttribPointer(texCoordLocation, 2, this.gl.FLOAT, false, 16, 8);\n        return vao;\n    }\n    createTexture() {\n        const texture = this.gl.createTexture();\n        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n        return texture;\n    }\n    updateTexture(sourceFrame) {\n        if (this.lastFrame === sourceFrame) {\n            return;\n        }\n        if (sourceFrame.displayWidth !== this.canvas.width || sourceFrame.displayHeight !== this.canvas.height) {\n            this.canvas.width = sourceFrame.displayWidth;\n            this.canvas.height = sourceFrame.displayHeight;\n        }\n        this.gl.activeTexture(this.gl.TEXTURE0);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.sourceTexture);\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, sourceFrame);\n        this.lastFrame = sourceFrame;\n    }\n    extractColor(sourceFrame) {\n        this.updateTexture(sourceFrame);\n        this.gl.useProgram(this.colorProgram);\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.bindVertexArray(this.vao);\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n        return new VideoFrame(this.canvas, {\n            timestamp: sourceFrame.timestamp,\n            duration: sourceFrame.duration ?? undefined,\n            alpha: 'discard',\n        });\n    }\n    extractAlpha(sourceFrame) {\n        this.updateTexture(sourceFrame);\n        this.gl.useProgram(this.alphaProgram);\n        this.gl.uniform2f(this.alphaResolutionLocation, this.canvas.width, this.canvas.height);\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.bindVertexArray(this.vao);\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n        const { width, height } = this.canvas;\n        const chromaSamples = Math.ceil(width / 2) * Math.ceil(height / 2);\n        const yuvSize = width * height + chromaSamples * 2;\n        const requiredHeight = Math.ceil(yuvSize / (width * 4));\n        let yuv = new Uint8Array(4 * width * requiredHeight);\n        this.gl.readPixels(0, 0, width, requiredHeight, this.gl.RGBA, this.gl.UNSIGNED_BYTE, yuv);\n        yuv = yuv.subarray(0, yuvSize);\n        assert(yuv[width * height] === 128); // Where chroma data starts\n        assert(yuv[yuv.length - 1] === 128); // Assert the YUV data has been fully written\n        // Defining this separately because TypeScript doesn't know `transfer` and I can't be bothered to do declaration\n        // merging right now\n        const init = {\n            format: 'I420',\n            codedWidth: width,\n            codedHeight: height,\n            timestamp: sourceFrame.timestamp,\n            duration: sourceFrame.duration ?? undefined,\n            transfer: [yuv.buffer],\n        };\n        return new VideoFrame(yuv, init);\n    }\n    close() {\n        this.gl.getExtension('WEBGL_lose_context')?.loseContext();\n        this.gl = null;\n    }\n}\n/**\n * This source can be used to add raw, unencoded video samples (frames) to an output video track. These frames will\n * automatically be encoded and then piped into the output.\n * @group Media sources\n * @public\n */\nexport class VideoSampleSource extends VideoSource {\n    /**\n     * Creates a new {@link VideoSampleSource} whose samples are encoded according to the specified\n     * {@link VideoEncodingConfig}.\n     */\n    constructor(encodingConfig) {\n        validateVideoEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Encodes a video sample (frame) and then adds it to the output.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(videoSample, encodeOptions) {\n        if (!(videoSample instanceof VideoSample)) {\n            throw new TypeError('videoSample must be a VideoSample.');\n        }\n        return this._encoder.add(videoSample, false, encodeOptions);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * This source can be used to add video frames to the output track from a fixed canvas element. Since canvases are often\n * used for rendering, this source provides a convenient wrapper around {@link VideoSampleSource}.\n * @group Media sources\n * @public\n */\nexport class CanvasSource extends VideoSource {\n    /**\n     * Creates a new {@link CanvasSource} from a canvas element or `OffscreenCanvas` whose samples are encoded\n     * according to the specified {@link VideoEncodingConfig}.\n     */\n    constructor(canvas, encodingConfig) {\n        if (!(typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement)\n            && !(typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n            throw new TypeError('canvas must be an HTMLCanvasElement or OffscreenCanvas.');\n        }\n        validateVideoEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n        this._canvas = canvas;\n    }\n    /**\n     * Captures the current canvas state as a video sample (frame), encodes it and adds it to the output.\n     *\n     * @param timestamp - The timestamp of the sample, in seconds.\n     * @param duration - The duration of the sample, in seconds.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(timestamp, duration = 0, encodeOptions) {\n        if (!Number.isFinite(timestamp) || timestamp < 0) {\n            throw new TypeError('timestamp must be a non-negative number.');\n        }\n        if (!Number.isFinite(duration) || duration < 0) {\n            throw new TypeError('duration must be a non-negative number.');\n        }\n        const sample = new VideoSample(this._canvas, { timestamp, duration });\n        return this._encoder.add(sample, true, encodeOptions);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Video source that encodes the frames of a\n * [`MediaStreamVideoTrack`](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) and pipes them into the\n * output. This is useful for capturing live or real-time data such as webcams or screen captures. Frames will\n * automatically start being captured once the connected {@link Output} is started, and will keep being captured until\n * the {@link Output} is finalized or this source is closed.\n * @group Media sources\n * @public\n */\nexport class MediaStreamVideoTrackSource extends VideoSource {\n    /** A promise that rejects upon any error within this source. This promise never resolves. */\n    get errorPromise() {\n        this._errorPromiseAccessed = true;\n        return this._promiseWithResolvers.promise;\n    }\n    /** Whether this source is currently paused as a result of calling `.pause()`. */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * Creates a new {@link MediaStreamVideoTrackSource} from a\n     * [`MediaStreamVideoTrack`](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack), which will pull\n     * video samples from the stream in real time and encode them according to {@link VideoEncodingConfig}.\n     */\n    constructor(track, encodingConfig) {\n        if (!(track instanceof MediaStreamTrack) || track.kind !== 'video') {\n            throw new TypeError('track must be a video MediaStreamTrack.');\n        }\n        validateVideoEncodingConfig(encodingConfig);\n        encodingConfig = {\n            ...encodingConfig,\n            latencyMode: 'realtime',\n        };\n        super(encodingConfig.codec);\n        /** @internal */\n        this._abortController = null;\n        /** @internal */\n        this._workerTrackId = null;\n        /** @internal */\n        this._workerListener = null;\n        /** @internal */\n        this._promiseWithResolvers = promiseWithResolvers();\n        /** @internal */\n        this._errorPromiseAccessed = false;\n        /** @internal */\n        this._paused = false;\n        /** @internal */\n        this._lastSampleTimestamp = null;\n        /** @internal */\n        this._pauseOffset = 0;\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n        this._track = track;\n    }\n    /** @internal */\n    async _start() {\n        if (!this._errorPromiseAccessed) {\n            console.warn('Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal'\n                + ' errors get bubbled up properly.');\n        }\n        this._abortController = new AbortController();\n        let firstVideoFrameTimestamp = null;\n        let errored = false;\n        const onVideoFrame = (videoFrame) => {\n            if (errored) {\n                videoFrame.close();\n                return;\n            }\n            const currentTimestamp = videoFrame.timestamp / 1e6;\n            if (this._paused) {\n                const frameSeen = firstVideoFrameTimestamp !== null;\n                if (frameSeen) {\n                    if (this._lastSampleTimestamp !== null) {\n                        // In addition to dropping this frame, let's also keep track of the time we have lost due to the\n                        // pause. Doing it like this instead of simply keeping track of the paused time is better since\n                        // it retains the frame rate of the underlying source.\n                        const timeDelta = currentTimestamp - this._lastSampleTimestamp;\n                        // We modify this field instead of _timestampOffset since we still might have data in flight\n                        // in the encoder, with which we don't want to mess.\n                        this._pauseOffset -= timeDelta;\n                    }\n                    this._lastSampleTimestamp = currentTimestamp;\n                }\n                videoFrame.close();\n                return;\n            }\n            if (firstVideoFrameTimestamp === null) {\n                firstVideoFrameTimestamp = currentTimestamp;\n                const muxer = this._connectedTrack.output._muxer;\n                if (muxer.firstMediaStreamTimestamp === null) {\n                    muxer.firstMediaStreamTimestamp = performance.now() / 1000;\n                    this._timestampOffset = -firstVideoFrameTimestamp;\n                }\n                else {\n                    this._timestampOffset = (performance.now() / 1000 - muxer.firstMediaStreamTimestamp)\n                        - firstVideoFrameTimestamp;\n                }\n            }\n            this._lastSampleTimestamp = currentTimestamp;\n            if (this._encoder.getQueueSize() >= 4) {\n                // Drop frames if the encoder is overloaded\n                videoFrame.close();\n                return;\n            }\n            const sample = new VideoSample(videoFrame, {\n                timestamp: currentTimestamp + this._pauseOffset,\n            });\n            void this._encoder.add(sample, true)\n                .catch((error) => {\n                errored = true;\n                this._abortController?.abort();\n                this._promiseWithResolvers.reject(error);\n                if (this._workerTrackId !== null) {\n                    // Tell the worker to stop the track\n                    sendMessageToMediaStreamTrackProcessorWorker({\n                        type: 'stopTrack',\n                        trackId: this._workerTrackId,\n                    });\n                }\n            });\n        };\n        if (typeof MediaStreamTrackProcessor !== 'undefined') {\n            // We can do it here directly, perfect\n            const processor = new MediaStreamTrackProcessor({ track: this._track });\n            const consumer = new WritableStream({ write: onVideoFrame });\n            processor.readable.pipeTo(consumer, {\n                signal: this._abortController.signal,\n            }).catch((error) => {\n                // Handle AbortError silently\n                if (error instanceof DOMException && error.name === 'AbortError')\n                    return;\n                this._promiseWithResolvers.reject(error);\n            });\n        }\n        else {\n            // It might still be supported in a worker, so let's check that\n            const supportedInWorker = await mediaStreamTrackProcessorIsSupportedInWorker();\n            if (supportedInWorker) {\n                this._workerTrackId = nextMediaStreamTrackProcessorWorkerId++;\n                sendMessageToMediaStreamTrackProcessorWorker({\n                    type: 'videoTrack',\n                    trackId: this._workerTrackId,\n                    track: this._track,\n                });\n                this._workerListener = (event) => {\n                    const message = event.data;\n                    if (message.type === 'videoFrame' && message.trackId === this._workerTrackId) {\n                        onVideoFrame(message.videoFrame);\n                    }\n                    else if (message.type === 'error' && message.trackId === this._workerTrackId) {\n                        this._promiseWithResolvers.reject(message.error);\n                    }\n                };\n                mediaStreamTrackProcessorWorker.addEventListener('message', this._workerListener);\n            }\n            else {\n                throw new Error('MediaStreamTrackProcessor is required but not supported by this browser.');\n            }\n        }\n    }\n    /**\n     * Pauses the capture of video frames - any video frames emitted by the underlying media stream will be ignored\n     * while paused. This does *not* close the underlying `MediaStreamVideoTrack`, it just ignores its output.\n     */\n    pause() {\n        this._paused = true;\n    }\n    /** Resumes the capture of video frames after being paused. */\n    resume() {\n        this._paused = false;\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (this._abortController) {\n            this._abortController.abort();\n            this._abortController = null;\n        }\n        if (this._workerTrackId !== null) {\n            assert(this._workerListener);\n            sendMessageToMediaStreamTrackProcessorWorker({\n                type: 'stopTrack',\n                trackId: this._workerTrackId,\n            });\n            // Wait for the worker to stop the track\n            await new Promise((resolve) => {\n                const listener = (event) => {\n                    const message = event.data;\n                    if (message.type === 'trackStopped' && message.trackId === this._workerTrackId) {\n                        assert(this._workerListener);\n                        mediaStreamTrackProcessorWorker.removeEventListener('message', this._workerListener);\n                        mediaStreamTrackProcessorWorker.removeEventListener('message', listener);\n                        resolve();\n                    }\n                };\n                mediaStreamTrackProcessorWorker.addEventListener('message', listener);\n            });\n        }\n        await this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Base class for audio sources - sources for audio tracks.\n * @group Media sources\n * @public\n */\nexport class AudioSource extends MediaSource {\n    /** Internal constructor. */\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!AUDIO_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid audio codec '${codec}'. Must be one of: ${AUDIO_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * The most basic audio source; can be used to directly pipe encoded packets into the output file.\n * @group Media sources\n * @public\n */\nexport class EncodedAudioPacketSource extends AudioSource {\n    /** Creates a new {@link EncodedAudioPacketSource} whose packets are encoded using `codec`. */\n    constructor(codec) {\n        super(codec);\n    }\n    /**\n     * Adds an encoded packet to the output audio track. Packets must be added in *decode order*.\n     *\n     * @param meta - Additional metadata from the encoder. You should pass this for the first call, including a valid\n     * decoder config.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(packet, meta) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (packet.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be added.');\n        }\n        if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n            throw new TypeError('meta, when provided, must be an object.');\n        }\n        this._ensureValidAdd();\n        return this._connectedTrack.output._muxer.addEncodedAudioPacket(this._connectedTrack, packet, meta);\n    }\n}\nclass AudioEncoderWrapper {\n    constructor(source, encodingConfig) {\n        this.source = source;\n        this.encodingConfig = encodingConfig;\n        this.ensureEncoderPromise = null;\n        this.encoderInitialized = false;\n        this.encoder = null;\n        this.muxer = null;\n        this.lastNumberOfChannels = null;\n        this.lastSampleRate = null;\n        this.isPcmEncoder = false;\n        this.outputSampleSize = null;\n        this.writeOutputValue = null;\n        this.customEncoder = null;\n        this.customEncoderCallSerializer = new CallSerializer();\n        this.customEncoderQueueSize = 0;\n        this.lastEndSampleIndex = null;\n        /**\n         * Encoders typically throw their errors \"out of band\", meaning asynchronously in some other execution context.\n         * However, we want to surface these errors to the user within the normal control flow, so they don't go uncaught.\n         * So, we keep track of the encoder error and throw it as soon as we get the chance.\n         */\n        this.error = null;\n        this.errorNeedsNewStack = true;\n    }\n    async add(audioSample, shouldClose) {\n        try {\n            this.checkForEncoderError();\n            this.source._ensureValidAdd();\n            // Ensure audio parameters remain constant\n            if (this.lastNumberOfChannels !== null && this.lastSampleRate !== null) {\n                if (audioSample.numberOfChannels !== this.lastNumberOfChannels\n                    || audioSample.sampleRate !== this.lastSampleRate) {\n                    throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at`\n                        + ` ${this.lastSampleRate} Hz, got ${audioSample.numberOfChannels} channels at`\n                        + ` ${audioSample.sampleRate} Hz.`);\n                }\n            }\n            else {\n                this.lastNumberOfChannels = audioSample.numberOfChannels;\n                this.lastSampleRate = audioSample.sampleRate;\n            }\n            if (!this.encoderInitialized) {\n                if (!this.ensureEncoderPromise) {\n                    this.ensureEncoder(audioSample);\n                }\n                // No, this \"if\" statement is not useless. Sometimes, the above call to `ensureEncoder` might have\n                // synchronously completed and the encoder is already initialized. In this case, we don't need to await\n                // the promise anymore. This also fixes nasty async race condition bugs when multiple code paths are\n                // calling this method: It's important that the call that initialized the encoder go through this\n                // code first.\n                if (!this.encoderInitialized) {\n                    await this.ensureEncoderPromise;\n                }\n            }\n            assert(this.encoderInitialized);\n            // Handle padding of gaps with silence to avoid audio drift over time, like in\n            // https://github.com/Vanilagy/mediabunny/issues/176\n            // TODO An open question is how encoders deal with the first AudioData having a non-zero timestamp, and with\n            // AudioDatas that have an overlapping timestamp range.\n            {\n                const startSampleIndex = Math.round(audioSample.timestamp * audioSample.sampleRate);\n                const endSampleIndex = Math.round((audioSample.timestamp + audioSample.duration) * audioSample.sampleRate);\n                if (this.lastEndSampleIndex === null) {\n                    this.lastEndSampleIndex = endSampleIndex;\n                }\n                else {\n                    const sampleDiff = startSampleIndex - this.lastEndSampleIndex;\n                    if (sampleDiff >= 64) {\n                        // The gap is big enough, let's add a correction sample\n                        const fillSample = new AudioSample({\n                            data: new Float32Array(sampleDiff * audioSample.numberOfChannels),\n                            format: 'f32-planar',\n                            sampleRate: audioSample.sampleRate,\n                            numberOfChannels: audioSample.numberOfChannels,\n                            numberOfFrames: sampleDiff,\n                            timestamp: this.lastEndSampleIndex / audioSample.sampleRate,\n                        });\n                        await this.add(fillSample, true); // Recursive call\n                    }\n                    this.lastEndSampleIndex += audioSample.numberOfFrames;\n                }\n            }\n            if (this.customEncoder) {\n                this.customEncoderQueueSize++;\n                // We clone the sample so it cannot be closed on us from the outside before it reaches the encoder\n                const clonedSample = audioSample.clone();\n                const promise = this.customEncoderCallSerializer\n                    .call(() => this.customEncoder.encode(clonedSample))\n                    .then(() => this.customEncoderQueueSize--)\n                    .catch((error) => this.error ??= error)\n                    .finally(() => {\n                    clonedSample.close();\n                    // `audioSample` gets closed in the finally block at the end of the method\n                });\n                if (this.customEncoderQueueSize >= 4) {\n                    await promise;\n                }\n                await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n            }\n            else if (this.isPcmEncoder) {\n                await this.doPcmEncoding(audioSample, shouldClose);\n            }\n            else {\n                assert(this.encoder);\n                const audioData = audioSample.toAudioData();\n                this.encoder.encode(audioData);\n                audioData.close();\n                if (shouldClose) {\n                    audioSample.close();\n                }\n                if (this.encoder.encodeQueueSize >= 4) {\n                    await new Promise(resolve => this.encoder.addEventListener('dequeue', resolve, { once: true }));\n                }\n                await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n            }\n        }\n        finally {\n            if (shouldClose) {\n                // Make sure it's always closed, even if there was an error\n                audioSample.close();\n            }\n        }\n    }\n    async doPcmEncoding(audioSample, shouldClose) {\n        assert(this.outputSampleSize);\n        assert(this.writeOutputValue);\n        // Need to extract data from the audio data before we close it\n        const { numberOfChannels, numberOfFrames, sampleRate, timestamp } = audioSample;\n        const CHUNK_SIZE = 2048;\n        const outputs = [];\n        // Prepare all of the output buffers, each being bounded by CHUNK_SIZE so we don't generate huge packets\n        for (let frame = 0; frame < numberOfFrames; frame += CHUNK_SIZE) {\n            const frameCount = Math.min(CHUNK_SIZE, audioSample.numberOfFrames - frame);\n            const outputSize = frameCount * numberOfChannels * this.outputSampleSize;\n            const outputBuffer = new ArrayBuffer(outputSize);\n            const outputView = new DataView(outputBuffer);\n            outputs.push({ frameCount, view: outputView });\n        }\n        const allocationSize = audioSample.allocationSize(({ planeIndex: 0, format: 'f32-planar' }));\n        const floats = new Float32Array(allocationSize / Float32Array.BYTES_PER_ELEMENT);\n        for (let i = 0; i < numberOfChannels; i++) {\n            audioSample.copyTo(floats, { planeIndex: i, format: 'f32-planar' });\n            for (let j = 0; j < outputs.length; j++) {\n                const { frameCount, view } = outputs[j];\n                for (let k = 0; k < frameCount; k++) {\n                    this.writeOutputValue(view, (k * numberOfChannels + i) * this.outputSampleSize, floats[j * CHUNK_SIZE + k]);\n                }\n            }\n        }\n        if (shouldClose) {\n            audioSample.close();\n        }\n        const meta = {\n            decoderConfig: {\n                codec: this.encodingConfig.codec,\n                numberOfChannels,\n                sampleRate,\n            },\n        };\n        for (let i = 0; i < outputs.length; i++) {\n            const { frameCount, view } = outputs[i];\n            const outputBuffer = view.buffer;\n            const startFrame = i * CHUNK_SIZE;\n            const packet = new EncodedPacket(new Uint8Array(outputBuffer), 'key', timestamp + startFrame / sampleRate, frameCount / sampleRate);\n            this.encodingConfig.onEncodedPacket?.(packet, meta);\n            await this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta); // With backpressure\n        }\n    }\n    ensureEncoder(audioSample) {\n        const encoderError = new Error();\n        this.ensureEncoderPromise = (async () => {\n            const { numberOfChannels, sampleRate } = audioSample;\n            const encoderConfig = buildAudioEncoderConfig({\n                numberOfChannels,\n                sampleRate,\n                ...this.encodingConfig,\n            });\n            this.encodingConfig.onEncoderConfig?.(encoderConfig);\n            const MatchingCustomEncoder = customAudioEncoders.find(x => x.supports(this.encodingConfig.codec, encoderConfig));\n            if (MatchingCustomEncoder) {\n                // @ts-expect-error \"Can't create instance of abstract class \"\n                this.customEncoder = new MatchingCustomEncoder();\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.codec = this.encodingConfig.codec;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.config = encoderConfig;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.onPacket = (packet, meta) => {\n                    if (!(packet instanceof EncodedPacket)) {\n                        throw new TypeError('The first argument passed to onPacket must be an EncodedPacket.');\n                    }\n                    if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n                        throw new TypeError('The second argument passed to onPacket must be an object or undefined.');\n                    }\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta)\n                        .catch((error) => {\n                        this.error ??= error;\n                        this.errorNeedsNewStack = false;\n                    });\n                };\n                await this.customEncoder.init();\n            }\n            else if (PCM_AUDIO_CODECS.includes(this.encodingConfig.codec)) {\n                this.initPcmEncoder();\n            }\n            else {\n                if (typeof AudioEncoder === 'undefined') {\n                    throw new Error('AudioEncoder is not supported by this browser.');\n                }\n                const support = await AudioEncoder.isConfigSupported(encoderConfig);\n                if (!support.supported) {\n                    throw new Error(`This specific encoder configuration (${encoderConfig.codec}, ${encoderConfig.bitrate} bps,`\n                        + ` ${encoderConfig.numberOfChannels} channels, ${encoderConfig.sampleRate} Hz) is not`\n                        + ` supported by this browser. Consider using another codec or changing your audio parameters.`);\n                }\n                this.encoder = new AudioEncoder({\n                    output: (chunk, meta) => {\n                        // WebKit emits an invalid description for AAC (https://bugs.webkit.org/show_bug.cgi?id=302253),\n                        // which we try to detect here. If detected, we'll provide our own description instead, derived\n                        // from the codec string and audio parameters.\n                        if (this.encodingConfig.codec === 'aac' && meta?.decoderConfig) {\n                            let needsDescriptionOverwrite = false;\n                            if (!meta.decoderConfig.description || meta.decoderConfig.description.byteLength < 2) {\n                                needsDescriptionOverwrite = true;\n                            }\n                            else {\n                                const audioSpecificConfig = parseAacAudioSpecificConfig(toUint8Array(meta.decoderConfig.description));\n                                needsDescriptionOverwrite = audioSpecificConfig.objectType === 0;\n                            }\n                            if (needsDescriptionOverwrite) {\n                                const objectType = Number(last(encoderConfig.codec.split('.')));\n                                meta.decoderConfig.description = buildAacAudioSpecificConfig({\n                                    objectType,\n                                    numberOfChannels: meta.decoderConfig.numberOfChannels,\n                                    sampleRate: meta.decoderConfig.sampleRate,\n                                });\n                            }\n                        }\n                        const packet = EncodedPacket.fromEncodedChunk(chunk);\n                        this.encodingConfig.onEncodedPacket?.(packet, meta);\n                        void this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta)\n                            .catch((error) => {\n                            this.error ??= error;\n                            this.errorNeedsNewStack = false;\n                        });\n                    },\n                    error: (error) => {\n                        error.stack = encoderError.stack; // Provide a more useful stack trace\n                        this.error ??= error;\n                    },\n                });\n                this.encoder.configure(encoderConfig);\n            }\n            assert(this.source._connectedTrack);\n            this.muxer = this.source._connectedTrack.output._muxer;\n            this.encoderInitialized = true;\n        })();\n    }\n    initPcmEncoder() {\n        this.isPcmEncoder = true;\n        const codec = this.encodingConfig.codec;\n        const { dataType, sampleSize, littleEndian } = parsePcmCodec(codec);\n        this.outputSampleSize = sampleSize;\n        // All these functions receive a float sample as input and map it into the desired format\n        switch (sampleSize) {\n            case 1:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint8(byteOffset, clamp((value + 1) * 127.5, 0, 255));\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            view.setInt8(byteOffset, clamp(Math.round(value * 128), -128, 127));\n                        };\n                    }\n                    else if (dataType === 'ulaw') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            const int16 = clamp(Math.floor(value * 32767), -32768, 32767);\n                            view.setUint8(byteOffset, toUlaw(int16));\n                        };\n                    }\n                    else if (dataType === 'alaw') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            const int16 = clamp(Math.floor(value * 32767), -32768, 32767);\n                            view.setUint8(byteOffset, toAlaw(int16));\n                        };\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 2:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint16(byteOffset, clamp((value + 1) * 32767.5, 0, 65535), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt16(byteOffset, clamp(Math.round(value * 32767), -32768, 32767), littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 3:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => setUint24(view, byteOffset, clamp((value + 1) * 8388607.5, 0, 16777215), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => setInt24(view, byteOffset, clamp(Math.round(value * 8388607), -8388608, 8388607), littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 4:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint32(byteOffset, clamp((value + 1) * 2147483647.5, 0, 4294967295), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt32(byteOffset, clamp(Math.round(value * 2147483647), -2147483648, 2147483647), littleEndian);\n                    }\n                    else if (dataType === 'float') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setFloat32(byteOffset, value, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 8:\n                {\n                    if (dataType === 'float') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setFloat64(byteOffset, value, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            default:\n                {\n                    assertNever(sampleSize);\n                    assert(false);\n                }\n                ;\n        }\n    }\n    async flushAndClose(forceClose) {\n        if (!forceClose)\n            this.checkForEncoderError();\n        if (this.customEncoder) {\n            if (!forceClose) {\n                void this.customEncoderCallSerializer.call(() => this.customEncoder.flush());\n            }\n            await this.customEncoderCallSerializer.call(() => this.customEncoder.close());\n        }\n        else if (this.encoder) {\n            if (!forceClose) {\n                await this.encoder.flush();\n            }\n            if (this.encoder.state !== 'closed') {\n                this.encoder.close();\n            }\n        }\n        if (!forceClose)\n            this.checkForEncoderError();\n    }\n    getQueueSize() {\n        if (this.customEncoder) {\n            return this.customEncoderQueueSize;\n        }\n        else if (this.isPcmEncoder) {\n            return 0;\n        }\n        else {\n            return this.encoder?.encodeQueueSize ?? 0;\n        }\n    }\n    checkForEncoderError() {\n        if (this.error) {\n            if (this.errorNeedsNewStack) {\n                this.error.stack = new Error().stack; // Provide an even more useful stack trace\n            }\n            throw this.error;\n        }\n    }\n}\n/**\n * This source can be used to add raw, unencoded audio samples to an output audio track. These samples will\n * automatically be encoded and then piped into the output.\n * @group Media sources\n * @public\n */\nexport class AudioSampleSource extends AudioSource {\n    /**\n     * Creates a new {@link AudioSampleSource} whose samples are encoded according to the specified\n     * {@link AudioEncodingConfig}.\n     */\n    constructor(encodingConfig) {\n        validateAudioEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Encodes an audio sample and then adds it to the output.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(audioSample) {\n        if (!(audioSample instanceof AudioSample)) {\n            throw new TypeError('audioSample must be an AudioSample.');\n        }\n        return this._encoder.add(audioSample, false);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * This source can be used to add audio data from an AudioBuffer to the output track. This is useful when working with\n * the Web Audio API.\n * @group Media sources\n * @public\n */\nexport class AudioBufferSource extends AudioSource {\n    /**\n     * Creates a new {@link AudioBufferSource} whose `AudioBuffer` instances are encoded according to the specified\n     * {@link AudioEncodingConfig}.\n     */\n    constructor(encodingConfig) {\n        validateAudioEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        /** @internal */\n        this._accumulatedTime = 0;\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Converts an AudioBuffer to audio samples, encodes them and adds them to the output. The first AudioBuffer will\n     * be played at timestamp 0, and any subsequent AudioBuffer will have a timestamp equal to the total duration of\n     * all previous AudioBuffers.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    async add(audioBuffer) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const iterator = AudioSample._fromAudioBuffer(audioBuffer, this._accumulatedTime);\n        this._accumulatedTime += audioBuffer.duration;\n        for (const audioSample of iterator) {\n            await this._encoder.add(audioSample, true);\n        }\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Audio source that encodes the data of a\n * [`MediaStreamAudioTrack`](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) and pipes it into the\n * output. This is useful for capturing live or real-time audio such as microphones or audio from other media elements.\n * Audio will automatically start being captured once the connected {@link Output} is started, and will keep being\n * captured until the {@link Output} is finalized or this source is closed.\n * @group Media sources\n * @public\n */\nexport class MediaStreamAudioTrackSource extends AudioSource {\n    /** A promise that rejects upon any error within this source. This promise never resolves. */\n    get errorPromise() {\n        this._errorPromiseAccessed = true;\n        return this._promiseWithResolvers.promise;\n    }\n    /** Whether this source is currently paused as a result of calling `.pause()`. */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * Creates a new {@link MediaStreamAudioTrackSource} from a `MediaStreamAudioTrack`, which will pull audio samples\n     * from the stream in real time and encode them according to {@link AudioEncodingConfig}.\n     */\n    constructor(track, encodingConfig) {\n        if (!(track instanceof MediaStreamTrack) || track.kind !== 'audio') {\n            throw new TypeError('track must be an audio MediaStreamTrack.');\n        }\n        validateAudioEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        /** @internal */\n        this._abortController = null;\n        /** @internal */\n        this._audioContext = null;\n        /** @internal */\n        this._scriptProcessorNode = null; // Deprecated but goated\n        /** @internal */\n        this._promiseWithResolvers = promiseWithResolvers();\n        /** @internal */\n        this._errorPromiseAccessed = false;\n        /** @internal */\n        this._paused = false;\n        /** @internal */\n        this._lastSampleTimestamp = null;\n        /** @internal */\n        this._pauseOffset = 0;\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n        this._track = track;\n    }\n    /** @internal */\n    async _start() {\n        if (!this._errorPromiseAccessed) {\n            console.warn('Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal'\n                + ' errors get bubbled up properly.');\n        }\n        this._abortController = new AbortController();\n        let firstAudioDataTimestamp = null;\n        let errored = false;\n        const onAudioSample = (audioSample) => {\n            if (errored) {\n                audioSample.close();\n                return;\n            }\n            const currentTimestamp = audioSample.timestamp;\n            if (this._paused) {\n                const dataSeen = firstAudioDataTimestamp !== null;\n                if (dataSeen) {\n                    if (this._lastSampleTimestamp !== null) {\n                        // In addition to dropping this sample, let's also keep track of the time we have lost due to\n                        // the pause. Doing it like this instead of simply keeping track of the paused time is better\n                        // since it retains the sample rate of the underlying source.\n                        const timeDelta = currentTimestamp - this._lastSampleTimestamp;\n                        // We modify this field instead of _timestampOffset since we still might have data in flight\n                        // in the encoder, with which we don't want to mess.\n                        this._pauseOffset -= timeDelta;\n                    }\n                    this._lastSampleTimestamp = currentTimestamp;\n                }\n                audioSample.close();\n                return;\n            }\n            if (firstAudioDataTimestamp === null) {\n                firstAudioDataTimestamp = audioSample.timestamp;\n                const muxer = this._connectedTrack.output._muxer;\n                if (muxer.firstMediaStreamTimestamp === null) {\n                    muxer.firstMediaStreamTimestamp = performance.now() / 1000;\n                    this._timestampOffset = -firstAudioDataTimestamp;\n                }\n                else {\n                    this._timestampOffset = (performance.now() / 1000 - muxer.firstMediaStreamTimestamp)\n                        - firstAudioDataTimestamp;\n                }\n            }\n            this._lastSampleTimestamp = currentTimestamp;\n            if (this._encoder.getQueueSize() >= 4) {\n                // Drop data if the encoder is overloaded\n                audioSample.close();\n                return;\n            }\n            audioSample.setTimestamp(currentTimestamp + this._pauseOffset);\n            void this._encoder.add(audioSample, true)\n                .catch((error) => {\n                errored = true;\n                this._abortController?.abort();\n                this._promiseWithResolvers.reject(error);\n                void this._audioContext?.suspend();\n            });\n        };\n        if (typeof MediaStreamTrackProcessor !== 'undefined') {\n            // Great, MediaStreamTrackProcessor is supported, this is the preferred way of doing things\n            const processor = new MediaStreamTrackProcessor({ track: this._track });\n            const consumer = new WritableStream({\n                write: audioData => onAudioSample(new AudioSample(audioData)),\n            });\n            processor.readable.pipeTo(consumer, {\n                signal: this._abortController.signal,\n            }).catch((error) => {\n                // Handle AbortError silently\n                if (error instanceof DOMException && error.name === 'AbortError')\n                    return;\n                this._promiseWithResolvers.reject(error);\n            });\n        }\n        else {\n            // Let's fall back to an AudioContext approach\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n            const AudioContext = window.AudioContext || window.webkitAudioContext;\n            this._audioContext = new AudioContext({ sampleRate: this._track.getSettings().sampleRate });\n            const sourceNode = this._audioContext.createMediaStreamSource(new MediaStream([this._track]));\n            this._scriptProcessorNode = this._audioContext.createScriptProcessor(4096);\n            if (this._audioContext.state === 'suspended') {\n                await this._audioContext.resume();\n            }\n            sourceNode.connect(this._scriptProcessorNode);\n            this._scriptProcessorNode.connect(this._audioContext.destination);\n            let totalDuration = 0;\n            this._scriptProcessorNode.onaudioprocess = (event) => {\n                const iterator = AudioSample._fromAudioBuffer(event.inputBuffer, totalDuration);\n                totalDuration += event.inputBuffer.duration;\n                for (const audioSample of iterator) {\n                    onAudioSample(audioSample);\n                }\n            };\n        }\n    }\n    /**\n     * Pauses the capture of audio data - any audio data emitted by the underlying media stream will be ignored\n     * while paused. This does *not* close the underlying `MediaStreamAudioTrack`, it just ignores its output.\n     */\n    pause() {\n        this._paused = true;\n    }\n    /** Resumes the capture of audio data after being paused. */\n    resume() {\n        this._paused = false;\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (this._abortController) {\n            this._abortController.abort();\n            this._abortController = null;\n        }\n        if (this._audioContext) {\n            assert(this._scriptProcessorNode);\n            this._scriptProcessorNode.disconnect();\n            await this._audioContext.suspend();\n        }\n        await this._encoder.flushAndClose(forceClose);\n    }\n}\nconst mediaStreamTrackProcessorWorkerCode = () => {\n    const sendMessage = (message, transfer) => {\n        if (transfer) {\n            self.postMessage(message, { transfer });\n        }\n        else {\n            self.postMessage(message);\n        }\n    };\n    // Immediately send a message to the main thread, letting them know of the support\n    sendMessage({\n        type: 'support',\n        supported: typeof MediaStreamTrackProcessor !== 'undefined',\n    });\n    const abortControllers = new Map();\n    const activeTracks = new Map();\n    self.addEventListener('message', (event) => {\n        const message = event.data;\n        switch (message.type) {\n            case 'videoTrack':\n                {\n                    activeTracks.set(message.trackId, message.track);\n                    const processor = new MediaStreamTrackProcessor({ track: message.track });\n                    const consumer = new WritableStream({\n                        write: (videoFrame) => {\n                            if (!activeTracks.has(message.trackId)) {\n                                videoFrame.close();\n                                return;\n                            }\n                            // Send it to the main thread\n                            sendMessage({\n                                type: 'videoFrame',\n                                trackId: message.trackId,\n                                videoFrame,\n                            }, [videoFrame]);\n                        },\n                    });\n                    const abortController = new AbortController();\n                    abortControllers.set(message.trackId, abortController);\n                    processor.readable.pipeTo(consumer, {\n                        signal: abortController.signal,\n                    }).catch((error) => {\n                        // Handle AbortError silently\n                        if (error instanceof DOMException && error.name === 'AbortError')\n                            return;\n                        sendMessage({\n                            type: 'error',\n                            trackId: message.trackId,\n                            error,\n                        });\n                    });\n                }\n                ;\n                break;\n            case 'stopTrack':\n                {\n                    const abortController = abortControllers.get(message.trackId);\n                    if (abortController) {\n                        abortController.abort();\n                        abortControllers.delete(message.trackId);\n                    }\n                    const track = activeTracks.get(message.trackId);\n                    track?.stop();\n                    activeTracks.delete(message.trackId);\n                    sendMessage({\n                        type: 'trackStopped',\n                        trackId: message.trackId,\n                    });\n                }\n                ;\n                break;\n            default: assertNever(message);\n        }\n    });\n};\nlet nextMediaStreamTrackProcessorWorkerId = 0;\nlet mediaStreamTrackProcessorWorker = null;\nconst initMediaStreamTrackProcessorWorker = () => {\n    const blob = new Blob([`(${mediaStreamTrackProcessorWorkerCode.toString()})()`], { type: 'application/javascript' });\n    const url = URL.createObjectURL(blob);\n    mediaStreamTrackProcessorWorker = new Worker(url);\n};\nlet mediaStreamTrackProcessorIsSupportedInWorkerCache = null;\nconst mediaStreamTrackProcessorIsSupportedInWorker = async () => {\n    if (mediaStreamTrackProcessorIsSupportedInWorkerCache !== null) {\n        return mediaStreamTrackProcessorIsSupportedInWorkerCache;\n    }\n    if (!mediaStreamTrackProcessorWorker) {\n        initMediaStreamTrackProcessorWorker();\n    }\n    return new Promise((resolve) => {\n        assert(mediaStreamTrackProcessorWorker);\n        const listener = (event) => {\n            const message = event.data;\n            if (message.type === 'support') {\n                mediaStreamTrackProcessorIsSupportedInWorkerCache = message.supported;\n                mediaStreamTrackProcessorWorker.removeEventListener('message', listener);\n                resolve(message.supported);\n            }\n        };\n        mediaStreamTrackProcessorWorker.addEventListener('message', listener);\n    });\n};\nconst sendMessageToMediaStreamTrackProcessorWorker = (message, transfer) => {\n    assert(mediaStreamTrackProcessorWorker);\n    if (transfer) {\n        mediaStreamTrackProcessorWorker.postMessage(message, transfer);\n    }\n    else {\n        mediaStreamTrackProcessorWorker.postMessage(message);\n    }\n};\n/**\n * Base class for subtitle sources - sources for subtitle tracks.\n * @group Media sources\n * @public\n */\nexport class SubtitleSource extends MediaSource {\n    /** Internal constructor. */\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!SUBTITLE_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid subtitle codec '${codec}'. Must be one of: ${SUBTITLE_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * This source can be used to add subtitles from a subtitle text file.\n * @group Media sources\n * @public\n */\nexport class TextSubtitleSource extends SubtitleSource {\n    /** Creates a new {@link TextSubtitleSource} where added text chunks are in the specified `codec`. */\n    constructor(codec) {\n        super(codec);\n        /** @internal */\n        this._error = null;\n        this._parser = new SubtitleParser({\n            codec,\n            output: (cue, metadata) => {\n                void this._connectedTrack?.output._muxer.addSubtitleCue(this._connectedTrack, cue, metadata)\n                    .catch((error) => {\n                    this._error ??= error;\n                });\n            },\n        });\n    }\n    /**\n     * Parses the subtitle text according to the specified codec and adds it to the output track. You don't have to\n     * add the entire subtitle file at once here; you can provide it in chunks.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(text) {\n        if (typeof text !== 'string') {\n            throw new TypeError('text must be a string.');\n        }\n        this._checkForError();\n        this._ensureValidAdd();\n        this._parser.parse(text);\n        return this._connectedTrack.output._muxer.mutex.currentPromise;\n    }\n    /** @internal */\n    _checkForError() {\n        if (this._error) {\n            throw this._error;\n        }\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (!forceClose) {\n            this._checkForError();\n        }\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AsyncMutex, isIso639Dash2LanguageCode } from './misc.js';\nimport { validateMetadataTags, validateTrackDisposition } from './metadata.js';\nimport { OutputFormat } from './output-format.js';\nimport { AudioSource, SubtitleSource, VideoSource } from './media-source.js';\nimport { Target } from './target.js';\n/**\n * List of all track types.\n * @group Miscellaneous\n * @public\n */\nexport const ALL_TRACK_TYPES = ['video', 'audio', 'subtitle'];\nconst validateBaseTrackMetadata = (metadata) => {\n    if (!metadata || typeof metadata !== 'object') {\n        throw new TypeError('metadata must be an object.');\n    }\n    if (metadata.languageCode !== undefined && !isIso639Dash2LanguageCode(metadata.languageCode)) {\n        throw new TypeError('metadata.languageCode, when provided, must be a three-letter, ISO 639-2/T language code.');\n    }\n    if (metadata.name !== undefined && typeof metadata.name !== 'string') {\n        throw new TypeError('metadata.name, when provided, must be a string.');\n    }\n    if (metadata.disposition !== undefined) {\n        validateTrackDisposition(metadata.disposition);\n    }\n    if (metadata.maximumPacketCount !== undefined\n        && (!Number.isInteger(metadata.maximumPacketCount) || metadata.maximumPacketCount < 0)) {\n        throw new TypeError('metadata.maximumPacketCount, when provided, must be a non-negative integer.');\n    }\n};\n/**\n * Main class orchestrating the creation of a new media file.\n * @group Output files\n * @public\n */\nexport class Output {\n    /**\n     * Creates a new instance of {@link Output} which can then be used to create a new media file according to the\n     * specified {@link OutputOptions}.\n     */\n    constructor(options) {\n        /** The current state of the output. */\n        this.state = 'pending';\n        /** @internal */\n        this._tracks = [];\n        /** @internal */\n        this._startPromise = null;\n        /** @internal */\n        this._cancelPromise = null;\n        /** @internal */\n        this._finalizePromise = null;\n        /** @internal */\n        this._mutex = new AsyncMutex();\n        /** @internal */\n        this._metadataTags = {};\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!(options.format instanceof OutputFormat)) {\n            throw new TypeError('options.format must be an OutputFormat.');\n        }\n        if (!(options.target instanceof Target)) {\n            throw new TypeError('options.target must be a Target.');\n        }\n        if (options.target._output) {\n            throw new Error('Target is already used for another output.');\n        }\n        options.target._output = this;\n        this.format = options.format;\n        this.target = options.target;\n        this._writer = options.target._createWriter();\n        this._muxer = options.format._createMuxer(this);\n    }\n    /** Adds a video track to the output with the given source. Can only be called before the output is started. */\n    addVideoTrack(source, metadata = {}) {\n        if (!(source instanceof VideoSource)) {\n            throw new TypeError('source must be a VideoSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        if (metadata.rotation !== undefined && ![0, 90, 180, 270].includes(metadata.rotation)) {\n            throw new TypeError(`Invalid video rotation: ${metadata.rotation}. Has to be 0, 90, 180 or 270.`);\n        }\n        if (!this.format.supportsVideoRotationMetadata && metadata.rotation) {\n            throw new Error(`${this.format._name} does not support video rotation metadata.`);\n        }\n        if (metadata.frameRate !== undefined\n            && (!Number.isFinite(metadata.frameRate) || metadata.frameRate <= 0)) {\n            throw new TypeError(`Invalid video frame rate: ${metadata.frameRate}. Must be a positive number.`);\n        }\n        this._addTrack('video', source, metadata);\n    }\n    /** Adds an audio track to the output with the given source. Can only be called before the output is started. */\n    addAudioTrack(source, metadata = {}) {\n        if (!(source instanceof AudioSource)) {\n            throw new TypeError('source must be an AudioSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        this._addTrack('audio', source, metadata);\n    }\n    /** Adds a subtitle track to the output with the given source. Can only be called before the output is started. */\n    addSubtitleTrack(source, metadata = {}) {\n        if (!(source instanceof SubtitleSource)) {\n            throw new TypeError('source must be a SubtitleSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        this._addTrack('subtitle', source, metadata);\n    }\n    /**\n     * Sets descriptive metadata tags about the media file, such as title, author, date, or cover art. When called\n     * multiple times, only the metadata from the last call will be used.\n     *\n     * Can only be called before the output is started.\n     */\n    setMetadataTags(tags) {\n        validateMetadataTags(tags);\n        if (this.state !== 'pending') {\n            throw new Error('Cannot set metadata tags after output has been started or canceled.');\n        }\n        this._metadataTags = tags;\n    }\n    /** @internal */\n    _addTrack(type, source, metadata) {\n        if (this.state !== 'pending') {\n            throw new Error('Cannot add track after output has been started or canceled.');\n        }\n        if (source._connectedTrack) {\n            throw new Error('Source is already used for a track.');\n        }\n        // Verify maximum track count constraints\n        const supportedTrackCounts = this.format.getSupportedTrackCounts();\n        const presentTracksOfThisType = this._tracks.reduce((count, track) => count + (track.type === type ? 1 : 0), 0);\n        const maxCount = supportedTrackCounts[type].max;\n        if (presentTracksOfThisType === maxCount) {\n            throw new Error(maxCount === 0\n                ? `${this.format._name} does not support ${type} tracks.`\n                : (`${this.format._name} does not support more than ${maxCount} ${type} track`\n                    + `${maxCount === 1 ? '' : 's'}.`));\n        }\n        const maxTotalCount = supportedTrackCounts.total.max;\n        if (this._tracks.length === maxTotalCount) {\n            throw new Error(`${this.format._name} does not support more than ${maxTotalCount} tracks`\n                + `${maxTotalCount === 1 ? '' : 's'} in total.`);\n        }\n        const track = {\n            id: this._tracks.length + 1,\n            output: this,\n            type,\n            source: source,\n            metadata,\n        };\n        if (track.type === 'video') {\n            const supportedVideoCodecs = this.format.getSupportedVideoCodecs();\n            if (supportedVideoCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support video tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedVideoCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` video codecs are: ${supportedVideoCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        else if (track.type === 'audio') {\n            const supportedAudioCodecs = this.format.getSupportedAudioCodecs();\n            if (supportedAudioCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support audio tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedAudioCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` audio codecs are: ${supportedAudioCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        else if (track.type === 'subtitle') {\n            const supportedSubtitleCodecs = this.format.getSupportedSubtitleCodecs();\n            if (supportedSubtitleCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support subtitle tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedSubtitleCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` subtitle codecs are: ${supportedSubtitleCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        this._tracks.push(track);\n        source._connectedTrack = track;\n    }\n    /**\n     * Starts the creation of the output file. This method should be called after all tracks have been added. Only after\n     * the output has started can media samples be added to the tracks.\n     *\n     * @returns A promise that resolves when the output has successfully started and is ready to receive media samples.\n     */\n    async start() {\n        // Verify minimum track count constraints\n        const supportedTrackCounts = this.format.getSupportedTrackCounts();\n        for (const trackType of ALL_TRACK_TYPES) {\n            const presentTracksOfThisType = this._tracks.reduce((count, track) => count + (track.type === trackType ? 1 : 0), 0);\n            const minCount = supportedTrackCounts[trackType].min;\n            if (presentTracksOfThisType < minCount) {\n                throw new Error(minCount === supportedTrackCounts[trackType].max\n                    ? (`${this.format._name} requires exactly ${minCount} ${trackType}`\n                        + ` track${minCount === 1 ? '' : 's'}.`)\n                    : (`${this.format._name} requires at least ${minCount} ${trackType}`\n                        + ` track${minCount === 1 ? '' : 's'}.`));\n            }\n        }\n        const totalMinCount = supportedTrackCounts.total.min;\n        if (this._tracks.length < totalMinCount) {\n            throw new Error(totalMinCount === supportedTrackCounts.total.max\n                ? (`${this.format._name} requires exactly ${totalMinCount} track`\n                    + `${totalMinCount === 1 ? '' : 's'}.`)\n                : (`${this.format._name} requires at least ${totalMinCount} track`\n                    + `${totalMinCount === 1 ? '' : 's'}.`));\n        }\n        if (this.state === 'canceled') {\n            throw new Error('Output has been canceled.');\n        }\n        if (this._startPromise) {\n            console.warn('Output has already been started.');\n            return this._startPromise;\n        }\n        return this._startPromise = (async () => {\n            this.state = 'started';\n            this._writer.start();\n            const release = await this._mutex.acquire();\n            await this._muxer.start();\n            const promises = this._tracks.map(track => track.source._start());\n            await Promise.all(promises);\n            release();\n        })();\n    }\n    /**\n     * Resolves with the full MIME type of the output file, including track codecs.\n     *\n     * The returned promise will resolve only once the precise codec strings of all tracks are known.\n     */\n    getMimeType() {\n        return this._muxer.getMimeType();\n    }\n    /**\n     * Cancels the creation of the output file, releasing internal resources like encoders and preventing further\n     * samples from being added.\n     *\n     * @returns A promise that resolves once all internal resources have been released.\n     */\n    async cancel() {\n        if (this._cancelPromise) {\n            console.warn('Output has already been canceled.');\n            return this._cancelPromise;\n        }\n        else if (this.state === 'finalizing' || this.state === 'finalized') {\n            console.warn('Output has already been finalized.');\n            return;\n        }\n        return this._cancelPromise = (async () => {\n            this.state = 'canceled';\n            const release = await this._mutex.acquire();\n            const promises = this._tracks.map(x => x.source._flushOrWaitForOngoingClose(true)); // Force close\n            await Promise.all(promises);\n            await this._writer.close();\n            release();\n        })();\n    }\n    /**\n     * Finalizes the output file. This method must be called after all media samples across all tracks have been added.\n     * Once the Promise returned by this method completes, the output file is ready.\n     */\n    async finalize() {\n        if (this.state === 'pending') {\n            throw new Error('Cannot finalize before starting.');\n        }\n        if (this.state === 'canceled') {\n            throw new Error('Cannot finalize after canceling.');\n        }\n        if (this._finalizePromise) {\n            console.warn('Output has already been finalized.');\n            return this._finalizePromise;\n        }\n        return this._finalizePromise = (async () => {\n            this.state = 'finalizing';\n            const release = await this._mutex.acquire();\n            const promises = this._tracks.map(x => x.source._flushOrWaitForOngoingClose(false));\n            await Promise.all(promises);\n            await this._muxer.finalize();\n            await this._writer.flush();\n            await this._writer.finalize();\n            this.state = 'finalized';\n            release();\n        })();\n    }\n}\n", "/*!\n * Copyright (c) 2025-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AUDIO_CODECS, NON_PCM_AUDIO_CODECS, VIDEO_CODECS, } from './codec.js';\nimport { getEncodableAudioCodecs, getFirstEncodableVideoCodec, Quality, QUALITY_HIGH, } from './encode.js';\nimport { Input } from './input.js';\nimport { AudioSampleSink, CanvasSink, EncodedPacketSink, VideoSampleSink, } from './media-sink.js';\nimport { EncodedVideoPacketSource, EncodedAudioPacketSource, VideoSampleSource, AudioSampleSource, } from './media-source.js';\nimport { assert, clamp, isIso639Dash2LanguageCode, normalizeRotation, promiseWithResolvers, } from './misc.js';\nimport { Output } from './output.js';\nimport { Mp4OutputFormat } from './output-format.js';\nimport { AudioSample, clampCropRectangle, validateCropRectangle, VideoSample } from './sample.js';\nimport { validateMetadataTags } from './metadata.js';\nimport { NullTarget } from './target.js';\nconst validateVideoOptions = (videoOptions) => {\n    if (videoOptions !== undefined && (!videoOptions || typeof videoOptions !== 'object')) {\n        throw new TypeError('options.video, when provided, must be an object.');\n    }\n    if (videoOptions?.discard !== undefined && typeof videoOptions.discard !== 'boolean') {\n        throw new TypeError('options.video.discard, when provided, must be a boolean.');\n    }\n    if (videoOptions?.forceTranscode !== undefined && typeof videoOptions.forceTranscode !== 'boolean') {\n        throw new TypeError('options.video.forceTranscode, when provided, must be a boolean.');\n    }\n    if (videoOptions?.codec !== undefined && !VIDEO_CODECS.includes(videoOptions.codec)) {\n        throw new TypeError(`options.video.codec, when provided, must be one of: ${VIDEO_CODECS.join(', ')}.`);\n    }\n    if (videoOptions?.bitrate !== undefined\n        && !(videoOptions.bitrate instanceof Quality)\n        && (!Number.isInteger(videoOptions.bitrate) || videoOptions.bitrate <= 0)) {\n        throw new TypeError('options.video.bitrate, when provided, must be a positive integer or a quality.');\n    }\n    if (videoOptions?.width !== undefined\n        && (!Number.isInteger(videoOptions.width) || videoOptions.width <= 0)) {\n        throw new TypeError('options.video.width, when provided, must be a positive integer.');\n    }\n    if (videoOptions?.height !== undefined\n        && (!Number.isInteger(videoOptions.height) || videoOptions.height <= 0)) {\n        throw new TypeError('options.video.height, when provided, must be a positive integer.');\n    }\n    if (videoOptions?.fit !== undefined && !['fill', 'contain', 'cover'].includes(videoOptions.fit)) {\n        throw new TypeError('options.video.fit, when provided, must be one of \\'fill\\', \\'contain\\', or \\'cover\\'.');\n    }\n    if (videoOptions?.width !== undefined\n        && videoOptions.height !== undefined\n        && videoOptions.fit === undefined) {\n        throw new TypeError('When both options.video.width and options.video.height are provided, options.video.fit must also be'\n            + ' provided.');\n    }\n    if (videoOptions?.rotate !== undefined && ![0, 90, 180, 270].includes(videoOptions.rotate)) {\n        throw new TypeError('options.video.rotate, when provided, must be 0, 90, 180 or 270.');\n    }\n    if (videoOptions?.allowRotationMetadata !== undefined && typeof videoOptions.allowRotationMetadata !== 'boolean') {\n        throw new TypeError('options.video.allowRotationMetadata, when provided, must be a boolean.');\n    }\n    if (videoOptions?.crop !== undefined) {\n        validateCropRectangle(videoOptions.crop, 'options.video.');\n    }\n    if (videoOptions?.frameRate !== undefined\n        && (!Number.isFinite(videoOptions.frameRate) || videoOptions.frameRate <= 0)) {\n        throw new TypeError('options.video.frameRate, when provided, must be a finite positive number.');\n    }\n    if (videoOptions?.alpha !== undefined && !['discard', 'keep'].includes(videoOptions.alpha)) {\n        throw new TypeError('options.video.alpha, when provided, must be either \\'discard\\' or \\'keep\\'.');\n    }\n    if (videoOptions?.keyFrameInterval !== undefined\n        && (!Number.isFinite(videoOptions.keyFrameInterval) || videoOptions.keyFrameInterval < 0)) {\n        throw new TypeError('options.video.keyFrameInterval, when provided, must be a non-negative number.');\n    }\n    if (videoOptions?.process !== undefined && typeof videoOptions.process !== 'function') {\n        throw new TypeError('options.video.process, when provided, must be a function.');\n    }\n    if (videoOptions?.processedWidth !== undefined\n        && (!Number.isInteger(videoOptions.processedWidth) || videoOptions.processedWidth <= 0)) {\n        throw new TypeError('options.video.processedWidth, when provided, must be a positive integer.');\n    }\n    if (videoOptions?.processedHeight !== undefined\n        && (!Number.isInteger(videoOptions.processedHeight) || videoOptions.processedHeight <= 0)) {\n        throw new TypeError('options.video.processedHeight, when provided, must be a positive integer.');\n    }\n    if (videoOptions?.hardwareAcceleration !== undefined\n        && !['no-preference', 'prefer-hardware', 'prefer-software'].includes(videoOptions.hardwareAcceleration)) {\n        throw new TypeError('options.video.hardwareAcceleration, when provided, must be \\'no-preference\\', \\'prefer-hardware\\' or'\n            + ' \\'prefer-software\\'.');\n    }\n};\nconst validateAudioOptions = (audioOptions) => {\n    if (audioOptions !== undefined && (!audioOptions || typeof audioOptions !== 'object')) {\n        throw new TypeError('options.audio, when provided, must be an object.');\n    }\n    if (audioOptions?.discard !== undefined && typeof audioOptions.discard !== 'boolean') {\n        throw new TypeError('options.audio.discard, when provided, must be a boolean.');\n    }\n    if (audioOptions?.forceTranscode !== undefined && typeof audioOptions.forceTranscode !== 'boolean') {\n        throw new TypeError('options.audio.forceTranscode, when provided, must be a boolean.');\n    }\n    if (audioOptions?.codec !== undefined && !AUDIO_CODECS.includes(audioOptions.codec)) {\n        throw new TypeError(`options.audio.codec, when provided, must be one of: ${AUDIO_CODECS.join(', ')}.`);\n    }\n    if (audioOptions?.bitrate !== undefined\n        && !(audioOptions.bitrate instanceof Quality)\n        && (!Number.isInteger(audioOptions.bitrate) || audioOptions.bitrate <= 0)) {\n        throw new TypeError('options.audio.bitrate, when provided, must be a positive integer or a quality.');\n    }\n    if (audioOptions?.numberOfChannels !== undefined\n        && (!Number.isInteger(audioOptions.numberOfChannels) || audioOptions.numberOfChannels <= 0)) {\n        throw new TypeError('options.audio.numberOfChannels, when provided, must be a positive integer.');\n    }\n    if (audioOptions?.sampleRate !== undefined\n        && (!Number.isInteger(audioOptions.sampleRate) || audioOptions.sampleRate <= 0)) {\n        throw new TypeError('options.audio.sampleRate, when provided, must be a positive integer.');\n    }\n    if (audioOptions?.process !== undefined && typeof audioOptions.process !== 'function') {\n        throw new TypeError('options.audio.process, when provided, must be a function.');\n    }\n    if (audioOptions?.processedNumberOfChannels !== undefined\n        && (!Number.isInteger(audioOptions.processedNumberOfChannels) || audioOptions.processedNumberOfChannels <= 0)) {\n        throw new TypeError('options.audio.processedNumberOfChannels, when provided, must be a positive integer.');\n    }\n    if (audioOptions?.processedSampleRate !== undefined\n        && (!Number.isInteger(audioOptions.processedSampleRate) || audioOptions.processedSampleRate <= 0)) {\n        throw new TypeError('options.audio.processedSampleRate, when provided, must be a positive integer.');\n    }\n};\nconst FALLBACK_NUMBER_OF_CHANNELS = 2;\nconst FALLBACK_SAMPLE_RATE = 48000;\n/**\n * Represents a media file conversion process, used to convert one media file into another. In addition to conversion,\n * this class can be used to resize and rotate video, resample audio, drop tracks, or trim to a specific time range.\n * @group Conversion\n * @public\n */\nexport class Conversion {\n    /** Initializes a new conversion process without starting the conversion. */\n    static async init(options) {\n        const conversion = new Conversion(options);\n        await conversion._init();\n        return conversion;\n    }\n    /** Creates a new Conversion instance (duh). */\n    constructor(options) {\n        /** @internal */\n        this._addedCounts = {\n            video: 0,\n            audio: 0,\n            subtitle: 0,\n        };\n        /** @internal */\n        this._totalTrackCount = 0;\n        /** @internal */\n        this._trackPromises = [];\n        /** @internal */\n        this._executed = false;\n        /** @internal */\n        this._synchronizer = new TrackSynchronizer();\n        /** @internal */\n        this._totalDuration = null;\n        /** @internal */\n        this._maxTimestamps = new Map(); // Track ID -> timestamp\n        /** @internal */\n        this._canceled = false;\n        /**\n         * A callback that is fired whenever the conversion progresses. Returns a number between 0 and 1, indicating the\n         * completion of the conversion. Note that a progress of 1 doesn't necessarily mean the conversion is complete;\n         * the conversion is complete once `execute()` resolves.\n         *\n         * In order for progress to be computed, this property must be set before `execute` is called.\n         */\n        this.onProgress = undefined;\n        /** @internal */\n        this._computeProgress = false;\n        /** @internal */\n        this._lastProgress = 0;\n        /**\n         * Whether this conversion, as it has been configured, is valid and can be executed. If this field is `false`, check\n         * the `discardedTracks` field for reasons.\n         */\n        this.isValid = false;\n        /** The list of tracks that are included in the output file. */\n        this.utilizedTracks = [];\n        /** The list of tracks from the input file that have been discarded, alongside the discard reason. */\n        this.discardedTracks = [];\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!(options.input instanceof Input)) {\n            throw new TypeError('options.input must be an Input.');\n        }\n        if (!(options.output instanceof Output)) {\n            throw new TypeError('options.output must be an Output.');\n        }\n        if (options.output._tracks.length > 0\n            || Object.keys(options.output._metadataTags).length > 0\n            || options.output.state !== 'pending') {\n            throw new TypeError('options.output must be fresh: no tracks or metadata tags added and not started.');\n        }\n        if (typeof options.video !== 'function') {\n            validateVideoOptions(options.video);\n        }\n        else {\n            // We'll validate the return value later\n        }\n        if (typeof options.audio !== 'function') {\n            validateAudioOptions(options.audio);\n        }\n        else {\n            // We'll validate the return value later\n        }\n        if (options.trim !== undefined && (!options.trim || typeof options.trim !== 'object')) {\n            throw new TypeError('options.trim, when provided, must be an object.');\n        }\n        if (options.trim?.start !== undefined && (!Number.isFinite(options.trim.start) || options.trim.start < 0)) {\n            throw new TypeError('options.trim.start, when provided, must be a non-negative number.');\n        }\n        if (options.trim?.end !== undefined && (!Number.isFinite(options.trim.end) || options.trim.end < 0)) {\n            throw new TypeError('options.trim.end, when provided, must be a non-negative number.');\n        }\n        if (options.trim?.start !== undefined\n            && options.trim.end !== undefined\n            && options.trim.start >= options.trim.end) {\n            throw new TypeError('options.trim.start must be less than options.trim.end.');\n        }\n        if (options.tags !== undefined\n            && (typeof options.tags !== 'object' || !options.tags)\n            && typeof options.tags !== 'function') {\n            throw new TypeError('options.tags, when provided, must be an object or a function.');\n        }\n        if (typeof options.tags === 'object') {\n            validateMetadataTags(options.tags);\n        }\n        if (options.showWarnings !== undefined && typeof options.showWarnings !== 'boolean') {\n            throw new TypeError('options.showWarnings, when provided, must be a boolean.');\n        }\n        this._options = options;\n        this.input = options.input;\n        this.output = options.output;\n        this._startTimestamp = options.trim?.start ?? 0;\n        this._endTimestamp = options.trim?.end ?? Infinity;\n        const { promise: started, resolve: start } = promiseWithResolvers();\n        this._started = started;\n        this._start = start;\n    }\n    /** @internal */\n    async _init() {\n        const inputTracks = await this.input.getTracks();\n        const outputTrackCounts = this.output.format.getSupportedTrackCounts();\n        let nVideo = 1;\n        let nAudio = 1;\n        for (const track of inputTracks) {\n            let trackOptions = undefined;\n            if (track.isVideoTrack()) {\n                if (this._options.video) {\n                    if (typeof this._options.video === 'function') {\n                        trackOptions = await this._options.video(track, nVideo);\n                        validateVideoOptions(trackOptions);\n                        nVideo++;\n                    }\n                    else {\n                        trackOptions = this._options.video;\n                    }\n                }\n            }\n            else if (track.isAudioTrack()) {\n                if (this._options.audio) {\n                    if (typeof this._options.audio === 'function') {\n                        trackOptions = await this._options.audio(track, nAudio);\n                        validateAudioOptions(trackOptions);\n                        nAudio++;\n                    }\n                    else {\n                        trackOptions = this._options.audio;\n                    }\n                }\n            }\n            else {\n                assert(false);\n            }\n            if (trackOptions?.discard) {\n                this.discardedTracks.push({\n                    track,\n                    reason: 'discarded_by_user',\n                });\n                continue;\n            }\n            if (this._totalTrackCount === outputTrackCounts.total.max) {\n                this.discardedTracks.push({\n                    track,\n                    reason: 'max_track_count_reached',\n                });\n                continue;\n            }\n            if (this._addedCounts[track.type] === outputTrackCounts[track.type].max) {\n                this.discardedTracks.push({\n                    track,\n                    reason: 'max_track_count_of_type_reached',\n                });\n                continue;\n            }\n            if (track.isVideoTrack()) {\n                await this._processVideoTrack(track, (trackOptions ?? {}));\n            }\n            else if (track.isAudioTrack()) {\n                await this._processAudioTrack(track, (trackOptions ?? {}));\n            }\n        }\n        // Now, let's deal with metadata tags\n        const inputTags = await this.input.getMetadataTags();\n        let outputTags;\n        if (this._options.tags) {\n            const result = typeof this._options.tags === 'function'\n                ? await this._options.tags(inputTags)\n                : this._options.tags;\n            validateMetadataTags(result);\n            outputTags = result;\n        }\n        else {\n            outputTags = inputTags;\n        }\n        // Somewhat dirty but pragmatic\n        const inputAndOutputFormatMatch = (await this.input.getFormat()).mimeType === this.output.format.mimeType;\n        const rawTagsAreUnchanged = inputTags.raw === outputTags.raw;\n        if (inputTags.raw && rawTagsAreUnchanged && !inputAndOutputFormatMatch) {\n            // If the input and output formats aren't the same, copying over raw metadata tags makes no sense and only\n            // results in junk tags, so let's cut them out.\n            delete outputTags.raw;\n        }\n        this.output.setMetadataTags(outputTags);\n        // Let's check if the conversion can actually be executed\n        this.isValid = this._totalTrackCount >= outputTrackCounts.total.min\n            && this._addedCounts.video >= outputTrackCounts.video.min\n            && this._addedCounts.audio >= outputTrackCounts.audio.min\n            && this._addedCounts.subtitle >= outputTrackCounts.subtitle.min;\n        if (this._options.showWarnings ?? true) {\n            const warnElements = [];\n            const unintentionallyDiscardedTracks = this.discardedTracks.filter(x => x.reason !== 'discarded_by_user');\n            if (unintentionallyDiscardedTracks.length > 0) {\n                // Let's give the user a notice/warning about discarded tracks so they aren't confused\n                warnElements.push('Some tracks had to be discarded from the conversion:', unintentionallyDiscardedTracks);\n            }\n            if (!this.isValid) {\n                warnElements.push('\\n\\n' + this._getInvalidityExplanation().join(''));\n            }\n            if (warnElements.length > 0) {\n                console.warn(...warnElements);\n            }\n        }\n    }\n    /** @internal */\n    _getInvalidityExplanation() {\n        const elements = [];\n        if (this.discardedTracks.length === 0) {\n            elements.push('Due to missing tracks, this conversion cannot be executed.');\n        }\n        else {\n            const encodabilityIsTheProblem = this.discardedTracks.every(x => x.reason === 'discarded_by_user' || x.reason === 'no_encodable_target_codec');\n            elements.push('Due to discarded tracks, this conversion cannot be executed.');\n            if (encodabilityIsTheProblem) {\n                const codecs = this.discardedTracks.flatMap((x) => {\n                    if (x.reason === 'discarded_by_user')\n                        return [];\n                    if (x.track.type === 'video') {\n                        return this.output.format.getSupportedVideoCodecs();\n                    }\n                    else if (x.track.type === 'audio') {\n                        return this.output.format.getSupportedAudioCodecs();\n                    }\n                    else {\n                        return this.output.format.getSupportedSubtitleCodecs();\n                    }\n                });\n                if (codecs.length === 1) {\n                    elements.push(`\\nTracks were discarded because your environment is not able to encode '${codecs[0]}'.`);\n                }\n                else {\n                    elements.push('\\nTracks were discarded because your environment is not able to encode any of the following'\n                        + ` codecs: ${codecs.map(x => `'${x}'`).join(', ')}.`);\n                }\n                if (codecs.includes('mp3')) {\n                    elements.push(`\\nThe @mediabunny/mp3-encoder extension package provides support for encoding MP3.`);\n                }\n            }\n            else {\n                elements.push('\\nCheck the discardedTracks field for more info.');\n            }\n        }\n        return elements;\n    }\n    /**\n     * Executes the conversion process. Resolves once conversion is complete.\n     *\n     * Will throw if `isValid` is `false`.\n     */\n    async execute() {\n        if (!this.isValid) {\n            throw new Error('Cannot execute this conversion because its output configuration is invalid. Make sure to always check'\n                + ' the isValid field before executing a conversion.\\n'\n                + this._getInvalidityExplanation().join(''));\n        }\n        if (this._executed) {\n            throw new Error('Conversion cannot be executed twice.');\n        }\n        this._executed = true;\n        if (this.onProgress) {\n            this._computeProgress = true;\n            this._totalDuration = Math.min((await this.input.computeDuration()) - this._startTimestamp, this._endTimestamp - this._startTimestamp);\n            for (const track of this.utilizedTracks) {\n                this._maxTimestamps.set(track.id, 0);\n            }\n            this.onProgress?.(0);\n        }\n        await this.output.start();\n        this._start();\n        try {\n            await Promise.all(this._trackPromises);\n        }\n        catch (error) {\n            if (!this._canceled) {\n                // Make sure to cancel to stop other encoding processes and clean up resources\n                void this.cancel();\n            }\n            throw error;\n        }\n        if (this._canceled) {\n            await new Promise(() => { }); // Never resolve\n        }\n        await this.output.finalize();\n        if (this._computeProgress) {\n            this.onProgress?.(1);\n        }\n    }\n    /** Cancels the conversion process. Does nothing if the conversion is already complete. */\n    async cancel() {\n        if (this.output.state === 'finalizing' || this.output.state === 'finalized') {\n            return;\n        }\n        if (this._canceled) {\n            console.warn('Conversion already canceled.');\n            return;\n        }\n        this._canceled = true;\n        await this.output.cancel();\n    }\n    /** @internal */\n    async _processVideoTrack(track, trackOptions) {\n        const sourceCodec = track.codec;\n        if (!sourceCodec) {\n            this.discardedTracks.push({\n                track,\n                reason: 'unknown_source_codec',\n            });\n            return;\n        }\n        let videoSource;\n        const totalRotation = normalizeRotation(track.rotation + (trackOptions.rotate ?? 0));\n        const canUseRotationMetadata = this.output.format.supportsVideoRotationMetadata\n            && (trackOptions.allowRotationMetadata ?? true);\n        const [rotatedWidth, rotatedHeight] = totalRotation % 180 === 0\n            ? [track.codedWidth, track.codedHeight]\n            : [track.codedHeight, track.codedWidth];\n        const crop = trackOptions.crop;\n        if (crop) {\n            clampCropRectangle(crop, rotatedWidth, rotatedHeight);\n        }\n        const [originalWidth, originalHeight] = crop\n            ? [crop.width, crop.height]\n            : [rotatedWidth, rotatedHeight];\n        let width = originalWidth;\n        let height = originalHeight;\n        const aspectRatio = width / height;\n        // A lot of video encoders require that the dimensions be multiples of 2\n        const ceilToMultipleOfTwo = (value) => Math.ceil(value / 2) * 2;\n        if (trackOptions.width !== undefined && trackOptions.height === undefined) {\n            width = ceilToMultipleOfTwo(trackOptions.width);\n            height = ceilToMultipleOfTwo(Math.round(width / aspectRatio));\n        }\n        else if (trackOptions.width === undefined && trackOptions.height !== undefined) {\n            height = ceilToMultipleOfTwo(trackOptions.height);\n            width = ceilToMultipleOfTwo(Math.round(height * aspectRatio));\n        }\n        else if (trackOptions.width !== undefined && trackOptions.height !== undefined) {\n            width = ceilToMultipleOfTwo(trackOptions.width);\n            height = ceilToMultipleOfTwo(trackOptions.height);\n        }\n        const firstTimestamp = await track.getFirstTimestamp();\n        const needsTranscode = !!trackOptions.forceTranscode\n            || this._startTimestamp > 0\n            || firstTimestamp < 0\n            || !!trackOptions.frameRate\n            || trackOptions.keyFrameInterval !== undefined\n            || trackOptions.process !== undefined;\n        let needsRerender = width !== originalWidth\n            || height !== originalHeight\n            // TODO This is suboptimal: Forcing a rerender when both rotation and process are set is not\n            // performance-optimal, but right now there's no other way because we can't change the track rotation\n            // metadata after the output has already started. Should be possible with API changes in v2, though!\n            || (totalRotation !== 0 && (!canUseRotationMetadata || trackOptions.process !== undefined))\n            || !!crop;\n        const alpha = trackOptions.alpha ?? 'discard';\n        let videoCodecs = this.output.format.getSupportedVideoCodecs();\n        if (!needsTranscode\n            && !trackOptions.bitrate\n            && !needsRerender\n            && videoCodecs.includes(sourceCodec)\n            && (!trackOptions.codec || trackOptions.codec === sourceCodec)) {\n            // Fast path, we can simply copy over the encoded packets\n            const source = new EncodedVideoPacketSource(sourceCodec);\n            videoSource = source;\n            this._trackPromises.push((async () => {\n                await this._started;\n                const sink = new EncodedPacketSink(track);\n                const decoderConfig = await track.getDecoderConfig();\n                const meta = { decoderConfig: decoderConfig ?? undefined };\n                const endPacket = Number.isFinite(this._endTimestamp)\n                    ? await sink.getPacket(this._endTimestamp, { metadataOnly: true }) ?? undefined\n                    : undefined;\n                for await (const packet of sink.packets(undefined, endPacket, { verifyKeyPackets: true })) {\n                    if (this._canceled) {\n                        return;\n                    }\n                    if (alpha === 'discard') {\n                        // Feels hacky given that the rest of the packet is readonly. But, works for now.\n                        delete packet.sideData.alpha;\n                        delete packet.sideData.alphaByteLength;\n                    }\n                    this._reportProgress(track.id, packet.timestamp);\n                    await source.add(packet, meta);\n                    if (this._synchronizer.shouldWait(track.id, packet.timestamp)) {\n                        await this._synchronizer.wait(packet.timestamp);\n                    }\n                }\n                source.close();\n                this._synchronizer.closeTrack(track.id);\n            })());\n        }\n        else {\n            // We need to decode & reencode the video\n            const canDecode = await track.canDecode();\n            if (!canDecode) {\n                this.discardedTracks.push({\n                    track,\n                    reason: 'undecodable_source_codec',\n                });\n                return;\n            }\n            if (trackOptions.codec) {\n                videoCodecs = videoCodecs.filter(codec => codec === trackOptions.codec);\n            }\n            const bitrate = trackOptions.bitrate ?? QUALITY_HIGH;\n            const encodableCodec = await getFirstEncodableVideoCodec(videoCodecs, {\n                width: trackOptions.process && trackOptions.processedWidth\n                    ? trackOptions.processedWidth\n                    : width,\n                height: trackOptions.process && trackOptions.processedHeight\n                    ? trackOptions.processedHeight\n                    : height,\n                bitrate,\n            });\n            if (!encodableCodec) {\n                this.discardedTracks.push({\n                    track,\n                    reason: 'no_encodable_target_codec',\n                });\n                return;\n            }\n            const encodingConfig = {\n                codec: encodableCodec,\n                bitrate,\n                keyFrameInterval: trackOptions.keyFrameInterval,\n                sizeChangeBehavior: trackOptions.fit ?? 'passThrough',\n                alpha,\n                hardwareAcceleration: trackOptions.hardwareAcceleration,\n            };\n            const source = new VideoSampleSource(encodingConfig);\n            videoSource = source;\n            if (!needsRerender) {\n                // If we're directly passing decoded samples back to the encoder, sometimes the encoder may error due\n                // to lack of support of certain video frame formats, like when HDR is at play. To check for this, we\n                // first try to pass a single frame to the encoder to see how it behaves. If it throws, we then fall\n                // back to the rerender path.\n                //\n                // Creating a new temporary Output is sort of hacky, but due to a lack of an isolated encoder API right\n                // now, this is the simplest way. Will refactor in the future! TODO\n                const tempOutput = new Output({\n                    format: new Mp4OutputFormat(), // Supports all video codecs\n                    target: new NullTarget(),\n                });\n                const tempSource = new VideoSampleSource(encodingConfig);\n                tempOutput.addVideoTrack(tempSource);\n                await tempOutput.start();\n                const sink = new VideoSampleSink(track);\n                const firstSample = await sink.getSample(firstTimestamp); // Let's just use the first sample\n                if (firstSample) {\n                    try {\n                        await tempSource.add(firstSample);\n                        firstSample.close();\n                        await tempOutput.finalize();\n                    }\n                    catch (error) {\n                        console.info('Error when probing encoder support. Falling back to rerender path.', error);\n                        needsRerender = true;\n                        void tempOutput.cancel();\n                    }\n                }\n                else {\n                    await tempOutput.cancel();\n                }\n            }\n            if (needsRerender) {\n                this._trackPromises.push((async () => {\n                    await this._started;\n                    const sink = new CanvasSink(track, {\n                        width,\n                        height,\n                        fit: trackOptions.fit ?? 'fill',\n                        rotation: totalRotation, // Bake the rotation into the output\n                        crop: trackOptions.crop,\n                        poolSize: 1,\n                        alpha: alpha === 'keep',\n                    });\n                    const iterator = sink.canvases(this._startTimestamp, this._endTimestamp);\n                    const frameRate = trackOptions.frameRate;\n                    let lastCanvas = null;\n                    let lastCanvasTimestamp = null;\n                    let lastCanvasEndTimestamp = null;\n                    /** Repeats the last sample to pad out the time until the specified timestamp. */\n                    const padFrames = async (until) => {\n                        assert(lastCanvas);\n                        assert(frameRate !== undefined);\n                        const frameDifference = Math.round((until - lastCanvasTimestamp) * frameRate);\n                        for (let i = 1; i < frameDifference; i++) {\n                            const sample = new VideoSample(lastCanvas, {\n                                timestamp: lastCanvasTimestamp + i / frameRate,\n                                duration: 1 / frameRate,\n                            });\n                            await this._registerVideoSample(track, trackOptions, source, sample);\n                            sample.close();\n                        }\n                    };\n                    for await (const { canvas, timestamp, duration } of iterator) {\n                        if (this._canceled) {\n                            return;\n                        }\n                        let adjustedSampleTimestamp = Math.max(timestamp - this._startTimestamp, 0);\n                        lastCanvasEndTimestamp = adjustedSampleTimestamp + duration;\n                        if (frameRate !== undefined) {\n                            // Logic for skipping/repeating frames when a frame rate is set\n                            const alignedTimestamp = Math.floor(adjustedSampleTimestamp * frameRate) / frameRate;\n                            if (lastCanvas !== null) {\n                                if (alignedTimestamp <= lastCanvasTimestamp) {\n                                    lastCanvas = canvas;\n                                    lastCanvasTimestamp = alignedTimestamp;\n                                    // Skip this sample, since we already added one for this frame\n                                    continue;\n                                }\n                                else {\n                                    // Check if we may need to repeat the previous frame\n                                    await padFrames(alignedTimestamp);\n                                }\n                            }\n                            adjustedSampleTimestamp = alignedTimestamp;\n                        }\n                        const sample = new VideoSample(canvas, {\n                            timestamp: adjustedSampleTimestamp,\n                            duration: frameRate !== undefined ? 1 / frameRate : duration,\n                        });\n                        await this._registerVideoSample(track, trackOptions, source, sample);\n                        sample.close();\n                        if (frameRate !== undefined) {\n                            lastCanvas = canvas;\n                            lastCanvasTimestamp = adjustedSampleTimestamp;\n                        }\n                    }\n                    if (lastCanvas) {\n                        assert(lastCanvasEndTimestamp !== null);\n                        assert(frameRate !== undefined);\n                        // If necessary, pad until the end timestamp of the last sample\n                        await padFrames(Math.floor(lastCanvasEndTimestamp * frameRate) / frameRate);\n                    }\n                    source.close();\n                    this._synchronizer.closeTrack(track.id);\n                })());\n            }\n            else {\n                this._trackPromises.push((async () => {\n                    await this._started;\n                    const sink = new VideoSampleSink(track);\n                    const frameRate = trackOptions.frameRate;\n                    let lastSample = null;\n                    let lastSampleTimestamp = null;\n                    let lastSampleEndTimestamp = null;\n                    /** Repeats the last sample to pad out the time until the specified timestamp. */\n                    const padFrames = async (until) => {\n                        assert(lastSample);\n                        assert(frameRate !== undefined);\n                        const frameDifference = Math.round((until - lastSampleTimestamp) * frameRate);\n                        for (let i = 1; i < frameDifference; i++) {\n                            lastSample.setTimestamp(lastSampleTimestamp + i / frameRate);\n                            lastSample.setDuration(1 / frameRate);\n                            await this._registerVideoSample(track, trackOptions, source, lastSample);\n                        }\n                        lastSample.close();\n                    };\n                    for await (const sample of sink.samples(this._startTimestamp, this._endTimestamp)) {\n                        if (this._canceled) {\n                            lastSample?.close();\n                            return;\n                        }\n                        let adjustedSampleTimestamp = Math.max(sample.timestamp - this._startTimestamp, 0);\n                        lastSampleEndTimestamp = adjustedSampleTimestamp + sample.duration;\n                        if (frameRate !== undefined) {\n                            // Logic for skipping/repeating frames when a frame rate is set\n                            const alignedTimestamp = Math.floor(adjustedSampleTimestamp * frameRate) / frameRate;\n                            if (lastSample !== null) {\n                                if (alignedTimestamp <= lastSampleTimestamp) {\n                                    lastSample.close();\n                                    lastSample = sample;\n                                    lastSampleTimestamp = alignedTimestamp;\n                                    // Skip this sample, since we already added one for this frame\n                                    continue;\n                                }\n                                else {\n                                    // Check if we may need to repeat the previous frame\n                                    await padFrames(alignedTimestamp);\n                                }\n                            }\n                            adjustedSampleTimestamp = alignedTimestamp;\n                            sample.setDuration(1 / frameRate);\n                        }\n                        sample.setTimestamp(adjustedSampleTimestamp);\n                        await this._registerVideoSample(track, trackOptions, source, sample);\n                        if (frameRate !== undefined) {\n                            lastSample = sample;\n                            lastSampleTimestamp = adjustedSampleTimestamp;\n                        }\n                        else {\n                            sample.close();\n                        }\n                    }\n                    if (lastSample) {\n                        assert(lastSampleEndTimestamp !== null);\n                        assert(frameRate !== undefined);\n                        // If necessary, pad until the end timestamp of the last sample\n                        await padFrames(Math.floor(lastSampleEndTimestamp * frameRate) / frameRate);\n                    }\n                    source.close();\n                    this._synchronizer.closeTrack(track.id);\n                })());\n            }\n        }\n        this.output.addVideoTrack(videoSource, {\n            frameRate: trackOptions.frameRate,\n            // TODO: This condition can be removed when all demuxers properly homogenize to BCP47 in v2\n            languageCode: isIso639Dash2LanguageCode(track.languageCode) ? track.languageCode : undefined,\n            name: track.name ?? undefined,\n            disposition: track.disposition,\n            rotation: needsRerender ? 0 : totalRotation, // Rerendering will bake the rotation into the output\n        });\n        this._addedCounts.video++;\n        this._totalTrackCount++;\n        this.utilizedTracks.push(track);\n    }\n    /** @internal */\n    async _registerVideoSample(track, trackOptions, source, sample) {\n        if (this._canceled) {\n            return;\n        }\n        this._reportProgress(track.id, sample.timestamp);\n        let finalSamples;\n        if (!trackOptions.process) {\n            finalSamples = [sample];\n        }\n        else {\n            let processed = trackOptions.process(sample);\n            if (processed instanceof Promise)\n                processed = await processed;\n            if (!Array.isArray(processed)) {\n                processed = processed === null ? [] : [processed];\n            }\n            finalSamples = processed.map((x) => {\n                if (x instanceof VideoSample) {\n                    return x;\n                }\n                if (typeof VideoFrame !== 'undefined' && x instanceof VideoFrame) {\n                    return new VideoSample(x);\n                }\n                // Calling the VideoSample constructor here will automatically handle input validation for us\n                // (it throws for any non-legal argument).\n                return new VideoSample(x, {\n                    timestamp: sample.timestamp,\n                    duration: sample.duration,\n                });\n            });\n        }\n        for (const finalSample of finalSamples) {\n            if (this._canceled) {\n                break;\n            }\n            await source.add(finalSample);\n            if (this._synchronizer.shouldWait(track.id, finalSample.timestamp)) {\n                await this._synchronizer.wait(finalSample.timestamp);\n            }\n        }\n        for (const finalSample of finalSamples) {\n            if (finalSample !== sample) {\n                finalSample.close();\n            }\n        }\n    }\n    /** @internal */\n    async _processAudioTrack(track, trackOptions) {\n        const sourceCodec = track.codec;\n        if (!sourceCodec) {\n            this.discardedTracks.push({\n                track,\n                reason: 'unknown_source_codec',\n            });\n            return;\n        }\n        let audioSource;\n        const originalNumberOfChannels = track.numberOfChannels;\n        const originalSampleRate = track.sampleRate;\n        const firstTimestamp = await track.getFirstTimestamp();\n        let numberOfChannels = trackOptions.numberOfChannels ?? originalNumberOfChannels;\n        let sampleRate = trackOptions.sampleRate ?? originalSampleRate;\n        let needsResample = numberOfChannels !== originalNumberOfChannels\n            || sampleRate !== originalSampleRate\n            || this._startTimestamp > 0\n            || firstTimestamp < 0;\n        let audioCodecs = this.output.format.getSupportedAudioCodecs();\n        if (!trackOptions.forceTranscode\n            && !trackOptions.bitrate\n            && !needsResample\n            && audioCodecs.includes(sourceCodec)\n            && (!trackOptions.codec || trackOptions.codec === sourceCodec)\n            && !trackOptions.process) {\n            // Fast path, we can simply copy over the encoded packets\n            const source = new EncodedAudioPacketSource(sourceCodec);\n            audioSource = source;\n            this._trackPromises.push((async () => {\n                await this._started;\n                const sink = new EncodedPacketSink(track);\n                const decoderConfig = await track.getDecoderConfig();\n                const meta = { decoderConfig: decoderConfig ?? undefined };\n                const endPacket = Number.isFinite(this._endTimestamp)\n                    ? await sink.getPacket(this._endTimestamp, { metadataOnly: true }) ?? undefined\n                    : undefined;\n                for await (const packet of sink.packets(undefined, endPacket)) {\n                    if (this._canceled) {\n                        return;\n                    }\n                    this._reportProgress(track.id, packet.timestamp);\n                    await source.add(packet, meta);\n                    if (this._synchronizer.shouldWait(track.id, packet.timestamp)) {\n                        await this._synchronizer.wait(packet.timestamp);\n                    }\n                }\n                source.close();\n                this._synchronizer.closeTrack(track.id);\n            })());\n        }\n        else {\n            // We need to decode & reencode the audio\n            const canDecode = await track.canDecode();\n            if (!canDecode) {\n                this.discardedTracks.push({\n                    track,\n                    reason: 'undecodable_source_codec',\n                });\n                return;\n            }\n            let codecOfChoice = null;\n            if (trackOptions.codec) {\n                audioCodecs = audioCodecs.filter(codec => codec === trackOptions.codec);\n            }\n            const bitrate = trackOptions.bitrate ?? QUALITY_HIGH;\n            const encodableCodecs = await getEncodableAudioCodecs(audioCodecs, {\n                numberOfChannels: trackOptions.process && trackOptions.processedNumberOfChannels\n                    ? trackOptions.processedNumberOfChannels\n                    : numberOfChannels,\n                sampleRate: trackOptions.process && trackOptions.processedSampleRate\n                    ? trackOptions.processedSampleRate\n                    : sampleRate,\n                bitrate,\n            });\n            if (!encodableCodecs.some(codec => NON_PCM_AUDIO_CODECS.includes(codec))\n                && audioCodecs.some(codec => NON_PCM_AUDIO_CODECS.includes(codec))\n                && (numberOfChannels !== FALLBACK_NUMBER_OF_CHANNELS || sampleRate !== FALLBACK_SAMPLE_RATE)) {\n                // We could not find a compatible non-PCM codec despite the container supporting them. This can be\n                // caused by strange channel count or sample rate configurations. Therefore, let's try again but with\n                // fallback parameters.\n                const encodableCodecsWithDefaultParams = await getEncodableAudioCodecs(audioCodecs, {\n                    numberOfChannels: FALLBACK_NUMBER_OF_CHANNELS,\n                    sampleRate: FALLBACK_SAMPLE_RATE,\n                    bitrate,\n                });\n                const nonPcmCodec = encodableCodecsWithDefaultParams\n                    .find(codec => NON_PCM_AUDIO_CODECS.includes(codec));\n                if (nonPcmCodec) {\n                    // We are able to encode using a non-PCM codec, but it'll require resampling\n                    needsResample = true;\n                    codecOfChoice = nonPcmCodec;\n                    numberOfChannels = FALLBACK_NUMBER_OF_CHANNELS;\n                    sampleRate = FALLBACK_SAMPLE_RATE;\n                }\n            }\n            else {\n                codecOfChoice = encodableCodecs[0] ?? null;\n            }\n            if (codecOfChoice === null) {\n                this.discardedTracks.push({\n                    track,\n                    reason: 'no_encodable_target_codec',\n                });\n                return;\n            }\n            if (needsResample) {\n                audioSource = this._resampleAudio(track, trackOptions, codecOfChoice, numberOfChannels, sampleRate, bitrate);\n            }\n            else {\n                const source = new AudioSampleSource({\n                    codec: codecOfChoice,\n                    bitrate,\n                });\n                audioSource = source;\n                this._trackPromises.push((async () => {\n                    await this._started;\n                    const sink = new AudioSampleSink(track);\n                    for await (const sample of sink.samples(undefined, this._endTimestamp)) {\n                        if (this._canceled) {\n                            return;\n                        }\n                        await this._registerAudioSample(track, trackOptions, source, sample);\n                        sample.close();\n                    }\n                    source.close();\n                    this._synchronizer.closeTrack(track.id);\n                })());\n            }\n        }\n        this.output.addAudioTrack(audioSource, {\n            // TODO: This condition can be removed when all demuxers properly homogenize to BCP47 in v2\n            languageCode: isIso639Dash2LanguageCode(track.languageCode) ? track.languageCode : undefined,\n            name: track.name ?? undefined,\n            disposition: track.disposition,\n        });\n        this._addedCounts.audio++;\n        this._totalTrackCount++;\n        this.utilizedTracks.push(track);\n    }\n    /** @internal */\n    async _registerAudioSample(track, trackOptions, source, sample) {\n        if (this._canceled) {\n            return;\n        }\n        this._reportProgress(track.id, sample.timestamp);\n        let finalSamples;\n        if (!trackOptions.process) {\n            finalSamples = [sample];\n        }\n        else {\n            let processed = trackOptions.process(sample);\n            if (processed instanceof Promise)\n                processed = await processed;\n            if (!Array.isArray(processed)) {\n                processed = processed === null ? [] : [processed];\n            }\n            if (!processed.every(x => x instanceof AudioSample)) {\n                throw new TypeError('The audio process function must return an AudioSample, null, or an array of AudioSamples.');\n            }\n            finalSamples = processed;\n        }\n        for (const finalSample of finalSamples) {\n            if (this._canceled) {\n                break;\n            }\n            await source.add(finalSample);\n            if (this._synchronizer.shouldWait(track.id, finalSample.timestamp)) {\n                await this._synchronizer.wait(finalSample.timestamp);\n            }\n        }\n        for (const finalSample of finalSamples) {\n            if (finalSample !== sample) {\n                finalSample.close();\n            }\n        }\n    }\n    /** @internal */\n    _resampleAudio(track, trackOptions, codec, targetNumberOfChannels, targetSampleRate, bitrate) {\n        const source = new AudioSampleSource({\n            codec,\n            bitrate,\n        });\n        this._trackPromises.push((async () => {\n            await this._started;\n            const resampler = new AudioResampler({\n                targetNumberOfChannels,\n                targetSampleRate,\n                startTime: this._startTimestamp,\n                endTime: this._endTimestamp,\n                onSample: async (sample) => {\n                    await this._registerAudioSample(track, trackOptions, source, sample);\n                    sample.close();\n                },\n            });\n            const sink = new AudioSampleSink(track);\n            const iterator = sink.samples(this._startTimestamp, this._endTimestamp);\n            for await (const sample of iterator) {\n                if (this._canceled) {\n                    return;\n                }\n                await resampler.add(sample);\n                sample.close();\n            }\n            await resampler.finalize();\n            source.close();\n            this._synchronizer.closeTrack(track.id);\n        })());\n        return source;\n    }\n    /** @internal */\n    _reportProgress(trackId, endTimestamp) {\n        if (!this._computeProgress) {\n            return;\n        }\n        assert(this._totalDuration !== null);\n        this._maxTimestamps.set(trackId, Math.max(endTimestamp, this._maxTimestamps.get(trackId)));\n        const minTimestamp = Math.min(...this._maxTimestamps.values());\n        const newProgress = clamp(minTimestamp / this._totalDuration, 0, 1);\n        if (newProgress !== this._lastProgress) {\n            this._lastProgress = newProgress;\n            this.onProgress?.(newProgress);\n        }\n    }\n}\nconst MAX_TIMESTAMP_GAP = 5;\n/**\n * Utility class for synchronizing multiple track packet consumers with one another. We don't want one consumer to get\n * too out-of-sync with the others, as that may lead to a large number of packets that need to be internally buffered\n * before they can be written. Therefore, we use this class to slow down a consumer if it is too far ahead of the\n * slowest consumer.\n */\nclass TrackSynchronizer {\n    constructor() {\n        this.maxTimestamps = new Map(); // Track ID -> timestamp\n        this.resolvers = [];\n    }\n    computeMinAndMaybeResolve() {\n        let newMin = Infinity;\n        for (const [, timestamp] of this.maxTimestamps) {\n            newMin = Math.min(newMin, timestamp);\n        }\n        for (let i = 0; i < this.resolvers.length; i++) {\n            const entry = this.resolvers[i];\n            if (entry.timestamp - newMin < MAX_TIMESTAMP_GAP) {\n                // The gap has gotten small enough again, the consumer can continue again\n                entry.resolve();\n                this.resolvers.splice(i, 1);\n                i--;\n            }\n        }\n        return newMin;\n    }\n    shouldWait(trackId, timestamp) {\n        this.maxTimestamps.set(trackId, Math.max(timestamp, this.maxTimestamps.get(trackId) ?? -Infinity));\n        const newMin = this.computeMinAndMaybeResolve();\n        return timestamp - newMin >= MAX_TIMESTAMP_GAP; // Should wait if it is too far ahead of the slowest consumer\n    }\n    wait(timestamp) {\n        const { promise, resolve } = promiseWithResolvers();\n        this.resolvers.push({\n            timestamp,\n            resolve,\n        });\n        return promise;\n    }\n    closeTrack(trackId) {\n        this.maxTimestamps.delete(trackId);\n        this.computeMinAndMaybeResolve();\n    }\n}\n/**\n * Utility class to handle audio resampling, handling both sample rate resampling as well as channel up/downmixing.\n * The advantage over doing this manually rather than using OfflineAudioContext to do it for us is the artifact-free\n * handling of putting multiple resampled audio samples back to back, which produces flaky results using\n * OfflineAudioContext.\n */\nexport class AudioResampler {\n    constructor(options) {\n        this.sourceSampleRate = null;\n        this.sourceNumberOfChannels = null;\n        this.targetSampleRate = options.targetSampleRate;\n        this.targetNumberOfChannels = options.targetNumberOfChannels;\n        this.startTime = options.startTime;\n        this.endTime = options.endTime;\n        this.onSample = options.onSample;\n        this.bufferSizeInFrames = Math.floor(this.targetSampleRate * 5.0); // 5 seconds\n        this.bufferSizeInSamples = this.bufferSizeInFrames * this.targetNumberOfChannels;\n        this.outputBuffer = new Float32Array(this.bufferSizeInSamples);\n        this.bufferStartFrame = 0;\n        this.maxWrittenFrame = -1;\n    }\n    /**\n     * Sets up the channel mixer to handle up/downmixing in the case where input and output channel counts don't match.\n     */\n    doChannelMixerSetup() {\n        assert(this.sourceNumberOfChannels !== null);\n        const sourceNum = this.sourceNumberOfChannels;\n        const targetNum = this.targetNumberOfChannels;\n        // Logic taken from\n        // https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Basic_concepts_behind_Web_Audio_API\n        // Most of the mapping functions are branchless.\n        if (sourceNum === 1 && targetNum === 2) {\n            // Mono to Stereo: M -> L, M -> R\n            this.channelMixer = (sourceData, sourceFrameIndex) => {\n                return sourceData[sourceFrameIndex * sourceNum];\n            };\n        }\n        else if (sourceNum === 1 && targetNum === 4) {\n            // Mono to Quad: M -> L, M -> R, 0 -> SL, 0 -> SR\n            this.channelMixer = (sourceData, sourceFrameIndex, targetChannelIndex) => {\n                return sourceData[sourceFrameIndex * sourceNum] * +(targetChannelIndex < 2);\n            };\n        }\n        else if (sourceNum === 1 && targetNum === 6) {\n            // Mono to 5.1: 0 -> L, 0 -> R, M -> C, 0 -> LFE, 0 -> SL, 0 -> SR\n            this.channelMixer = (sourceData, sourceFrameIndex, targetChannelIndex) => {\n                return sourceData[sourceFrameIndex * sourceNum] * +(targetChannelIndex === 2);\n            };\n        }\n        else if (sourceNum === 2 && targetNum === 1) {\n            // Stereo to Mono: 0.5 * (L + R)\n            this.channelMixer = (sourceData, sourceFrameIndex) => {\n                const baseIdx = sourceFrameIndex * sourceNum;\n                return 0.5 * (sourceData[baseIdx] + sourceData[baseIdx + 1]);\n            };\n        }\n        else if (sourceNum === 2 && targetNum === 4) {\n            // Stereo to Quad: L -> L, R -> R, 0 -> SL, 0 -> SR\n            this.channelMixer = (sourceData, sourceFrameIndex, targetChannelIndex) => {\n                return sourceData[sourceFrameIndex * sourceNum + targetChannelIndex] * +(targetChannelIndex < 2);\n            };\n        }\n        else if (sourceNum === 2 && targetNum === 6) {\n            // Stereo to 5.1: L -> L, R -> R, 0 -> C, 0 -> LFE, 0 -> SL, 0 -> SR\n            this.channelMixer = (sourceData, sourceFrameIndex, targetChannelIndex) => {\n                return sourceData[sourceFrameIndex * sourceNum + targetChannelIndex] * +(targetChannelIndex < 2);\n            };\n        }\n        else if (sourceNum === 4 && targetNum === 1) {\n            // Quad to Mono: 0.25 * (L + R + SL + SR)\n            this.channelMixer = (sourceData, sourceFrameIndex) => {\n                const baseIdx = sourceFrameIndex * sourceNum;\n                return 0.25 * (sourceData[baseIdx] + sourceData[baseIdx + 1]\n                    + sourceData[baseIdx + 2] + sourceData[baseIdx + 3]);\n            };\n        }\n        else if (sourceNum === 4 && targetNum === 2) {\n            // Quad to Stereo: 0.5 * (L + SL), 0.5 * (R + SR)\n            this.channelMixer = (sourceData, sourceFrameIndex, targetChannelIndex) => {\n                const baseIdx = sourceFrameIndex * sourceNum;\n                return 0.5 * (sourceData[baseIdx + targetChannelIndex]\n                    + sourceData[baseIdx + targetChannelIndex + 2]);\n            };\n        }\n        else if (sourceNum === 4 && targetNum === 6) {\n            // Quad to 5.1: L -> L, R -> R, 0 -> C, 0 -> LFE, SL -> SL, SR -> SR\n            this.channelMixer = (sourceData, sourceFrameIndex, targetChannelIndex) => {\n                const baseIdx = sourceFrameIndex * sourceNum;\n                // It's a bit harder to do this one branchlessly\n                if (targetChannelIndex < 2)\n                    return sourceData[baseIdx + targetChannelIndex]; // L, R\n                if (targetChannelIndex === 2 || targetChannelIndex === 3)\n                    return 0; // C, LFE\n                return sourceData[baseIdx + targetChannelIndex - 2]; // SL, SR\n            };\n        }\n        else if (sourceNum === 6 && targetNum === 1) {\n            // 5.1 to Mono: sqrt(1/2) * (L + R) + C + 0.5 * (SL + SR)\n            this.channelMixer = (sourceData, sourceFrameIndex) => {\n                const baseIdx = sourceFrameIndex * sourceNum;\n                return Math.SQRT1_2 * (sourceData[baseIdx] + sourceData[baseIdx + 1])\n                    + sourceData[baseIdx + 2]\n                    + 0.5 * (sourceData[baseIdx + 4] + sourceData[baseIdx + 5]);\n            };\n        }\n        else if (sourceNum === 6 && targetNum === 2) {\n            // 5.1 to Stereo: L + sqrt(1/2) * (C + SL), R + sqrt(1/2) * (C + SR)\n            this.channelMixer = (sourceData, sourceFrameIndex, targetChannelIndex) => {\n                const baseIdx = sourceFrameIndex * sourceNum;\n                return sourceData[baseIdx + targetChannelIndex]\n                    + Math.SQRT1_2 * (sourceData[baseIdx + 2] + sourceData[baseIdx + targetChannelIndex + 4]);\n            };\n        }\n        else if (sourceNum === 6 && targetNum === 4) {\n            // 5.1 to Quad: L + sqrt(1/2) * C, R + sqrt(1/2) * C, SL, SR\n            this.channelMixer = (sourceData, sourceFrameIndex, targetChannelIndex) => {\n                const baseIdx = sourceFrameIndex * sourceNum;\n                // It's a bit harder to do this one branchlessly\n                if (targetChannelIndex < 2) {\n                    return sourceData[baseIdx + targetChannelIndex] + Math.SQRT1_2 * sourceData[baseIdx + 2];\n                }\n                return sourceData[baseIdx + targetChannelIndex + 2]; // SL, SR\n            };\n        }\n        else {\n            // Discrete fallback: direct mapping with zero-fill or drop\n            this.channelMixer = (sourceData, sourceFrameIndex, targetChannelIndex) => {\n                return targetChannelIndex < sourceNum\n                    ? sourceData[sourceFrameIndex * sourceNum + targetChannelIndex]\n                    : 0;\n            };\n        }\n    }\n    ensureTempBufferSize(requiredSamples) {\n        let length = this.tempSourceBuffer.length;\n        while (length < requiredSamples) {\n            length *= 2;\n        }\n        if (length !== this.tempSourceBuffer.length) {\n            const newBuffer = new Float32Array(length);\n            newBuffer.set(this.tempSourceBuffer);\n            this.tempSourceBuffer = newBuffer;\n        }\n    }\n    async add(audioSample) {\n        if (this.sourceSampleRate === null) {\n            // This is the first sample, so let's init the missing data. Initting the sample rate from the decoded\n            // sample is more reliable than using the file's metadata, because decoders are free to emit any sample rate\n            // they see fit.\n            this.sourceSampleRate = audioSample.sampleRate;\n            this.sourceNumberOfChannels = audioSample.numberOfChannels;\n            // Pre-allocate temporary buffer for source data\n            this.tempSourceBuffer = new Float32Array(this.sourceSampleRate * this.sourceNumberOfChannels);\n            this.doChannelMixerSetup();\n        }\n        const requiredSamples = audioSample.numberOfFrames * audioSample.numberOfChannels;\n        this.ensureTempBufferSize(requiredSamples);\n        // Copy the audio data to the temp buffer\n        const sourceDataSize = audioSample.allocationSize({ planeIndex: 0, format: 'f32' });\n        const sourceView = new Float32Array(this.tempSourceBuffer.buffer, 0, sourceDataSize / 4);\n        audioSample.copyTo(sourceView, { planeIndex: 0, format: 'f32' });\n        const inputStartTime = audioSample.timestamp - this.startTime;\n        const inputDuration = audioSample.numberOfFrames / this.sourceSampleRate;\n        const inputEndTime = Math.min(inputStartTime + inputDuration, this.endTime - this.startTime);\n        // Compute which output frames are affected by this sample\n        const outputStartFrame = Math.floor(inputStartTime * this.targetSampleRate);\n        const outputEndFrame = Math.ceil(inputEndTime * this.targetSampleRate);\n        for (let outputFrame = outputStartFrame; outputFrame < outputEndFrame; outputFrame++) {\n            if (outputFrame < this.bufferStartFrame) {\n                continue; // Skip writes to the past\n            }\n            while (outputFrame >= this.bufferStartFrame + this.bufferSizeInFrames) {\n                // The write is after the current buffer, so finalize it\n                await this.finalizeCurrentBuffer();\n                this.bufferStartFrame += this.bufferSizeInFrames;\n            }\n            const bufferFrameIndex = outputFrame - this.bufferStartFrame;\n            assert(bufferFrameIndex < this.bufferSizeInFrames);\n            const outputTime = outputFrame / this.targetSampleRate;\n            const inputTime = outputTime - inputStartTime;\n            const sourcePosition = inputTime * this.sourceSampleRate;\n            const sourceLowerFrame = Math.floor(sourcePosition);\n            const sourceUpperFrame = Math.ceil(sourcePosition);\n            const fraction = sourcePosition - sourceLowerFrame;\n            // Process each output channel\n            for (let targetChannel = 0; targetChannel < this.targetNumberOfChannels; targetChannel++) {\n                let lowerSample = 0;\n                let upperSample = 0;\n                if (sourceLowerFrame >= 0 && sourceLowerFrame < audioSample.numberOfFrames) {\n                    lowerSample = this.channelMixer(sourceView, sourceLowerFrame, targetChannel);\n                }\n                if (sourceUpperFrame >= 0 && sourceUpperFrame < audioSample.numberOfFrames) {\n                    upperSample = this.channelMixer(sourceView, sourceUpperFrame, targetChannel);\n                }\n                // For resampling, we do naive linear interpolation to find the in-between sample. This produces\n                // suboptimal results especially for downsampling (for which a low-pass filter would first need to be\n                // applied), but AudioContext doesn't do this either, so, whatever, for now.\n                const outputSample = lowerSample + fraction * (upperSample - lowerSample);\n                // Write to output buffer (interleaved)\n                const outputIndex = bufferFrameIndex * this.targetNumberOfChannels + targetChannel;\n                this.outputBuffer[outputIndex] += outputSample; // Add in case of overlapping samples\n            }\n            this.maxWrittenFrame = Math.max(this.maxWrittenFrame, bufferFrameIndex);\n        }\n    }\n    async finalizeCurrentBuffer() {\n        if (this.maxWrittenFrame < 0) {\n            return; // Nothing to finalize\n        }\n        const samplesWritten = (this.maxWrittenFrame + 1) * this.targetNumberOfChannels;\n        const outputData = new Float32Array(samplesWritten);\n        outputData.set(this.outputBuffer.subarray(0, samplesWritten));\n        const timestampSeconds = this.bufferStartFrame / this.targetSampleRate;\n        const audioSample = new AudioSample({\n            format: 'f32',\n            sampleRate: this.targetSampleRate,\n            numberOfChannels: this.targetNumberOfChannels,\n            timestamp: timestampSeconds,\n            data: outputData,\n        });\n        await this.onSample(audioSample);\n        this.outputBuffer.fill(0);\n        this.maxWrittenFrame = -1;\n    }\n    finalize() {\n        return this.finalizeCurrentBuffer();\n    }\n}\n"],
  "mappings": "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",
  "names": ["bytes", "view", "url", "bytes", "level", "bytes", "view", "AvcNalUnitType", "HevcNalUnitType", "bytes", "view", "FlacBlockType", "u8", "view", "keyPacket", "sample", "finalSample", "view", "view", "startPos", "bytes", "sampleSize", "boxInfo", "slice", "sampleIndex", "EBMLId", "bytes", "bytes", "BlockLacing", "ContentEncodingScope", "ContentCompAlgo", "slice", "_a", "Id3V2HeaderFlags", "Id3V2TextEncoding", "bytes", "size", "slice", "bytes", "view", "bytes", "view", "startPosition", "WaveFormat", "slice", "bytes", "readFrameHeader", "bytes", "readFrameHeader", "bytes", "bytes", "id", "slice", "readFrameHeader", "url", "data", "bytes", "worker", "entry", "bytes", "view", "bytes", "box", "bytes", "nodeAlias", "node", "nodeAlias", "box", "body", "sample", "trackData", "movieBox", "bytes", "relativeTimestamp", "view", "view", "word", "bytes", "view", "slice", "bytes", "_a", "_b", "colorChunk", "view", "url", "track"]
}
